#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 3cm
\headsep 3cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Servicios Telemáticos
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Date
2019/2020
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introducción a los SSTT.
 Servicios de información y aplicaciones de red
\end_layout

\begin_layout Subsection
¿Qué es Internet?
\end_layout

\begin_layout Subsubsection*
Una descripción esencial
\end_layout

\begin_layout Standard
\align block
Internet es una red de ordenadores que interconecta centenares de millones
 de dispositivos en el mundo.
 Estos dispositivos se llaman 
\series bold
hosts o sistemas finales
\series default
.
 Estos están conectados entre sí mediante una red de 
\series bold
enlaces de comunicación 
\series default
y 
\series bold
encaminadores de paquetes 
\series default
(packet switch).
 
\end_layout

\begin_layout Standard
\align block
Diferentes enlaces pueden transmitir datos a diferentes tasas, midiendose
 la 
\series bold
tasa de transmisión 
\series default
de un enlace en bits/segundo.
\end_layout

\begin_layout Standard
\align block
Cuando un sistema final tiene datos que enviar a otro sistema final, el
 que envía segmenta los datos y añade bytes de encabezamiento a cada segmento.
 Los paquetes de información resultantes, conocidos como 
\series bold
paquetes
\series default
, se envían a través de la red hacia el sistema final destino, donde se
 reensamblan para contener la misma información que antes de ser dividido.
 
\end_layout

\begin_layout Standard
\align block
Un encaminador toma paquetes que llegan a uno de sus enlaces de entrada
 y los envía a través de uno de sus enlaces de salida.
 Los dos tipos de encaminador más importantes en internet son los routers
 y los switch de la capa de enlace.
 Ambos tipos reenvían paquetes hacia su destino final.
 
\end_layout

\begin_layout Standard
\align block
Los 
\series bold
switch de la capa de enlace 
\series default
son usados en redes de acceso.
\end_layout

\begin_layout Standard
\align block
Los 
\series bold
routers 
\series default
son usados en el centro (core) de la red.
 
\end_layout

\begin_layout Standard
\align block
La secuencia de enlaces de comunicación y encaminadores atravesados por
 un paquete desde el host que envía hasta el que recibe se conoce como 
\series bold
ruta 
\series default
o 
\series bold
camino
\series default
.
\end_layout

\begin_layout Standard
\align block
Los sistemas finales acceden la internet a través de 
\series bold
ISPs (Internet Service Providers)
\series default
, que pueden ser residenciales, corporativos, universitarios y los ISP que
 proporcionan acceso WiFi en espacios públicos.
 Cada ISP es, en sí mismo, una red de encaminadores de paquetes y hosts.
 Los ISPs proporcionan variedad de tipos de acceso a redes a los sitemas
 finales, incluyendo acceso residencial con banda ancha como modem por cáble
 o DSL.
 También proporcionan acceso a internet a proveedores de contenido, conectando
 sitios web directamente a la internet.
 
\end_layout

\begin_layout Standard
\align block
Los ISPs que proporcionan acceso a sistemas finales tienen que estar tamibén
 interconectados.
 Estos ISPs de los niveles bajos están interconectados a través de otros
 ISPs de niveles superiores, nacionales o internacionales, como Level 3
 Communications o AT&T.
\end_layout

\begin_layout Standard
\align block
Un IPS de nivel superior consiste en routers de alta velocidad interconectados
 con enlaces de fibra óptica de alta velocidad.
 Cada red ISP, ya sea inferior o superior, se controla independientemente,
 usa los protocolos IP y se ajusta a ciertas convenciones de nombres y direccion
es.
\end_layout

\begin_layout Standard
\align block
Los sistemas finales, los switches y otras partes de la internet usan 
\series bold
protocolos 
\series default
que controlan el envío y recepción de información a través de internet.
\end_layout

\begin_layout Standard
\align block
El 
\series bold
protocolo IP 
\series default
especifica el formato de los paquetes que se envían y reciben por routers
 y sistemas finales.
 Los principales protocolos de internet se conocen conjuntamente como 
\series bold
TCP/IP
\series default
.
\end_layout

\begin_layout Standard
\align block
Los 
\series bold
estándars de internet 
\series default
se desarrollaron por el Internet Engineering Task Force.
 Los documentos de estandarización de IETF se conocen como 
\series bold
requests for comments (RFCs)
\series default
, y suelen ser bastante técnicos y detallados.
 Se usan para definir protocolos.
\end_layout

\begin_layout Subsubsection*
Una descripción de servicios
\end_layout

\begin_layout Standard
\align block
Internet puede definirse como 
\begin_inset Quotes eld
\end_inset

una infraestructura que proporciona sercicios a distintas aplicaciones
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\align block
Las aplicaciones se dice que son 
\series bold
aplicaciones distribuidas
\series default
, ya que involucran diferentes sistemas finales que itnercambian datos entre
 ellos.
 Las aplicaciones de internet se ejecutan en los hosts y no en los encaminadores.
 Aunque los encaminadores facilitan el intercambio de datos entre hosts,
 ellos no tienen nada que ver con la aplicación que genera o recibe los
 datos.
\end_layout

\begin_layout Standard
\align block
Los hosts conectados a intrnet proporcionan una 
\series bold
Application Programming Interface (API)
\series default
, que especifica cómo un programa ejecutándose en un hosts pide a la infraestruc
tura de internet que lleve datos a un programa destino específico, que se
 ejecuta en otro host.
 Esta API de internet es un conjunto de reglas que el programa que envía
 tiene que seguir para que internet pueda entregar los datos al programa
 destino.
\end_layout

\begin_layout Subsubsection*
¿Qué es un protocolo?
\end_layout

\begin_layout Standard
\align block
Un protocolo define el formato y el orden de los mensajes intercambiados
 entre dos o más entidades de comunicación, así como las acciones llevadas
 a cabo en la transmisión y/o recepción de un mensaje o algún otro evento.
\end_layout

\begin_layout Standard
\align block
Cualquier actividad en Internet que involucre dos o más entidades de comunicació
n remotas debe usar un protocolo.
\end_layout

\begin_layout Subsection
El extremo de la red
\end_layout

\begin_layout Standard
\align block
Los hosts se pueden dividir en dos categorías:
\end_layout

\begin_layout Itemize
\align block

\series bold
Clientes: 
\series default
suelen ser ordenadores portátiles y de escritorio, smartphones,...
\end_layout

\begin_layout Itemize
\align block

\series bold
Servidores: 
\series default
son máquinas más potentes que almacenan y distribuyen páginas web, video
 streaming, retransmiten emails,...
 La mayoría de los servidores de los que recibimos información están localizados
 en grandes 
\series bold
centros de datos
\series default
.
\end_layout

\begin_layout Subsubsection*
Redes de acceso
\end_layout

\begin_layout Standard
\align block
Una red de acceso es una red que conecta físicamente un host al primer router
 (
\series bold
edge router
\series default
) en un camino desde el host hasta cualquier otro host distante.
\end_layout

\begin_layout Subsubsection*
Acceso de hogar: DSL, Cable, FTTH, línea conmutada, y satélite
\end_layout

\begin_layout Itemize
\noindent
\align block

\series bold
Digital Subscriber Line (DSL): 
\series default
una residencia normalmente obtiene conexión DSL a internet de la misma compañia
 de teléfono local que proporciona su acceso local inalámbrico telefónico.
 Cuando se usa DSL, estas compañías actúan como ISP.
 
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align block
Cada módem DSL de un 
\bar under
consumidor
\bar default
 usa la línea de teléfono existente para intercambiar datos con un multiplexor
 de acceso de línea de abonado digital (DSLAM) localizado en la oficina
 central local de la compañía (CO).
 El módem DSL del hogar toma datos digitales y los traduce a ondas de alta
 frecuencia para ser transmitidos por los cables telefónicos hasta el CO;
 las señales analógicas de muchos hogares se vuelven a traducir de forma
 inversa en formato digital en el DSLAM.
 
\end_layout

\begin_layout Standard
\noindent
\align block
La línea residencial telefónica lleva tanto datos como la señal telefónica
 tradicional simultáneamente, por lo que deben codificarse en distintas
 frecuencias:
\end_layout

\begin_layout Itemize
\noindent
\align block
Canal de bajada de alta velocidad: 50kHz-1MHz
\end_layout

\begin_layout Itemize
\noindent
\align block
Canal de subida de velocidad media: 4-50kHz
\end_layout

\begin_layout Itemize
\noindent
\align block
Canal telefónico de doble sentido: 0-4kHz
\end_layout

\begin_layout Standard
\noindent
\align block
Esto hace que un único enlace DSL funcione como si albergase tres enlaces
 distintos, de forma que una llamada telefónica y una conexión a internet
 pueden compartir el enlace DSL.
\end_layout

\begin_layout Standard
\noindent
\align block
En el lado del cliente, un separador (splitter) divide los datos y las señales
 telefónicas que llegan al hogar y reenvía la señal de datos al módem DSL.
\end_layout

\begin_layout Standard
\noindent
\align block
En el lado de la compañía, en la CO, el DSLAM separa los datos y las señales
 telefónicas y envía los datos hacia internet.
\end_layout

\begin_layout Standard
\noindent
\align block
Como las tasas de subida (1.8Mbps ó 2.5Mbps) y bajada (12Mbps ó 24Mbps) son
 distintas, el acceso se dice que es 
\series bold
asimétrico
\series default
.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/redDSL.png

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\noindent
\align block

\series bold
Acceso a internet por cable: 
\series default
hace uso del cable preexistente de las compañías de televisión.
 Una residencia obtiene acceso a internet por cable de la misma compañía
 que le proporciona televisión por cable.
 La 
\series bold
fibra óptica
\series default
 conecta la cabeza del cable a una intersección a nivel de vecindario, desde
 donde el cable coaxial tradicional se usa para alcanzar los hogares individuale
s.
 Como en este sistema se usan tanto fibra óptica como cable coaxial, a veces
 se le llama 
\series bold
hybrid fiber coax (HFC)
\series default
.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align block
El acceso por cable a internet requiere de módems especiales, llamados módems
 de cable.
 Como los módem DSL, los de cable normalmente son un dispositivo externo
 y conectan con el PC del hogar a través de un puerto ethernet.
\end_layout

\begin_layout Standard
\noindent
\align block
En la cabeza del cable, el sistema terminal del módem de cable (CMTS) hace
 una función similar a la del DSLAM en las redes DSL.
 O sea, los módems de cable dividen la red HFC en dos canales, uno de bajada
 y otro de subida.
 El acceso es, como antes, asimétrico.
\end_layout

\begin_layout Standard
\noindent
\align block
Otra característica importante del acceso por cable a internet es que es
 un medio de broadcast compartido, esto quiere decir que todo paquete envíado
 por la cabeza viaja por el camino de bajada por todos los enlaces de todos
 los hogares conectados y todo paquete envíado por un hogar viaja por el
 camino de subida hasta la cabeza.
 Por este motivo, si varios usuarios están descargando un video por el canal
 de bajada, la tasa a la que cada usuario recibe el vídeo será significativament
e menor que la tasa de bajada agregada del cable.
 Si hay pocos usuarios sus tasas de bajada serán mayores.
\end_layout

\begin_layout Standard
\noindent
\align block
Como el canal de subida también es compartido, se hace necesario un protocolo
 de acceso múltiple y distribuido para coordinar transmisiones y evitar
 colisiones.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/redHFC.png
	scale 75

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\noindent
\align block

\series bold
FTTH (Fiber To The Home, 
\series default
fibra hasta el hogar
\series bold
): 
\series default
es un concepto simple, proporcionar un camino de fibra óptica desde el CO
 directamente al hogar.
\end_layout

\begin_deeper
\begin_layout Standard
\noindent
\align block
Hay varias tecnologías compitiendo en este nicho.
 La red de distribución de fibra más simple es la 
\series bold
fibra directa
\series default
, con una fibra saliendo de la CO para cada hogar.
 Más comúnmente, cada fibra que sale de la CO se comparte por varios hogares,
 y no es hasta que la fibra está relativamente cerca de los hogares cuando
 se separa en fibras individuales para cada consumidor.
 Para esta segunda opción hay dos principales tecnologías competidoras:
 
\end_layout

\begin_layout Itemize
\noindent
\align block

\series bold
Active optical networks (AON): 
\series default
esencialmente ethernet conmutado
\end_layout

\begin_layout Itemize
\noindent
\align block

\series bold
Passive optical networks (PON): 
\series default
cada hogar tiene un terminal de red óptica (ONT), que se conecta por una
 fibra óptica dedicada a un separador por vecindario.
 El separador combina una cantidad de hogares en una única y compartida
 fibra óptica, que conecta a un terminal de línea óptica (OLT) en la CO
 de la compañía.
 El OLT proporciona la conversión entre señales ópticas y electricas, conecta
 a internet por un router de la compañía.
 En el hogar, los usuarios conectan un router de hogar (normalmente inalámbrico)
 al ONT y acceden internet vía este router del hogar.
 En la arquitectura PON, todos los paquetes envíados desde el OLT al separador
 son duplicados en el separador.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/redFTTH.png

\end_inset


\end_layout

\begin_layout Standard
\align block
FTTH potencialmente puede proporcionar tasas de acceso a internet del orden
 de los gigabits por segundo.
\end_layout

\end_deeper
\begin_layout Itemize
\align block
Otras dos tecnologías de acceso a la red son usadas para proporcionar conexión
 a internet desde el hogar.
\end_layout

\begin_deeper
\begin_layout Itemize
\align block

\series bold
Enlace por satélite: 
\series default
puede ser usado para conectar una residencia al internet a velocidades superiore
s a 1Mbps
\end_layout

\begin_layout Itemize
\align block

\series bold
Enlace por línea conmutada: 
\series default
se apoya sobre las líneas telefónicas tradicionales y se basa en la misma
 idea que DSL.
 Un módem de hogar conecta por una línea telefónica a un módem en el ISP.

\series bold
 
\end_layout

\end_deeper
\begin_layout Subsubsection*
Acceso en la empresa (y el hogar): Ethernet y WiFi
\end_layout

\begin_layout Standard
\align block
En las empresas y los campus de las universidades, y, cada vez más, en los
 hogares, es normal usar una 
\series bold
red de área local (LAN) 
\series default
para conectar un sistema final al router frontera.
 Aunque hay diversos tipos de tecnologías LAN, 
\series bold
Ethernet 
\series default
es la más extendida.
\end_layout

\begin_layout Standard
\align block
Los usuarios de Ethernet usan cable de cobre de par trenzado para conectarse
 a un switch Ethernet.
 Este, o una red de switches interconectados, entonces se conecta a la internet.
 Con el acceso Ethernet, los usuarios normalmente tienen 100Mbps de acceso
 al switch Ethernet.
\end_layout

\begin_layout Standard
\align block
La gente, cada vez más, está accediendo la internet inalámbricamente, desde
 portátiles, móviles,...
 En una 
\series bold
configuración LAN inalámbrica
\series default
 los usuarios envían/reciben paquetes a/desde un punto de acceso que está
 conectado a la red de la empresa o el hogar, que estará conectada a la
 internet cableada.
 Los usuarios de una LAN inalámbrica deben estar a unas pocas decenas de
 metros del punto de acceso si estamos hablando de tecnología IEEE 802.11
 o 
\series bold
WiFi
\series default
.
\end_layout

\begin_layout Standard
\align block
Aunque las redes de acceso por Ethernet o WiFi inicialmente se desplegaron
 en la empresa, cada vez es más normal verlas en los hogares.
 Muchos hogares combinan acceso residencial de banda ancha con estas tecnologías
 LAN inalámbricas, que son baratas, para crear potentes redes en el hogar.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/redLAN.png
	scale 30

\end_inset


\end_layout

\begin_layout Subsubsection*
Acceso Inalámbrico de Larga Distancia: 3G y LTE
\end_layout

\begin_layout Standard
\align block
Las compañías de telecomunicaciones han hecho enormes inversiones en las
 tecnologías llamadas 
\series bold
inalámbricas de tercera generación (3G)
\series default
, que proporcionan acceso inalámbrico a internet en una gran área y por
 conmutación de paquetes, a unas velocidades de 1Mbps.
\end_layout

\begin_layout Standard

\series bold
LTE (Long Term Evolution) 
\series default
se basa en las tecnologías 3G y puede, potencialmente, alcanzar tasas de
 10Mbps.
\end_layout

\begin_layout Subsubsection
Medios físicos
\end_layout

\begin_layout Standard
\align block
Los medios físicos pueden ser de varios tipos e, incluso, en una ruta de
 internet pueden haber diferentes medios físicos involucrados.
 Podemos dividirlos en dos categorías:
\end_layout

\begin_layout Itemize
\align block

\series bold
Medios guiados: 
\series default
las ondas son guiadas a través de un medio sólido
\end_layout

\begin_layout Itemize
\align block

\series bold
Medios no-guiados: 
\series default
las ondas se propagan en la atmósfera o en el espacio
\end_layout

\begin_layout Standard
\align block
El coste actual de los enlaces físicos suele ser relativamente pequeño comparado
 con otros costes de la red.
 Es particularmente cara la instalación de los enlaces físicos, mucho más
 que el propio enlace.
\end_layout

\begin_layout Subsubsection*
Cable par trenzado de cobre
\end_layout

\begin_layout Standard
\align block
Es el menos caro y el más utilizado de los medios guiados.
\end_layout

\begin_layout Standard
\align block
Consiste en dos cables de cobre aislados, cada uno de 1mm de ancho, posicionados
 en un patrón regular en espiral.
 Los cables se enrollan juntos para reducir la interferencia eléctrica de
 otros pares similares cercanos.
\end_layout

\begin_layout Standard
Normalmente, una cantidad de pares se agrupan en un cable envolviéndolos
 en un escudo protector.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/parTrenzado.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align block
Un par cableado constituye un único enlace de comunicación.
\end_layout

\begin_layout Standard
\align block
El 
\series bold
par trenzado sin escudo (UTP) 
\series default
se usa en redes de ordenadores dentro de un edificio, con tasas entre 10Mbps
 y 10Gbps.
\end_layout

\begin_layout Standard
\align block
La tecnología moderna de par trenzado puede alcanzar tasas de 10Gbps en
 distancias de hasta cientos de metros.
 Así, el apr trenzado se ha posicionado como la solución dominante para
 las redes LAN de alta velocidad.
\end_layout

\begin_layout Subsubsection*
Cable coaxial
\end_layout

\begin_layout Standard
\align block
Consiste en dos conductores de cobre, pero en este caso son concéntricos.
 Con esta construcción y esta separación y protección, el cable coaxial
 puede alcanzar grandes tasas de transmisión.
 Es muy usado en sistemas de televisión por cable.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/coaxial.png
	scale 40

\end_inset


\end_layout

\begin_layout Standard
\align block
En televisión por cable y acceso a internet por cable, el transmisor cambia
 la señal digital original a una frecuencia específica, y la señal analógica
 resultante es enviada desde el transmisor a uno o más receptores.
 El cable coaxial puede usarse como un medio guiado compartido.
\end_layout

\begin_layout Subsubsection*
Fibra óptica
\end_layout

\begin_layout Standard
\align block
Es un medio fino y flexible que conduce pulsos de luz, con cada pulso representa
ndo un bit.
 Una única fibra óptica puede transmitir a altas tasas, hasta las decenas
 o centenares de Gbps.
 Son inmunes a las interferencias electromagnéticas y tienen muy poca atenuación
 de la señal hasta los 100Km, además son muy difíciles de interceptar por
 agentes indeseados.
 Estas características hacen de la fibra óptica el medio guiado preferido
 para recorridos largos, particularmente para enlaces transoceánicos.
\end_layout

\begin_layout Standard
\align block
La fibra óptica es predominante también en el backbone de internet.
 
\end_layout

\begin_layout Standard
\align block
Sin embargo, el alto coste de los dispositivos ópticos ha obstaculizado
 su desplegamiento para transporte de corta distancia.
\end_layout

\begin_layout Subsubsection*
Canales de radio terrestres
\end_layout

\begin_layout Standard
\align block
Los canales de radio transmiten señales del espectro electromagnético.
 Son medios atractivos porque no requieren cables que instalar, pueden atravesar
 paredes, dar conexión a usuarios móviles y, potencialmente, transmitir
 señales en largas distancias.
\end_layout

\begin_layout Standard
\align block
Las características de un canal de radio depende mucho del entorno de propagació
n y de la distancia que la señal debe atravesar.
 Las condiciones del entorno pueden determinar la aparición de pérdidas
 de información o disipación de las ondas, interferencias de una señal consigo
 misma debido a rebotes e interferencias con otras señales.
\end_layout

\begin_layout Standard
\align block
Pueden ser clasificados en tres grupos: los que operan en distancias muy
 cortas; los que operan en áreas locales (10 a algunos cientos de metros);
 y los que operan en grandes áreas (decenas de kilómetros).
\end_layout

\begin_layout Subsubsection*
Canales de radio por satélite
\end_layout

\begin_layout Standard
\align block
Un satélite de comunicación enlaza dos o más transmisores/receptores de
 microondas localizados en la tierra, conocidos como estaciones terrestres.
 El satélite recibe transmisiones en una frecuencia, regenera la señal usando
 un repetidor y la trasmite en otra frecuencia.
 
\end_layout

\begin_layout Standard
\align block
En comunicaciones se usan dos tipos de satélites:
\end_layout

\begin_layout Itemize
\align block

\series bold
Satélites geoestacionarios: 
\series default
permanecen orbitando sobre el mismo punto de la tierra, a 36000Km de altura.
 El retardo de propagación es de 280 ms
\end_layout

\begin_layout Itemize
\align block

\series bold
Satélites LEO (órbita terrestre baja): 
\series default
están mucho más cerca de la tierra
\series bold
 
\series default
y no están siempre sobre el mismo punto.
 Giran alrededor de la tierra y pueden comunicarse unos con otros.
 Para proporcionar cobertura continua en un área, muchos satélites tienen
 que ser lanzados a órbita.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/satelites.png
	scale 70

\end_inset


\end_layout

\begin_layout Subsection
El núcleo de la red
\end_layout

\begin_layout Subsubsection
Conmutación de paquetes
\end_layout

\begin_layout Standard
\align block
En una aplicación de red, los hosts intercambian 
\series bold
mensajes
\series default
 entre ellos.
 Estos pueden contener lo que sea que el diseñador de la aplicación desee.
 Los mensajes pueden desarrollar una función de control o pueden contener
 datos.
 Para enviar un mensaje desde un emisor a un destino, el emisor parte los
 mensajes largos en bloques más pequeños de datos, conocidos como 
\series bold
paquetes
\series default
.
 Entre la fuente y el destino, cada paquete atraviesa enlaces de comunicación
 y encamincadores.
 Los paquetes se transmiten por cada enlace de comunicación a una tasa igual
 a la tasa total de transmisión del link.
\begin_inset Formula 
\[
t_{tr}=\frac{L}{R}
\]

\end_inset


\end_layout

\begin_layout Standard
\align block
O sea, el tiempo de transmisión es el tamaño del paquete, 
\begin_inset Formula $L$
\end_inset

, dividido entre la tasa de transferencia del enlace, 
\begin_inset Formula $R$
\end_inset

.
\end_layout

\begin_layout Subsubsection*
Transmisión por almacenamiento y reenvío (store-and-forward)
\end_layout

\begin_layout Standard
\align block
Los encaminadores deben recibir el paquete entero antes de poder transmitir
 el primer bit del paquete por el enlace de salida.
 Un router normalmente tendrá varios enlaces conectados, ya que su trabajo
 es es conmutar un paquete entrante a uno saliente.
 Veamos el proceso de envío de un paquete:
\end_layout

\begin_layout Itemize
\align block
El emisor empieza a transmitir en el instante 0.
 
\end_layout

\begin_layout Itemize
\align block
En el instante 
\begin_inset Formula $\frac{L}{R}$
\end_inset

 s, el emisor ha transmitido el paquete entero, y este ha sido recibido
 y almacenado en el router.
\end_layout

\begin_layout Itemize
\align block
En este mismo instante, como el router ya tiene el paquete entero, puede
 comenzar a transmitirlo por un enlace de salida hacia el destino.
\end_layout

\begin_layout Itemize
\align block
En el instante 
\begin_inset Formula $\frac{2L}{R}$
\end_inset

 s, el router ha transmitido el paquete entero, y este ha sido recibido
 por el destinatario.
\end_layout

\begin_layout Standard
\align block
Por tanto, el retardo total es de 
\begin_inset Formula $\frac{2L}{R}$
\end_inset

 s.
 Si el router transmitiese tan pronto como le llegan los bits, entonces
 el retraso total sería 
\begin_inset Formula $\frac{L}{R}$
\end_inset

 s, ya que los bits no esperarían en el router.
 Pero esto no es posible, los routers necesitan recibir, almacenar y procesar
 el paquete completo antes de poder enviarlo.
\end_layout

\begin_layout Standard
\align block
Ahora vamos a ver qué sucede al enviar tres paquetes:
\end_layout

\begin_layout Itemize
\align block
Igual que antes, en el instante 
\begin_inset Formula $\frac{L}{R}$
\end_inset

, el router comienza a enviar hacia el destino el primer paquete.
 Pero también en este instante el emisor comienza a enviar el segundo paquete,
 ya que ha terminado de enviar el primero.
\end_layout

\begin_layout Itemize
\align block
Así, en el instante 
\begin_inset Formula $\frac{2L}{R}$
\end_inset

, el destino ha recibido el primer paquete y el router el segundo.
\end_layout

\begin_layout Itemize
\align block
En 
\begin_inset Formula $\frac{3L}{R}$
\end_inset

, el destino ha recibido el segundo paquete y el router el tercero.
\end_layout

\begin_layout Itemize
\align block
Finalmente, en 
\begin_inset Formula $\frac{4L}{R}$
\end_inset

, el destino recibe los tres paquetes completos.
\end_layout

\begin_layout Standard
\align block
Generalizando, el retraso experimentado al enviar 
\begin_inset Formula $N-1$
\end_inset

 paquetes, es
\begin_inset Formula 
\[
t_{tr}(N-1)=N\cdot\frac{L}{R}
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Retrasos en colas y pérdida de paquetes
\end_layout

\begin_layout Standard
\align block
Cada encaminador tiene múltiples enlaces conectados.
 Y para cada uno de estos enlaces, tienen un 
\series bold
buffer de salida (output buffer)
\series default
 que almacena paquetes que el router está apunto de enviar por ese enlace.
\end_layout

\begin_layout Standard
\align block
Si un paquete entrante necesita ser transmitido por un enlace pero este
 está ocupado con la transmisión de otro paquete, el paquete entrante debe
 esperar en el buffer de salida.
 Así, además de los retardos por almacenamiento y reenvío, los paquetes
 sufren 
\series bold
retardos por colas
\series default
 en los buffers de salida.
\end_layout

\begin_layout Standard
\align block
Además, como el espacio de un buffer es limitado, un paquete entrante podría
 encontrarse el buffer lleno con otros paquetes esperando ser transmitidos.
 En este caso incurriremos en 
\series bold
pérdida de paquetes
\series default
, pues el paquete entrante no puede ser almacenado y debe descartarse.
\end_layout

\begin_layout Subsubsection*
Tablas de rutas y protocolos de enrutamiento
\end_layout

\begin_layout Standard
\align block
En la internet, cualquier host tiene una dirección llamada 
\series bold
dirección IP
\series default
.
 Cuando un emisor quiere enviar un paquete a un destino, el emisor incluye
 la IP del destinatario en la cabecera del paquete.
 
\end_layout

\begin_layout Standard
\align block
Esta dirección tiene una estructura jerárquica.
 Cuando un paquete llega a un router en la red, este examina una porción
 de la dirección del paquete de destino y lo reenvía a un router adyacente.
 Concretamente, cada router tiene una 
\series bold
tabla de rutas
\series default
 que mapea direcciones de destino con enlaces de salida.
 Cuando un paquete llega al router, este examina la dirección y busca en
 su tabla de rutas, usando la dirección de destino, para encontrar el enlace
 de salida correcto.
 Entonces, el router reenvía el paquete por este enlace de salida.
\end_layout

\begin_layout Standard
\align left
Los 
\series bold
protocolos de enrutamiento 
\series default
son usados para rellenar automáticamente estas tablas de rutas.
\end_layout

\begin_layout Subsubsection
Conmutación de circuitos
\end_layout

\begin_layout Standard
\align block
Hay dos formas principales de encaminar datos a través de una red de enlaces
 y encaminadores: conmutación de paquetes (como hemos visto antes) o conmutación
 de circuitos.
\end_layout

\begin_layout Standard
\align block
En las redes de circuitos conmutados, los recursos necesarios a lo largo
 de un camino para proporcionar la comunicación entre los hosts se reserva
 por la duración de la sesión de comunicación entre los hosts.
 
\end_layout

\begin_layout Standard
\align block
Por el contrario, en las redes de paquetes conmutados, estos recursos no
 se reservan, un mensaje de una sesión usa los recursos en demanda y, como
 consecuencia, deberá esperar para acceder al enlace.
\end_layout

\begin_layout Standard
\align block
Antes de que el emisor pueda enviar información, la red debe establecer
 una conexión entre el emisor y el receptor.
 Esto es una 
\series bold
conexión de buena fe
\series default
 para la que los switches en el camino entre los dos hosts mantienen un
 estado de conexión para esta conexión.
 Esto se llama un 
\series bold
circuito
\series default
.
 Cuando la red establece el circuito, también reserva una tasa constante
 de transmisión en los enlaces de la red para la duración de la conexión.
\end_layout

\begin_layout Subsubsection*
Multiplexión en redes de circuitos conmutados
\end_layout

\begin_layout Standard
\align block
Un circuito en un enlace se implementa de dos formas:
\end_layout

\begin_layout Itemize
\align block

\series bold
Multiplexión por división de frecuencia (FDM): 
\series default
el espectro de frecuencias de un enlace se divide para las conexiones establecid
as a través del enlace.
 Más concretamente, el enlace dedica una horquilla de frecuencias a cada
 conexión durante lo que dure la sesión.
 El ancho de esta horquilla se denomina 
\series bold
ancho de banda
\series default
.
\end_layout

\begin_layout Itemize
\align block

\series bold
Multiplexión por división de tiempo (TDM): 
\series default
el tiempo se divide en marcos de duración fija, y cada marco se divide en
 una cantidad fija de espacios.
 Cuando la red establece una conexión a lo largo de un enlace, la red dedica
 un espcio de cada marco a esta conexión.
 Estos espacios están dedicados para el único uso de esa conexión, con un
 espacio de tiempo disponible por uso para transmitir los datos de la conexión.
\end_layout

\begin_layout Standard
\align block
Los defensores de la conmutación de paquetes han argumentado que la conmutación
 de circuitos es ineficiente porque los circuitos dedicados permanecen ociosos
 durante períodos de silencio.
 También apuntan que establecer los circuitos extremo a extremo y reservar
 la capacidad de transmisión es complicado y requiere software de señalización
 complejo para coordinar la operación de los switches a lo largo del camino
 extremo a extremo.
\end_layout

\begin_layout Subsubsection*
Conmutación de paquetes VS Conmutación de circuitos
\end_layout

\begin_layout Standard
\align block
Los críticos de la conmutación de paquetes argumentan que esta no es apropiada
 para servicios en tiempo real debido a sus retrasos impredecibles y variables.
 Los defensores de los paquetes conmutados argumentan que:
\end_layout

\begin_layout Enumerate
\align block
Ofrece mejor compartición de la capacidad de transmisión que los circuitos
 conmutados
\end_layout

\begin_layout Enumerate
\align block
Es más simple, más eficiente y menos costoso de implementar que los circuitos
 conmutados
\end_layout

\begin_layout Standard
\align block
Los circuitos conmutados preasignan el uso del enlace de transmisión independien
temente de la demanda, con enlaces asignados pero innecesarios que quedan
 ociosos.
\end_layout

\begin_layout Standard
\align block
Por otro lado, los paquetes conmutados usan el enlace en demanda.
 La capacidad de transmisión del enlace será compartida en una dinámica
 paquete a paquete solo entre aquellos usuarios que tienen paquetes que
 necesitan transmitir a través del enlace.
\end_layout

\begin_layout Subsubsection
Una red de redes
\end_layout

\begin_layout Standard
\align block
Los ISPs de acceso deben estar interconectados entre sí.
 Esto se hace creando una red de redes.
\end_layout

\begin_layout Standard
\align block
A lo largo de los años, la red de redes que conforma internet ha evolucionado
 a una estructura muy compleja.
 Gran parte de esta evolución se debe a asuntos económicos y políticas nacionale
s, más que a consideraciones sobre la eficiencia.
\end_layout

\begin_layout Standard
\align block
Vamos a proceder a una construcción de más sencillez a más complejidad de
 la red:
\end_layout

\begin_layout Itemize
\align block

\series bold
Estructura de Red 1: 
\series default
interconecta todos los ISPs de acceso a través de un único ISP global de
 tránsito.
 Nuestro ISP global de tránsito es una red de routers y enlaces de comunicación
 que no solo abarca el mundo, pero también tiene al menos un router cerca
 de cada uno de los ISPs de acceso.
 Sería muy costoso para el ISP global construir una red tan extensa.
 Para ser rentable, debería cobrar a cada ISP de acceso por la conectividad,
 con el precio reflejando la cantidad de tráfico que un ISP intercambia
 con el ISP global.
 Como los ISP de acceso pagan al ISP global de tránsito, el ISP de acceso
 se dice que es un 
\series bold
cliente
\series default
 y el ISP global se dice que es un 
\series bold
proveedor
\series default
.
\end_layout

\begin_layout Itemize
\align block

\series bold
Estructura de Red 2: 
\series default
consiste en cientos de miles de ISPs de acceso y múltiples ISPs de tránsito
 globales.
 Los ISPs de acceso prefieren la estructura de red 2 antes que la 1, ya
 que ahora pueden elegir entre los ISPs de tránsito competidores en función
 del precio y los servicios ofrecidos.
 Nótese, sin embargo, que los ISPs de tránsito globales deben interconectarse
 también entre ellos.
\end_layout

\begin_deeper
\begin_layout Standard
\align block
Así, esta segunda estructura es una jerarquía de dos niveles con proveedores
 de tránsito globales en el nivel superior y ISPs de acceso en el inferior.
 Aquí asumimos no solo que los ISPs de tránsito son capaces de dar servicios
 cerca de los ISP de acceso, sino que lo encuentran económicamente deseable.
\end_layout

\end_deeper
\begin_layout Itemize
\align block

\series bold
Estructura de Red 3: 
\series default
en muchas regiones, podría haber 
\series bold
ISP regionales
\series default
 a los que los ISPs de acceso en esa región se conectarían.
 Cada ISP regional conectaría entonces con algún 
\series bold
ISP de nivel 1
\series default
, que son similares a nuestros ISPs de tránsito globales de la estructura
 2, pero los ISPs de nivel 1, que sí existen en la realidad, no tienen presencia
 en todas las ciudades del mundo.
\end_layout

\begin_deeper
\begin_layout Standard
\align block
Además, no solo hay múltiples ISPs de nivel 1 competidores, también puede
 haber múltiples ISPs regionales competidores en una región.
 En una jerarquía como esta, cada ISP de acceso paga el ISP regional al
 que se conecta, y cada ISP regional paga al ISP de nivel 1 al que se conecta.
 Por tanto, hay una relación cliente-proveedor en cada nivel de la jerarquía.
\end_layout

\begin_layout Standard
\align block
En algunas regiones, podría haber un ISP regional muy grande al que otros
 ISPs regionales más pequeños se conectarían.
 Después, el ISP regional grande se conectaría a un ISP de nivel 1.
\end_layout

\end_deeper
\begin_layout Standard
\align block
Para acercarnos más aún a la red que conforma internet, debemos añadir los
 
\series bold
puntos de acceso (PoPs)
\series default
, que existen en todos los niveles de la jerarquía excepto en el menor de
 todos.
 Un PoP simplemente es un grupo de uno o más routers en la red del proveedor
 donde los ISPs clientes pueden conectarse al ISP proveedor.
\end_layout

\begin_layout Standard
\align block
Una red cliente, para conectarse a un Pop de un proveedor, puede alquilar
 un enlace de alta velocidad a un tercer proveedor de telecomunicaciones,
 para conectar directamente uno de sus routers a un router del PoP.
\end_layout

\begin_layout Standard
\align block
Cualquier ISP (menos los de primer nivel) podría elegir hacer 
\series bold
multi-home
\series default
, o sea, conectar dos o más ISPs proveedores.
 Cuando un ISP multihomea, puede continuar enviando y recibiendo paquetes
 de internet incluso si uno de los dos proveedores tiene un fallo.
\end_layout

\begin_layout Standard
\align block
Ahora bien, la cantidad que un ISP cliente paga a un ISP proveedor refleja
 la cantidad de tráfico que intercambia con este.
 Para reducir estos costes, un par de ISPs cercanos del mismo nivel podrían
 aliarse (
\series bold
Peer
\series default
), conectando sus redes directamente y dejando que el tráfico pase a través
 de ellos en lugar de subir a ISPs de niveles superiores.
 Normalmente sib acuerdos igualitarios (settlement-free), es decir, que
 ninguno de ellos paga nada al otro.
\end_layout

\begin_layout Standard
\align block
También podría darse el caso de que una compañía de terceros crease un 
\series bold
Punto de Intercambio de Internet (IXP)
\series default
, que es un lugar donde múltiples ISP pueden hacer peering entre ellos.
 Todo este exosistema final conjunta la 
\series bold
Estructura de Red 4
\series default
.
\end_layout

\begin_layout Standard
\align block
La 
\series bold
Estructura de Red 5
\series default
 describe la internet de 2012.
 Se construye sobre la cuarta, añadiendo 
\series bold
redes proveedoras de contenido
\series default
, que, creando su propia red, no solo reducen los pagos a ISPs de niveles
 superiores, sino que tienen mayor control sobre cómo sus servicios son
 entregados, en última instancia, a los usuarios finales.
\end_layout

\begin_layout Standard
\align block
Así, la internet de hoy en día es compleja, consiste en una docena o más
 de ISPs de nivel uno y cientos de miles de ISPs de niveles inferiores.
 Los ISPs son variados por su cobertura, con algunos abarcando varios continente
s y oceános y otros limitados a regiones geográficas muy pequeñas.
 Los ISPs inferiores conectan a los superiores, y los superiores están intercone
ctados entre sí.
 Los usuarios y los proveedores de contenido son clientes de ISPs inferiores,
 y estos los son de los superiores.
\end_layout

\begin_layout Standard
\align block
En los últimos años, los proveedores de contenido más grandes también han
 creado sus propias redes y conectan directamente con ISPs inferiores allí
 donde es posible.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/isps.png

\end_inset


\end_layout

\begin_layout Subsection
Capas de protocolos y sus modelos de servicio
\end_layout

\begin_layout Subsubsection
Arquitectura por capas
\end_layout

\begin_layout Standard
\align block
Una arquitectura por capas nos permite explicar cada parte específica y
 bien definida de un gran y complejo sistema.
 Esta simplificación es, en sí misma, de un valor considerable, ya que proporcio
na modularidad, haciendo mucho más fácil cambiar la implementación del servicio
 ofrecido por una capa.
 Mientras que la capa proporcione el mismo servicio a la capa superior,
 y use los mismos servicios de la capa inferior, el resto del sistema permanece
 inalterado cuando la implementación de una capa cambia.
\end_layout

\begin_layout Subsubsection*
Organización en capas de los protocolos
\end_layout

\begin_layout Standard
\align block
Para proporcionar estructura al diseño de los protocolos de red, los diseñadores
 de redes organizan los protocolos en capas.
 Cada protocolo pertenece a una capa.
\end_layout

\begin_layout Standard
\align block
Nosotros estamos interesados en los 
\series bold
servicios 
\series default
que una capa ofrece a la inmediatamente superior, el llamado 
\series bold
modelo de servicio de una capa
\series default
.
 Cada capa proporciona su servicio:
\end_layout

\begin_layout Enumerate
\align block
realizando ciertas acciones dentro de la capa
\end_layout

\begin_layout Enumerate
\align block
usando los servicios de la capa inmediatamente inferior
\end_layout

\begin_layout Standard
\align block
Una capa de protocolos puede ser implementada en software, hardware o en
 una combinación de ambos.
\end_layout

\begin_layout Standard
\align block
Los 
\series bold
protocolos de la capa de aplicación 
\series default
son casi siempre implementados en software en los hosts, al igual que los
 
\series bold
protocolos de la capa de transporte
\series default
.
\end_layout

\begin_layout Standard
\align block
Como la 
\series bold
capa física 
\series default
y la 
\series bold
capa de enlace de datos 
\series default
son responsables de manejar la comunicación sobre un enlace en específico,
 normalmente se implementan en una tarjeta de red en la interfaz correspondiente
 al enlace.
\end_layout

\begin_layout Standard
\align block
La 
\series bold
capa de red 
\series default
suele ser una implementación mixta de hardware y software.
 Esta capa es una capa de protocolos distribuidos por los hosts, encaminadores
 y otros componentes de las redes.
\end_layout

\begin_layout Standard
\align block
La organización en capas de los protocolos tiene ventajas conceptuales y
 estructurales.
 Esta organización proporciona una forma estructurada de discutir los componente
s del sistema y la modularidad facilita la actualización de estos.
 Algunos investigadores e ingenieros de redes se oponen a este tipo de organizac
ión en capas.
 Una potencial desventaja es que una capa podría duplicar funcionalidad
 de una capa inferior; otra es que la funcionalidad de una capa podría requerir
 información de otra capa, lo que viola el objetivo de la organización en
 capas.
\end_layout

\begin_layout Standard
\align block
Cuando los juntamos, los protocolos de las distintas capas formas la 
\series bold
pila de protocolos (protocol stack)
\series default
, que consiste en cinco capas: física, enlace, red, transporte y aplicación.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/pilaProtocolos.png

\end_inset


\end_layout

\begin_layout Subsubsection*
Capa de aplicación
\end_layout

\begin_layout Standard
Es donde las aplicaciones de red y sus protocolos de la capa de aplicación
 residen.
 Incluye muchos protocolos, como HTTP o FTP.
 Ciertas funciones de red, como la traducción DNS, que traduce direcciones
 legibles por humanos a su correspondiente dirección de red.
 Un protocolo de la capa de aplicación es distribuido por múltiples hosts,
 con la aplicación en un host usando el protocolo para intercambiar paquetes
 de información con la aplicación en otro host.
 Nos referiremos a este paquete de información en la capa de apicación como
 
\series bold
mensaje
\series default
.
\end_layout

\begin_layout Subsubsection*
Capa de transporte
\end_layout

\begin_layout Standard
Transporta mensajes de la capa de aplicación entre extremos de la aplicación.
 Hay dos protocolos de transporte:
\end_layout

\begin_layout Itemize

\series bold
Transmission Control Protocol (TCP): 
\series default
proporciona a las aplicaciones un servicio orientado a conexión.
 Incluye entrega garantizada de mensajes y control de flujo.
 Además divide los mensajes en segmentos más pequeños y proporciona mecanismos
 de control de la congestión, de forma que el emisor reduzca su tasa de
 envío cuando la red está sobrecargada.
\end_layout

\begin_layout Itemize

\series bold
User Datagram Protocol (UDP): 
\series default
proporciona un servicio no orientado a conexión.
 Es un servicio simple que no ofrece fiabilidad, ni control de flujo o congestió
n.
\end_layout

\begin_layout Standard
A los paquetes de la capa de transporte los llamaremos 
\series bold
segmentos
\series default
.
\end_layout

\begin_layout Subsubsection*
Capa de red
\end_layout

\begin_layout Standard
Es la responsable de mover los los paquetes de la capa de red, conocidos
 como 
\series bold
datagramas
\series default
, de un host a otro.
 El protocolo de la capa de transporte en un emisor pasa un semento de la
 capa de transporte y la dirección del destino a la capa de red, esta proporcion
a el servicio de entrega del segmento a la capa de transporte del host de
 destino.
\end_layout

\begin_layout Standard
Incluye el 
\series bold
protocolo IP
\series default
, que define los campos de un datagrama, así como cómo los hosts y routers
 actúan sobre estos campos.
 Solo hay un protocolo IP, y todos los componentes de internet que tienen
 una capa de transporte deben usarlo.
 La capa de red también contiene protocolos de enrutamiento que determinan
 las rutas que sigue un datagrama entre dos hosts.
 Hay muchos protocolos de enrutamiento distintos.
\end_layout

\begin_layout Subsubsection*
Capa de enlace
\end_layout

\begin_layout Standard
Para mover los paquetes de un nodo al siguiente en la ruta, la capa de red
 se apoya en los servicios de la capa de enlace.
 En cada nodo, la capa de red pasa el datagrama a la capa de enlace, que
 entrega el datagrama al siguiente nodo por la ruta.
 En el siguiente nodo, la capa de enlace pasa el datagrama a la capa de
 red.
\end_layout

\begin_layout Standard
Los servicios proporcionados por la capa de enlace dependen de los protocolos
 específicos de la capa de enlace que se emplean en el enlace.
\end_layout

\begin_layout Standard
Como los datagramas normalmente tienen que atravesar varios enlaces para
 ir de una fuente a un destino, un datagrama puede ser manipulado por distintos
 protocolos de la capa de enlace en diferentes enlace a lo largo de la ruta.
\end_layout

\begin_layout Standard
Los paquetes en la capa de enlace se denominan 
\series bold
marcos (frames)
\series default
.
\end_layout

\begin_layout Subsubsection*
Capa física
\end_layout

\begin_layout Standard
El trabajo de la capa física es mover los bits individuales de un marco
 de un nodo a otro.
 Los protocolos en esta capa son, de nuevo, dependientes del enlace utilizado
 y dependen más aún del medio de transmisión del enlace.
\end_layout

\begin_layout Subsubsection
El modelo OSI
\end_layout

\begin_layout Standard
La pila de protocolos de internet TCP/IP no es la única pila de protocolos
 que existe.
 El modelo 
\series bold
OSI, Open Systems Interconnection
\series default
, está organizado en siete capas: aplicación, presentación, sesión, transporte,
 red, enlace y física.
 La funcionalidad de las cinco capas con el mismo nombre en la pila TCP/IP
 es la misma.
\end_layout

\begin_layout Standard
La 
\series bold
capa de presentación 
\series default
proporciona servicios que permiten a aplicaciones en comunicación interpretar
 el significado de los datos intercambiados.
 Estos servicios incluyen compresión de datos y su encriptación y desencriptació
n.
\end_layout

\begin_layout Standard
La 
\series bold
capa de sesión 
\series default
proporciona servicios de delimitación y sincronización de intercambio de
 datos, incluyendo la construcción de puntos de control y esquemas de recuperaci
ón.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/osi.png
	scale 50

\end_inset


\end_layout

\begin_layout Subsubsection
Encapsulación
\end_layout

\begin_layout Standard
De forma similar a los hosts, los routers y switches de la capa de enlace
 organizan su hardware y software de red en capas.
 Pero los router y switches no implementan todas las capas de la pila de
 protocolos, normalmente solo implementan las capas inferiores.
\end_layout

\begin_layout Standard
La encapsulación consiste en lo siguiente:
\end_layout

\begin_layout Itemize
En el emisor, un mensaje de la capa de aplicación se pasa a la capa de transport
e
\end_layout

\begin_layout Itemize
La capa de transporte coge el mensaje y le añade información adicional,
 que será usada por la capa de transporte del receptor.
 El mensaje de la capa de aplicación, junto con la cabecera de la capa de
 transporte se denomina 
\series bold
segmento de la capa de transporte
\series default
.
 Este, por tanto, encapsula el mensaje de la capa de aplicación.
 La información añadida puede incluir información que permita a la capa
 de transporte del receptor entregar el mensaje a la aplicación correcta
 y saber si el mensaje ha sufrido cambios en la ruta mediante bits de detección
 de errores.
 La capa de transporte entonces pasa el segmento a la capa de red.
\end_layout

\begin_layout Itemize
La capa de red añade una cabecera de la capa de red, con información como
 las direcciones de emisor y destino, creando un 
\series bold
datagrama de la capa de red
\series default
.
 Este es pasado a la capa de enlace.
\end_layout

\begin_layout Itemize
La capa de enlace, de nuevo, añadirá una cabecera con información útil y
 conforma el 
\series bold
marco de la capa de enlace
\series default
.
\end_layout

\begin_layout Itemize
Las cabeceras se van eliminando cuando los mensajes se pasan a las capas
 superiores
\end_layout

\begin_layout Standard
En general, vemos como un mensaje tiene dos tipos de campos: campos de cabecera
 y campos de carga útil (payload).
\end_layout

\begin_layout Subsection
Principios de las aplicaciones de red
\end_layout

\begin_layout Standard
El 
\series bold
desarrollo de aplicaciones de red 
\series default
consiste en escribir programas que corren en diferentes hosts y se comunican
 entre ellos a través de la red.
 El software no tiene que programarse para funcionar en routers ni switches,
 únicamente en hosts.
\end_layout

\begin_layout Subsubsection
Arquitecturas de las aplicaciones de red
\end_layout

\begin_layout Standard
Desde el punto de vista del desarrollador, la architectura de red es fija
 y proporciona un conjunto específico de funciones a sus aplicaciones.
 La 
\series bold
arquitectura de la aplicación 
\series default
es diseñada por el desarrollador y dicta cómo se estructura la aplicación
 sobre los distintos hosts.
 Hay varios tipos:
\end_layout

\begin_layout Itemize

\series bold
Cliente-servidor: 
\series default
hay un host que permanece siempre encendido, el 
\series bold
servidor
\series default
, que analiza peticiones de otros muchos hosts, llamados 
\series bold
clientes
\series default
.
 El servidor tiene una dirección IP fija y conocida, de forma que los clientes
 pueden conectarse en cualquier momento enviando un paquete a esa dirección
 IP.
\end_layout

\begin_deeper
\begin_layout Standard
En muchas ocasiones, un único servidor es incapaz de procesar todas las
 peticiones que le llegan, para esto están los 
\series bold
centros de datos
\series default
, que albergan gran cantidad de hosts y pueden usarse para crear un servidor
 virtual muy potente.
 Pueden tener cientos de miles de servidores, que deben ser suministrados
 de electricidad y mantenidos.
 Además, los proveedores de servicio deben pagar periódicamente la conexión
 y el ancho de banda para enviar datos desde sus centros de datos.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Peer to peer (P2P): 
\series default
hay una dependencia mínima o nula en servidores dedicados de centros de
 datos.
 En lugar de esto, la aplicación explota la comunicación directa entre pares
 de hosts conectados de forma intermitente, llamados 
\series bold
peers
\series default
.
 Los peers no son únicamente del proveedor de servicios, también pueden
 ser dispositivos controlados por usuarios.
 Una de las características más atractivas de la arquitectura P2P es que
 es auto-escalable, es decir, que cuantos más usuarios hay usando la aplicación,
 más potencia de procesamiento hay.
 Sin embargo, las aplicaciones P2P venideras tienen que plantar cara a tres
 desafíos principalmente:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
ISP friendly: 
\series default
la mayoría de ISPs residenciales han optado por el ancho de banda asimétrico,
 proporcionando mucho más ancho de banda de bajada que de subida.
 Pero las aplicaciones P2P de streaming de vídeo o de distribución de archivos
 cambian el tráfico saliente desde servidores a ISPs residenciales, poniendo
 bastante carga en estos.
\end_layout

\begin_layout Itemize

\series bold
Seguridad: 
\series default
devido a su naturaleza distribuida y abierta, las aplicaciones P2P pueden
 ser difífiles de mantener seguras.
\end_layout

\begin_layout Itemize

\series bold
Incentivos: 
\series default
el éxito de aplicaciones P2P futuras depende de convencer a los usuarios
 de prestar voluntariamente ancho de banda, almacenamiento y recursos de
 computación a las aplicaciones, esto es el desafío del diseño con incentivos.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Arquitecturas híbridas: 
\series default
algunas aplicaciones combinan los dos modelos vistos anteriormente.
\end_layout

\begin_layout Subsubsection
Comunicación de procesos
\end_layout

\begin_layout Standard
Un 
\series bold
proceso 
\series default
es un programa que está ejecutándose en un host.
 Cuando los procesos están ejecutándose en un mismo host, pueden comunicarse
 entre ellos con comunicación entre procesos.
\end_layout

\begin_layout Standard
\align left
Los procesos que se ejecutan en dos hosts diferentes se comunican entre
 ellos mediante intercambio de mensajes a través de la red.
 Un proceso emisor crea y envía mensajes por la red; un proceso receptor
 recibe esos mensajes y posiblemente responde enviando mensajes de vuelta.
\end_layout

\begin_layout Subsubsection*
Procesos del cliente y el servidor
\end_layout

\begin_layout Standard
Una aplicación de red consiste en pares de procesos que envían mensajes
 el uno al otro a través de la red.
 Para cada par de procesos en comunicación, normalmente uno será el cliente
 y otro será el servidor.
 En algunas aplicaciones un proceso puede ser tanto cliente como servidor.
\end_layout

\begin_layout Standard
\align left
El proceso que inicia la comunicación se etiqueta como 
\series bold
cliente 
\series default
y el que es contactado para comenzar la conexión como 
\series bold
servidor
\series default
.
\end_layout

\begin_layout Subsubsection*
La interfaz entre el proceso y la red
\end_layout

\begin_layout Standard
Un proceso envía y recibe mensajes de la red a través de una interfaz software
 llamada 
\series bold
socket
\series default
.
\end_layout

\begin_layout Standard
Un socket es la interfaz entre la capa de aplicación y la de transporte
 en un host.
 También se puede llamar 
\series bold
Application Programming Interface (API)
\series default
 entre la aplicación y la red, ya que el socket es la interfaz de programación
 con la que las aplicaciones de red se construyen.
 El desarrollador tiene control sobre todo en el lado de la capa de aplicación
 del socket pero tiene muy poco control en el lado de la capa de transporte
 del socket.
 El único control que tiene aquí es:
\end_layout

\begin_layout Itemize
La elección del protocolo de transporte
\end_layout

\begin_layout Itemize
Quizás la habilidad de fijar alguno parámetros de la capa de transporte
 como el tamaño del buffer y el tamaño máximo de los segmentos
\end_layout

\begin_layout Subsubsection*
Direccionando procesos
\end_layout

\begin_layout Standard
Para que un proceso ejecutándose en un host que envía paquetes a otro proceso
 ejecutándose en otro host, el receptor necesita tener una dirección.
 Para identificar al proceso receptor, hay que identificar dos partes de
 información:
\end_layout

\begin_layout Itemize
La dirección del host
\end_layout

\begin_layout Itemize
Un identificador que especifique el proceso receptor dentro del host receptor
\end_layout

\begin_layout Standard
En la internet los hosts se identifican por su 
\series bold
dirección IP
\series default
, un número de 32 bits que identifica unívocamente un host.
 
\end_layout

\begin_layout Standard
El proceso emisor también tiene que identificar al proceso receptor.
 Esta información es necesaria porque en general un host puede estar ejecutando
 varias aplicaciones de red.
 Los 
\series bold
números de puerto 
\series default
sirven para esto.
 Las aplicaciones más populares tienen asignados números de puerto específicos.
\end_layout

\begin_layout Subsubsection
Servicios de transporte disponibles para las aplicaciones
\end_layout

\begin_layout Standard
Muchas redes proporcionan más de un protocolo de transporte.
 Cuando desarrollas una aplicación, debes elegir uno de ellos.
 Estos pueden clasificarse de forma simple atendiendo cuatro aspectos:
\end_layout

\begin_layout Enumerate

\series bold
Transferencia de datos garantizada: 
\series default
en muchas aplicaciones la pérdida de datos puede tener consecuencias desastrosas.
 Para dar soporte a estas aplicaciones, algo debe hacerse para garantizar
 que los datos enviados llegan al destino completamente y correctamente.
 
\end_layout

\begin_deeper
\begin_layout Standard
Cuando un protocolo de transporte proporciona este servicio, el emisor puede
 pasar sus datos al socket y sabrá con completa seguridad que los datos
 llegarán al receptor.
\end_layout

\begin_layout Standard
Cuando un protocolo de la capa de transporte no proporciona transferencia
 de datos garantizada, algunos datos enviados por el emisor pueden no llegar
 nunca al receptor, esto puede ser aceptable en aplicaciones con tolerancia
 a pérdidas.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Throughput: 
\series default
es la tasa a la que el emisor puede enviar bits al receptor.
\end_layout

\begin_deeper
\begin_layout Standard
Como otras sesiones compartirán el ancho de banda a lo largo del camino
 de red y estas sesiones van y vienen, el throughput disponible fluctúa
 con el tiempo.
 En ocasiones es útil garantizar un throughput disponible a una tasa específica.
 La aplicación podría pedir un throughput de 
\begin_inset Formula $r$
\end_inset

 bits/s, y el protocolo de la capa de transporte tendría que asegurar que
 el throughput disponible siempre es de, al menos, 
\begin_inset Formula $r$
\end_inset

 bits/s.
\end_layout

\begin_layout Standard
Las aplicaciones que tienen requirimientos mínimos de throughput se dice
 que son aplicaciones sensibles al ancho de banda.
 Por otro lado, las aplicaciones elásticas pueden hacer uso de más o menos
 throughput, dependiendo de la disponibilidad.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Tiempo: 
\series default
puede ser interesante proporcionar garantías de tiempo de entrega.
\end_layout

\begin_layout Enumerate

\series bold
Seguridad: 
\series default
un protocolo de transporte puede proporcionar a la aplicación con uno o
 más servicios de seguridad.
 Estos servicios proporcionarían confidencialidad entre los dos procesos,
 incluso si los datos son de alguna forma observados entre el emisor y el
 receptor.
 También puede proporcionar otros servicios como integridad de los datos
 o autenticación extremo a extremo.
\end_layout

\begin_layout Subsubsection
Servicios de transporte proporcionados en internet
\end_layout

\begin_layout Standard
\align block
Internet pone dos protocolos de transporte a disposición de las aplicaciones,
 UDP y TCP.
 Cuando creas una aplicación para internet, una de las primeras decisiones
 que debes hacer es si usarás UDP o TCP.
 
\end_layout

\begin_layout Subsubsection*
Servicios de TCP
\end_layout

\begin_layout Itemize
\noindent

\series bold
Servicio orientado a conexión: 
\series default
TCP hace que el cliente y el servidor intercambien información de control
 de transporte entre ellos antes de que pueda comenzar el flujo de mensajes
 a nivel de aplicación.
 Esto se denomina 
\series bold
procedimiento de handshaking (saludo)
\series default
, e informa a cliente y servidor de que deben prepararse para un intercambio
 de paquetes.
 Después del saludo, se establece una 
\series bold
conexión TCP
\series default
 entre los sockets de los dos procesos.
 Es una conexión full-dúplex en la que dos procesos pueden enviar mensajes
 uno al otro sobre la conexión al mismo tiempo.
 Cuando la aplicación termina de enviar mensajes, debe cerrar la conexión.
\end_layout

\begin_layout Itemize
\noindent

\series bold
Servicio de entrega de datos garantizada: 
\series default
los procesos en comunicación pueden confiar en TCP para entregar todos los
 datos enviados win errores y en orden.
\end_layout

\begin_layout Itemize
\noindent

\series bold
Mecanismo de control de la congestión: 
\series default
es un servicio para el bienestar general de internet, más que para el beneficio
 directo de los procesos en comunicación.
 Avisa al emisor cuando la red está congestionada entre él y el receptor
 e intenta limitar cada conexión TCP para un reparto justo de ancho de banda
 en la red.
\end_layout

\begin_layout Subsubsection*
Servicios de UDP
\end_layout

\begin_layout Standard
\align block
UDP es un protocolo ligero y sin lujos, que proporciona los servicios mínimos.
 Es 
\series bold
no orientado a conexión
\series default
, así que no hay handshaking antes de que los dos procesos comiencen la
 comunicación.
 La entrega de datos 
\series bold
no es garantizada
\series default
: los mensajes pueden llegar desordenados o no llegar.
 UDP tampoco incluye un mecanismo de control de la congestion: el emisor
 puede pasar datos a la capa de transporte a la tasa que desee.
\end_layout

\begin_layout Subsubsection*
Servicios no proporcionados por los protocolos de transporte de internet
\end_layout

\begin_layout Standard
No ofrecen garantías de tiempo ni de throughput.
 Internet ha estado manteniendo aplicaciones sensibles al tiempo durante
 muchos años.
 Estas aplicaciones normalmente funcionan bastante bien porque han sido
 diseñadas para hacer frente a esta falta de garantías.
 
\end_layout

\begin_layout Standard
La internet de hoy en día puede proporcionar un servicio aceptable a las
 aplicaciones sensibles al tiempo, pero no puede dar garantías de tiempo
 ni de throughput.
\end_layout

\begin_layout Subsubsection
Protocolos de la capa de aplicación
\end_layout

\begin_layout Standard
Definen cómo los procesos de una aplicación, ejecutándose en distintos hosts,
 intercambian mensajes.
 Define:
\end_layout

\begin_layout Itemize
Los tipos de mensajes intercambiados
\end_layout

\begin_layout Itemize
La sintaxis de estos
\end_layout

\begin_layout Itemize
La semántica de los campos
\end_layout

\begin_layout Itemize
Reglas para determinar cuándo y cómo un proceso envía y responde mensajes
\end_layout

\begin_layout Standard
Es importante distinguir entre aplicaciones de red y protocolos de la capa
 de aplicación.
 Un protocolo solo es una parte de la aplicación de red.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Web HTTP
\end_layout

\begin_layout Subsection
La Web y HTTP
\end_layout

\begin_layout Subsubsection
Visión de conjunto de HTTP
\end_layout

\begin_layout Standard
El 
\series bold
Hypertext Transfer Protocol (HTTP)
\series default
, el protocolo de la capa de aplicación de la Web, está en el corazón de
 la Web.
 Se implementa en dos programas: un programa cliente y un programa servidor.
\end_layout

\begin_layout Standard
Los programas cliente y servidor, ejecutándose en diferentes hosts, hablan
 entre ellos intercambiando mensajes HTTP.
 HTTP define la estructura de estos mensajes y cómo el cliente y el servidor
 los intercambian.
\end_layout

\begin_layout Standard
Una 
\series bold
página Web 
\series default
está formada por objetos.
\end_layout

\begin_layout Standard
Un 
\series bold
objeto 
\series default
es un fichero direccionable por una única URL.
 
\end_layout

\begin_layout Standard
La mayoría de páginas Web consisten de un 
\series bold
fichero base HTML
\series default
 y varios objetos referenciados.
 El fichero base HTML referencia los otros objetos de la página con sus
 URLs.
 Cada URL tiene dos componentes: el hostname del servidor que almacena el
 objeto y la ruta del objeto dentro del servidor.
\end_layout

\begin_layout Standard
Como los 
\series bold
navegadores Web 
\series default
implementan la parte del cliente de HTTP, en el contexto de la Web, no distingui
remos entre los términos navegador y cliente.
\end_layout

\begin_layout Standard
Los 
\series bold
servidores Web
\series default
, que implementan la parte del servidor de HTTP, almacenan objetos Web,
 cada uno direccionable por una URL.
 Los servidores Web populares incluyen Apache y Microsoft Internet Information
 Server.
\end_layout

\begin_layout Standard
HTTP define cómo los clientes Web piden páginas Web a los servidores Web
 y cómo los servidores transfieren las páginas a los clientes.
\end_layout

\begin_layout Standard
Cuando un usuario pide una página Web, el navegador envía mensajes 
\series bold
HTTP requests 
\series default
para pedir los objetos de la página al servidor.
 El servidor recibe las peticiones y responde con mensajes 
\series bold
HTTP response
\series default
 que contienen cada objeto.
\end_layout

\begin_layout Standard
HTTP usa TCP como protocolo subyacente de transporte.
 El cliente HTTP inicia una conexión TCP con el servidor.
 Una vez que la conexión queda establecida, los procesos navegador y servidor
 acceden a esta a través de las interfaces de su socket.
 En el lado del cliente la interfaz del socket es la puerta entre el proceso
 cliente y la conexión TCP; en el lado del servidor es la puerta entre el
 proceso servidor y la conexión TCP.
\end_layout

\begin_layout Standard
El cliente envía mensajes HTTP request por la interfaz de su socket y recibe
 mensajes HTTP response de esta misma interfaz.
 En el servidor pasa lo propio, pero al contrario.
\end_layout

\begin_layout Standard
Es importante notar que el servidor envía los archivos pedidos a los clientes
 sin almacenar ningún tipo de información de estado sobre el cliente.
 Como un servidor HTTP no mantiene información sobre los clientes, se dice
 que HTTP es un 
\series bold
protocolo sin estado (stateless)
\series default
.
\end_layout

\begin_layout Standard
La Web usa, como venimos explicando, la arquitectura de aplicación cliente-servi
dor.
 Siempre debe haber un servidor Web encendido, con una dirección IP fija,
 y este procesa peticiones de, potencialmente, millones de navegadores distintos.
\end_layout

\begin_layout Subsubsection
Conexiones persistentes y no-persistentes
\end_layout

\begin_layout Standard
Cuando esta interacción cliente-servidor está teniendo lugar sobre TCP,
 el desarrollador de la aplicación necesita hacer una decisión importante,
 ¿debería cada par petición/respuesta ser enviado en una conexión TCP distinta
 o deberían todos los pares de este tipo ser enviados sobre una misma conexión
 TCP? El primer caso se denomina 
\series bold
conexión no-persistente
\series default
 y el segundo 
\series bold
conexión persistente
\series default
.
\end_layout

\begin_layout Subsubsection*
HTTP con conexión no-persistente
\end_layout

\begin_layout Standard
El funcionamiento, grosso modo, sería:
\end_layout

\begin_layout Enumerate
El cliente inicia conexión TCP con el servidor
\end_layout

\begin_layout Enumerate
El cliente envía un mensaje HTTP request al servidor por su socket
\end_layout

\begin_layout Enumerate
El servidor recibe la petición por su socket, lo procesa, busca el objeto
 pedido, lo encapsula en un mensaje HTTP response y envía este mensaje de
 respuesta al cliente por su socket
\end_layout

\begin_layout Enumerate
El servidor le dice a TCP que cierre la conexión TCP
\end_layout

\begin_layout Enumerate
El cliente recibe el mensaje de respuesta.
 Ahora es cuando termina la conexión TCP.
 El cliente procesa el mensaje de respuesta y busca todas las referencias
 a objetos que tenga
\end_layout

\begin_layout Enumerate
Para cada objeto referenciado, se repite el proceso
\end_layout

\begin_layout Standard
Cuando el navegador recibe la página Web, muestra la página al usuario.
 Dos navegadores distintos pueden interpretar una misma página de formas
 diferentes, HTTP no tiene nada que ver con cómo una página Web es interpretada
 por el cliente.
\end_layout

\begin_layout Standard
Como vemos, en el modelo no-persistente, cada conexión TCP transporta exactament
e un mensaje de petición y uno de respuesta.
\end_layout

\begin_layout Standard
Para medir cuánto tiempo tarda el cliente en recibir completamente la página
 que desea usamos el concepto de 
\series bold
Round Trip Time (RTT)
\series default
, el tiempo que tarda un paquete pequeño en viajar desde el cliente al servidor
 y volver.
 El RTT incluye los retardos de propagación, encolamiento, paso por routers
 y switches intermedios y de procesamiento.
\end_layout

\begin_layout Standard
Pensemos, entonces, en qué sucede al clickar en un hiperenlace: el navegador
 inicia una conexión TCP con el navegador, esto requiere de un establecimiento
 de conexión (3-way handshake).
\end_layout

\begin_layout Standard
Las dos primeras partes del establecimiento de la conexión consumen un RTT.
\end_layout

\begin_layout Standard
Tras esto, el cliente envía el mensaje HTTP request junto con la tercera
 parte del establecimiento de la conexión.
 Cuando esto llega al servidor, este responde con la página pedida.
 Este proceso consume otro RTT.
\end_layout

\begin_layout Standard
Es decir, para enviar un objeto, se consumen 2 RTTs.
\end_layout

\begin_layout Standard
Si queremos obtener una página que contiene 
\begin_inset Formula $N-1$
\end_inset

 objetos, entonces, se requerirán
\begin_inset Formula 
\[
2\cdot N\ RTTs
\]

\end_inset


\end_layout

\begin_layout Standard
dos RTTs por cada objeto pedido.
 Hay que tener en cuenta que la página es también un objeto.
\end_layout

\begin_layout Subsubsection*
HTTP con conexión persistente
\end_layout

\begin_layout Standard
La opción no-persistente presenta varias desventajas:
\end_layout

\begin_layout Itemize
Una nueva conexión debe establecerse y mantenerse para cada objeto pedido.
 En cada conexión los buffers TCP deben asignarse, así como las variables
 de TCP, tanto en cliente como en servidor.
 Esto puede suponer una carga importante para el servidor, que puede procesar
 respuestas de cientos de clientes distintos simultáneamente
\end_layout

\begin_layout Itemize
Cada objeto sufre un retardo de 2 RTTs
\end_layout

\begin_layout Standard
Con las conexiones persistentes, el servidor deja la conexión TCP abierta
 tras enviar la respuesta.
 Posteriores peticiones y respuestas entre los mismos cliente y servidor
 pueden ser enviados por la misma conexión.
 
\end_layout

\begin_layout Standard
Estas peticiones podrían incluso hacerse en 
\series bold
pipeline
\series default
, sin esperar cada respuesta.
\end_layout

\begin_layout Standard
Normalmente, el servidor cerrará la conexión cuando transcurre cierto tiempo
 sin recibir peticiones.
 Cuando el servidor recibe las peticiones en pipeline, envía también las
 respuestas en pipeline.
\end_layout

\begin_layout Standard
El retardo sin pipeline será 1RTT del establecimiento de la conexión, 1RTT
 por cada objeto requerido.
 Si queremos una página con 
\begin_inset Formula $N-1$
\end_inset

 objetos, será
\begin_inset Formula 
\[
N+1\ RTTs
\]

\end_inset


\end_layout

\begin_layout Standard
El retardo con pipeline depende del tamaño del pipeline (cuántos mensajes
 pueden haber en vuelo) y de posibles retardos de encolado.
 Si suponemos el pipeline admite 
\begin_inset Formula $M$
\end_inset

 mensajes (y suponemos que se envían simultáneamente), entonces consumiremos
 1RTT para el establecimiento de la conexión y 1RTT (siendo realistas sería
 más) por cada 
\begin_inset Formula $M$
\end_inset

 pares petición/respuesta.
 Si queremos una página con 
\begin_inset Formula $N-1$
\end_inset

 objetos, el retardo será
\begin_inset Formula 
\[
\left\lceil \frac{N}{M}\right\rceil +1\ RTTs
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Formato de los mensajes HTTP
\end_layout

\begin_layout Subsubsection*
Mensaje HTTP Request
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/httpReq.png

\end_inset


\end_layout

\begin_layout Standard
El mensaje se escribe en texto ASCII ordinario y consiste de una cantidad
 de líneas, cada una seguida de un retorno de carro y otro de line-feed
 (
\backslash
r
\backslash
n).
 La última línea lleva un 
\backslash
r
\backslash
n adicional, para indicar que termina la cabecera.
\end_layout

\begin_layout Standard
La primera línea se denomina 
\series bold
request line
\series default
 y las siguientes 
\series bold
header lines
\series default
.
 
\end_layout

\begin_layout Standard
La request line tiene tres campos:
\end_layout

\begin_layout Itemize

\series bold
Método: 
\series default
indica la acción requerida por la petición.
 Puede ser GET, POST, HEAD, PUT y DELETE
\end_layout

\begin_deeper
\begin_layout Itemize
GET: el método más usado.
 Se usa para pedir un objeto, con el objeto requerido identificado en el
 campo URL.
\end_layout

\begin_layout Itemize
POST: usado cuando el usuario rellena un formulario.
 Se usa también para pedir una página, pero los contenidos de esta dependen
 de lo que el usuario ha introducido en los campos del formulario.
\end_layout

\begin_layout Itemize
HEAD: parecido a GET.
 Cuando un servidor recibe una petición con el método HEAD, responde con
 un mensaje HTTP pero no envía el objeto requerido.
\end_layout

\begin_layout Itemize
PUT: suele usarse junto con herramientas de publicación Web.
 Permite al usuario subir un objeto a un directorio específico de un servidor
 Web.
\end_layout

\begin_layout Itemize
DELETE: permite a un usuario eliminar objetos de un servidor Web.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
URL: 
\series default
del objeto requerido
\end_layout

\begin_layout Itemize

\series bold
Versión HTTP
\end_layout

\begin_layout Standard
Tras la request line, vemos las header lines.
 Las más comunes son:
\end_layout

\begin_layout Itemize
User-Agent: informa del tipo de navegador que emplea el cliente
\end_layout

\begin_layout Itemize
Referer: URL del docuento desde el que se accedió al actual
\end_layout

\begin_layout Itemize
If-Modified-Since: solo se quiere el documento si se ha modificado tras
 la fecha indicada
\end_layout

\begin_layout Itemize
Accept: muestra los formatos que acepta el cliente
\end_layout

\begin_layout Itemize
Accept-Language: lenguajes aceptados por el navegador
\end_layout

\begin_layout Itemize
Host: servidor al que el cliente envía la petición
\end_layout

\begin_layout Itemize
Date: fecha actual
\end_layout

\begin_layout Itemize
Connection: se emplea para mantener la conexión
\end_layout

\begin_layout Itemize
Cookie: devuelve una cookie al servidor
\end_layout

\begin_layout Standard
Después de las header lines, nos encontramos con el 
\series bold
cuerpo
\series default
.
 Este está vacío en el método GET, pero se usa con el método POST.
\end_layout

\begin_layout Subsubsection*
Mensaje HTTP Response
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/httpRes.png

\end_inset


\end_layout

\begin_layout Standard
También tiene tres partes: una 
\series bold
línea de estado
\series default
, una cantidad de 
\series bold
header lines 
\series default
y el 
\series bold
cuerpo
\series default
.
\end_layout

\begin_layout Standard
El cuerpo contiene la parte importante del mennsaje, lleva el objeto requerido.
\end_layout

\begin_layout Standard
La línea de estado tiene tres campos: la versión HTTP, un código de estado
 y el mensaje de estado correspondiente.
\end_layout

\begin_layout Standard
Los header lines más comunes son:
\end_layout

\begin_layout Itemize
Location: nueva localización del documento solicitado
\end_layout

\begin_layout Itemize
Server: nombre y versión del software servidor
\end_layout

\begin_layout Itemize
MIME-version: versión del protocolo MIME usada por el servidor
\end_layout

\begin_layout Itemize
Content-Length: longitud en bytes del cuerpo de la respuesta
\end_layout

\begin_layout Itemize
Content-Type: tipo MIME que identifica el tipo de dato de la respuesta
\end_layout

\begin_layout Itemize
Last-Modified: fecha y hora en la que se modificó por última vez
\end_layout

\begin_layout Itemize
Set-Cookie: el servidor solicita al cliente que almacene una cookie
\end_layout

\begin_layout Standard
Y los códigos, junto con sus mensajes de estado, más frecuentes son:
\end_layout

\begin_layout Itemize
200 OK: la petición ha sido atendida con éxito y la respuesta se envía en
 la respuesta
\end_layout

\begin_layout Itemize
301 Moved Permanently: el objeto requerido ha sido movido de forma permamente.
 La nueva URL se especifica en 'Location:'.
 El cliente pedirá esta nueva URL
\end_layout

\begin_layout Itemize
400 Bad Request: es un código de error genérico que indica que la petición
 no pudo ser entendida por el servidor
\end_layout

\begin_layout Itemize
404 Not Found: el documento pedido no existe en este servidor
\end_layout

\begin_layout Itemize
\align left
505 HTTP Version Not Supported: el protocolo HTTP de la petición no es soportado
 por el servidor.
\end_layout

\begin_layout Subsubsection
Interacción usuario-servidor: Cookies
\end_layout

\begin_layout Standard
Es común que los sitios Web encuentren útil identificar usuarios, ya sea
 porque el servidor quiera restringir el acceso a algunos usuarios o porque
 quiera ofrecer contenido en función de la identidad del usuario.
 Para estos propósitos, HTTP utiliza 
\series bold
cookies
\series default
, que permiten a las páginas seguirle la pista a los usuarios.
 La mayoría de Web comerciales usan cookies hoy en día.
\end_layout

\begin_layout Standard
La tecnología de las cookies tiene cuatro componentes:
\end_layout

\begin_layout Enumerate
Una header line cookie en el mensaje HTTP response.
\end_layout

\begin_layout Enumerate
Un header line cookie en el mensaje HTTP request.
\end_layout

\begin_layout Enumerate
Un archivo cookie en el equipo del cliente, manejado por el navegador.
\end_layout

\begin_layout Enumerate
Una base de datos back-end en el servidor.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/cookie.png

\end_inset


\end_layout

\begin_layout Standard
Las cookies se pueden usar para identificar a un usuario.
 La primera vez que un usuario visita una página, este puede proporcionar
 una identificación de usuario.
 Durante las siguientes sesiones, el navegador pasa una cabecera cookie
 al servidor, identificando al usuario en el servidor.
 Por tanto, las cookies pueden usarse para crear una capa de sesión de usuario
 sobre HTTP sin estado.
\end_layout

\begin_layout Standard
Son polémicas, ya que pueden ser consideradas como invasión de la privacidad.
 Usando una combinación de cookies y de información proporcionada por el
 usuario un sitio Web puede aprender muchas cosas sobre el usuario y potencialme
nte vender esta información a terceros.
\end_layout

\begin_layout Subsubsection*
Formato de las Cookies HTTP
\end_layout

\begin_layout Standard
Las cookies son una sola línea de valores separados por ';', los valores
 más importantes son:
\end_layout

\begin_layout Itemize
nombre=valor : asocia a una propiedad un valor específico
\end_layout

\begin_layout Itemize
expires=fecha : fecha de caducidad de la cookie
\end_layout

\begin_layout Itemize
domain=ámbito : especifica los hosts permitidos para recibir la cookie
\end_layout

\begin_layout Itemize
path=camino : indica una ruta URL que debe existir en la URL solicitada
 para enviar el header
\end_layout

\begin_layout Itemize
secure : solo se envía cuando se emplea el protocolo HTTPS
\end_layout

\begin_layout Subsubsection
Caching Web
\end_layout

\begin_layout Standard
Una 
\series bold
caché Web (Proxy server)
\series default
 es una entidad de red que satisface peticiones HTTP en lugar del servidor
 Web original.
 La caché Web tiene su propio disco de almacenamiento y guarda copias de
 objetos recientementes solicitados.
 Un navegador Web puede ser configurado para que todas las peticiones HTTP
 del usuario sean primero dirigidas a la caché Web.
 El proceso es así:
\end_layout

\begin_layout Enumerate
El navegador establece una conexión TCP con la caché Web y envía una petición
 HTTP para el objeto a la caché Web
\end_layout

\begin_layout Enumerate
La caché Web comprueba si tiene una copia del objeto almacenada localmente.
 Si lo tiene, devuelve el objeto en una respuesta HTTP al navegador cliente
\end_layout

\begin_layout Enumerate
Si la caché Web no tiene el objeto, abre una conexión TCP con el servidor
 original.
 La caché Web entonces envía una petición HTTP para el objeto en el servidor.
 Tras recibir esta petición, el servidor original envía el objeto en una
 respuesta HTTP a la caché Web
\end_layout

\begin_layout Enumerate
\align left
Cuando la caché Web recibe el objeto, guarda una copia en su almacenamiento
 local y envía una copia, en una respuesta HTTP, al navegador cliente
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/cacheWeb.png

\end_inset


\end_layout

\begin_layout Standard
\align left
Nótese que una caché es tanto cliente como servidor al mismo tiempo.
 
\end_layout

\begin_layout Standard
Normalmente una caché Web es comprada e instalada por un ISP.
\end_layout

\begin_layout Standard
El caching Web ha sido bastante usado en Internet por dos razones:
\end_layout

\begin_layout Itemize
Una caché Web reduce sustancialmente el tiempo de respuesta para una petición,
 sobre todo si el cuello de botella de ancho de banda entre el cliente y
 el servidor original es mucho menor que el cuello de botella entre el cliente
 y la caché
\end_layout

\begin_layout Itemize
Las cachés Web pueden reducir significativamente el tráfico en un enlace
 de acceso institucional a Internet.
 Reduciendo el tráfico, la institución no tiene que aumentar el ancho de
 banda tan rápido, reduciendo costes.
\end_layout

\begin_layout Standard
Mediante el uso de 
\series bold
Content Distribution Networks (CDNs)
\series default
, red superpuesta de computadoras que contienen copias de datos, colocados
 en varios puntos de una red con el fin de maximizar el ancho de banda para
 el acceso a los datos de clientes por la red, las cachés Web han ido incrementa
lmente siendo más importantes en Internet.
 Una compañía de CDN instala muchas cachés distribuidas geográficamente
 a lo largo de internet.
 Hay CDNs compartidas y dedicadas.
\end_layout

\begin_layout Subsubsection
El GET condicional
\end_layout

\begin_layout Standard
Aunque el caching puede reducir los tiempos de respuesta percibidos por
 el usuario, introduce un nuevo problema: la copia del objeto en la caché
 puede estar desfasada, pues puede haber sido en el servidor desde que fue
 cacheado.
\end_layout

\begin_layout Standard
HTTP tiene un mecanismo que permite a la caché verificar si los objetos
 están actualizados.
 Este mecanismo es el GET condicional.
 Un mensaje HTTP request es un GET condicional si:
\end_layout

\begin_layout Enumerate
Usa el método GET
\end_layout

\begin_layout Enumerate
Include una header line 'If-Modified-Since:'
\end_layout

\begin_layout Standard
Si el objeto ha sido modificado después de la fecha indicada en este último
 campo, entonces el servidor lo enviará a la Caché.
 Si no, enviará un mensaje con código de estado 304 Not Modified.
 En cualquiera de los casos la caché se asegura de tener el objeto actualizado.
\end_layout

\begin_layout Subsection
Common Gateway Interface
\end_layout

\begin_layout Standard
\align block
Con HTML se pueden crear formularios cuyos datos se tienen que procesar
 en el servidor.
 Los métodos GET y POST permiten enviar datos del cliente al servidor, pero
 los servidores web no pueden procesar cualquier tipo de consulta.
\end_layout

\begin_layout Standard
El interfaz CGI define la comunicación estándar entre un servidor web y
 una aplicación externa.
\end_layout

\begin_layout Standard
El proceso es:
\end_layout

\begin_layout Enumerate
El usuario del navegador pulsa en el botón SUBMIT
\end_layout

\begin_layout Enumerate
El navegador codifica los datos antes de enviarlos al servidor
\end_layout

\begin_layout Enumerate
El navegador emplea GET o POST para enviar los datos al servidor
\end_layout

\begin_layout Enumerate
El servidor reconoce que están solicitando la ejecución de un programa gateway,
 e invoca dicho programa en un nuevo proceso
\end_layout

\begin_layout Enumerate
El gateway recibe los datos enviados desde el navegador a través de variables
 de entorno, parámetros de la línea de comando o la entrada estándar
\end_layout

\begin_layout Enumerate
Gateway procesa la solicitud y genera la respuesta en forma de página web
 a través de la salida estándar
\end_layout

\begin_layout Enumerate
El servidor web envía al cliente los resultados que emite el programa gateway.
 Normalmente completará las cabeceras de respuesta
\end_layout

\begin_layout Enumerate
El cliente visualiza la página que contiene los resultados
\end_layout

\begin_layout Standard

\bar under
Variables de entorno relativas al servidor que puede consultar CGI:
\end_layout

\begin_layout Itemize
DOCUMENT_ROOT: directorio que conteine las páginas HTML del servidor
\end_layout

\begin_layout Itemize
SERVER_NAME: nombre del servidor que gestione el script CGI
\end_layout

\begin_layout Itemize
SERVER_PORT: puerto del servidor
\end_layout

\begin_layout Standard

\bar under
Variables de entorno relativas a la conexión cliente-servidor:
\end_layout

\begin_layout Itemize
HTTP_ACCEPT: tipos MIME soportados por el cliente
\end_layout

\begin_layout Itemize
HTTP_COOKIE: cookies asociadas por el cliente al recurso solicitado
\end_layout

\begin_layout Itemize
REMOTE_ADDR: dirección IP del equipo desde el que se efectúa la petición
\end_layout

\begin_layout Standard

\bar under
Variables relativas a la petición:
\end_layout

\begin_layout Itemize
CONTENT_LENGTH: tamaño, en bytes, del contenido de la información
\end_layout

\begin_layout Itemize
CONTENT_TYPE: tipo MIME de la petición
\end_layout

\begin_layout Itemize
\align left
QUERY_STRING: cadena de caracteres, en formato URL, que aparece en la petición
 GET
\end_layout

\begin_layout Subsubsection*
El método GET
\end_layout

\begin_layout Standard
La entrada de datos se hace mediante la variable QUERY_STRING.
\end_layout

\begin_layout Standard
La ventaja es que el usuario puede conservar consultas en forma de una URL.
\end_layout

\begin_layout Standard
El inconveniente es que la cadena de caracteres que define la codificación
 URL puede ser larga y sobrepasar el tamaño máximo tolerado por el servidor.
\end_layout

\begin_layout Subsubsection*
El método POST
\end_layout

\begin_layout Standard
\align block
La entrada de datos se hace mediante la entrada estándar.
\end_layout

\begin_layout Standard
\align block
La ventaja es que el método no se ve restringido por el tamaño de los datos
 producidos por un formulario.
\end_layout

\begin_layout Standard
\align left
El inconveniente es que el usuario no puede conservar las consultas realizadas.
\end_layout

\begin_layout Subsection
HTTP/2
\end_layout

\begin_layout Standard
\align block
Tiene como objetivos la reducción de la latencia mediante la multiplexación
 completa de solicitudes y respuesta, minimizar la sobrecarga del protocolo
 mediante la compresión y compatibilizar con la priorización de solicitudes
 y push del servidor.
\end_layout

\begin_layout Standard
Mantiene la semántica de HTTP.
\end_layout

\begin_layout Subsubsection*
Capa de enmarcado binario
\end_layout

\begin_layout Standard
\align block
Determina la forma en que los mensajes de HTTP se encapsulan y se transfieren
 entre el cliente y el servidor.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/enmarcadoBinario.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align block
A diferencia del protocolo HTTP/1.x de texto plano delimitado por línea nueva,
 toda la comunicación de HTTP/2 se divide en mensajes y marcos más pequeños,
 cada uno de los cuales está codificado en formato binario.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/streamHTTP2.png
	scale 75

\end_inset


\end_layout

\begin_layout Standard
\align block
HTTP/2 desglosa la comunicación del protocolo HTTP en un intercambio de
 tramas con codificación binaria, que luego se asignan a los mensajes que
 pertenecen a una transmisión específica, todo está multiplexado dentro
 de una única conexión de TCP.
 Esta es la base que habilita al resto de las funciones y las optimizaciones
 de rendimiento ofrecidas por el protocolo HTTP/2.
\end_layout

\begin_layout Subsubsection*
Multiplexación de peticiones y respuestas
\end_layout

\begin_layout Standard
\align block
Con HTTP/1.x, si el cliente desea realizar múltiples solicitudes paralelas
 para mejorar el rendimiento, se deben usar múltiples conexiones de TCP.
 Este comportamiento es una consecuencia directa del modelo de entrega de
 HTTP/1.x, que asegura que solo una respuesta pueda entregarse por vez (cola
 de respuestas) por conexión.
 Peor aún, esto también desencadena el bloqueo de cabeza de línea y el uso
 ineficiente de la conexión de TCP subyacente.
\end_layout

\begin_layout Standard
\align block
La nueva capa de entramado binario de HTTP/2 elimina estas limitaciones
 y habilita una multiplexación total de solicitudes y respuestas, al permitir
 que el cliente y el servidor desglosen un mensaje de HTTP en tramas diferentes,
 intercalarlas y luego reensamblarlas en el otro extremo.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/multiplexionHTTP2.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
\align block
La capacidad de desglosar un mensaje de HTTP en marcos independientes, intercala
rlos y luego reensamblarlos en el otro extremo es la mejora más importante
 de HTTP/2.
 De hecho, produce un efecto dominó con numerosos beneficios de rendimiento
 en toda la pila de tecnologías web, lo que nos permite:
\end_layout

\begin_layout Itemize
\align block
Intercalar múltiples solicitudes en paralelo sin bloquear ninguna.
 
\end_layout

\begin_layout Itemize
\align block
Intercalar múltiples respuestas en paralelo sin bloquear ninguna.
 
\end_layout

\begin_layout Itemize
\align block
Usar una única conexión para entregar múltiples solicitudes y respuestas
 en paralelo.
 
\end_layout

\begin_layout Itemize
\align block
Eliminar métodos alternativos de HTTP/1.x innecesarios, como archivos concatenado
s, image sprites y fragmentos de dominio.
 
\end_layout

\begin_layout Itemize
\align block
Proporcionar tiempos de carga de páginas inferiores mediante la eliminación
 de la latencia innecesaria y la mejora de la utilización de la capacidad
 de red disponible.
 
\end_layout

\begin_layout Subsubsection*
Priorización de transmisiones
\end_layout

\begin_layout Standard
\align block
Una vez que un mensaje de HTTP puede dividirse en muchos marcos individuales
 y permitimos que los marcos de múltiples transmisiones estén multiplexados,
 el orden en el cual el cliente y el servidor intercalan y entregan los
 marcos se convierte en una consideración de rendimiento crítica.
 Para facilitar esto, el estándar HTTP/2 permite que cada transmisión tenga
 un peso y una dependencia asociados:
\end_layout

\begin_layout Itemize
\align block
A cada transmisión se le puede asignar un peso entero de entre 1 y 256.
 
\end_layout

\begin_layout Itemize
\align block
Cada transmisión puede recibir una dependencia explícita de otra transmisión.
\end_layout

\begin_layout Standard
\align block
La combinación de dependencias y pesos de transmisión permite que el cliente
 construya y comunique un "árbol de priorización" que exprese cómo preferiría
 recibir las respuestas.
 A su vez, el servidor puede usar esta información para priorizar el procesamien
to de transmisión al controlar la asignación de CPU, memoria y otros recursos
 y, una vez que los datos de la respuesta están disponibles, la asignación
 de ancho de banda para asegurar la entrega óptima de respuestas de prioridad
 alta al cliente.
\end_layout

\begin_layout Subsubsection*
Una conexión por origen
\end_layout

\begin_layout Standard
\align block
Con el nuevo mecanismo de enmarcado binario en funcionamiento, HTTP/2 no
 necesita más de múltiples conexiones de TCP para multiplexar transmisiones
 en paralelo: cada transmisión se divide en muchos marcos, que pueden intercalar
se y priorizarse.
 Como resultado, todas las conexiones de HTTP/2 son persistentes y solo
 se requiere una conexión por origen, lo cual ofrece numerosos beneficios
 de rendimiento.
\end_layout

\begin_layout Subsubsection*
Control de flujo
\end_layout

\begin_layout Standard
HTTP/2 proporciona un conjunto de elementos básicos simples que permiten
 que el cliente y el servidor implementen su propio control de flujo en
 el nivel de transmisión y de conexión:
\end_layout

\begin_layout Itemize
El control de flujo es direccional.
 Cada receptor puede optar por configurar cualquier tamaño de ventana que
 desee para cada transmisión y para toda la conexión.
 
\end_layout

\begin_layout Itemize
El control de flujo se basa en el crédito.
 Cada receptor indica su conexión inicial y la ventana de control de flujo
 de transmisión (en bytes), que se reduce cuando el emisor emite un marco
 DATA y se incrementa mediante un marco WINDOW_UPDATE enviado por el receptor.
 
\end_layout

\begin_layout Itemize
El control de flujo no se puede inhabilitar.
 Cuando se establece la conexión de HTTP/2, el cliente y el servidor intercambia
n marcos SETTINGS, que configuran los tamaños de la ventana de control de
 flujo en ambas direcciones.
 El valor predeterminado de la ventana de control de flujo se configura
 en 65,535 bytes, pero el receptor puede configurar un mayor tamaño de ventana
 máximo (2^31-1 bytes como tope) y mantenerlo mediante el envío de un marco
 WINDOW_UPDATE cada vez que se reciben datos.
 
\end_layout

\begin_layout Itemize
El control de flujo es de salto a salto, no de extremo a extremo.
 Es decir, un intermediario puede usarlo para controlar el uso de recursos
 e implementar mecanismos de asignación de recursos basados en criterios
 y heurística propios.
\end_layout

\begin_layout Standard
HTTP/2 no especifica ningún algoritmo en especial para implementar el control
 de flujo.
 En cambio, proporciona elementos básicos simples y concede la implementación
 al cliente y el servidor, que lo pueden usar para implementar estrategias
 personalizadas a fin de regular el uso y la asignación de recursos, además
 de implementar nuevas capacidades de entrega que ayuden a mejorar tanto
 el rendimiento real como el percibido de nuestras aplicaciones web.
 
\end_layout

\begin_layout Subsubsection*
Servidor Push
\end_layout

\begin_layout Standard
Otra nueva función poderosa de HTTP/2 es la capacidad del servidor de enviar
 respuestas múltiples para una única solicitud del cliente.
 Es decir, además de la respuesta a la solicitud original, el servidor puede
 insertar recursos adicionales en el cliente sin necesidad de que este los
 solicite de manera explícita.
\end_layout

\begin_layout Subsubsection*
Compresión de cabeceras
\end_layout

\begin_layout Standard
Cada transferencia de HTTP lleva un conjunto de encabezados que describen
 al recurso transferido y sus propiedades.
 En HTTP/1.x, estos metadatos siempre se envían como texto sin formato y
 agregan entre 500 y 800 bytes de sobrecarga por transferencia o a veces
 incluso kilobytes, si se usan cookies de HTTP.
 Para reducir esta sobrecarga y mejorar el rendimiento, HTTP/2 comprime
 los metadatos del encabezado de solicitud y respuesta mediante el formato
 de compresión HPACK, que usa dos técnicas simples pero poderosas:
\end_layout

\begin_layout Standard
Permite que los campos del encabezado transmitido se codifiquen a través
 de un código Huffman estático, que reduce su tamaño de transferencia individual.
 Requiere que tanto el cliente como el servidor mantengan y actualicen una
 lista indexada de campos de encabezado previamente vistos (en otras palabras,
 establece un contexto de compresión compartido), que luego se usa como
 referencia para codificar de manera eficaz los valores transmitidos con
 anterioridad.
\end_layout

\begin_layout Standard
La codificación Huffman permite que los valores individuales se compriman
 cuando se transfieren y la lista indexada de los valores transferidos anteriorm
ente nos permite codificar valores duplicados transfiriendo valores indexados
 que pueden usarse para buscar y reconstruir todas las claves y los valores
 del encabezado de manera eficaz.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/compresionCabeceras.png

\end_inset


\end_layout

\begin_layout Standard
Como una optimización adicional, el contexto de la compresión de HPACK consiste
 en una tabla estática y una tabla dinámica: la tabla estática está definida
 en la especificación y proporciona una lista de campos de encabezados de
 HTTP comunes que todas las conexiones tienen más posibilidades de usar
 (p.
 ej., nombres de encabezado válidos); la tabla dinámica inicialmente está
 vacía y se actualiza en base a los valores intercambiados dentro de una
 conexión específica.
 Como resultado, el tamaño de cada solicitud se reduce al usar codificación
 Huffman estática para los valores nunca antes vistos y una sustitución
 de índices por valores que ya están presentes en las tablas estáticas o
 dinámicas a cada lado.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Protocolos para el correo electrónico
\end_layout

\begin_layout Subsection
Correo electrónico en Internet
\end_layout

\begin_layout Standard
\align left
El correo electrónico es un medio de comunicación asíncrono que, en comparación
 con el correo postal, es rápido, de fácil de distribución y barato.
\end_layout

\begin_layout Standard
\align left
Los componentes del correo electrónico son:
\end_layout

\begin_layout Itemize
\align left

\series bold
User agent:
\series default
 permite a los usuarios leer, responder, reenviar, guardar y redactar mensajes
\end_layout

\begin_layout Itemize
\align left

\series bold
Servidor mail:
\series default
 forman la base de la infraestructura del e-mail.
 Cada receptor tiene un 
\series bold
mailbox
\series default
 localizado en uno de los servidores mail.
 Un mensaje típico comienza su viaje en el user agent del emisor, viaja
 al mail server del emisor, y va al mail server del receptor, donde se deposita
 en el mailbox del receptor.
 Si el servidor del emisor no puede entregar el mensaje al del receptor,
 lo almacena en una 
\series bold
cola de mensajes
\series default
 y lo intenta reenviar más tarde.
\end_layout

\begin_layout Itemize
\align left

\series bold
Simple Mail Transfer Protocol (SMTP):
\series default
 es el principal protocolo de la capa de aplicación para el correo electrónico.
 Usa TCP para transferir correos del servidor mail del emisor al derl receptor.
 Tiene dos caras:
\end_layout

\begin_deeper
\begin_layout Itemize
\align left
Cara cliente: ejecuta el servidor mail del emisor
\end_layout

\begin_layout Itemize
\align left
Cara servidor: ejecuta el servidor mail del receptor
\end_layout

\begin_layout Standard
\align left
Ambas caras de SMTP se ejecutan en todo servidor mail.
 Cuando un servidor envía mensajes a otros servidores actúa como cliente
 SMTP.
 Cuando recibe correos de otros servidores actúa como servidor SMTP.
\end_layout

\end_deeper
\begin_layout Subsubsection
SMTP
\end_layout

\begin_layout Standard
\align left
Transfiere mensajes de servidores mail de emisores a servidores mail de
 receptores.
\end_layout

\begin_layout Standard
\align left
Aunque SMTP tiene bastantes buenas propiedades, como evidencia su presencia
 en Internet, es, sin embargo, una tecnología antigua que tiene algunas
 características arcaicas.
\end_layout

\begin_layout Standard
\align left
El cuerpo está restringido a usar caracteres 7-bit ASCII.
 Esta restricción tenía sentido en los 90 cuando la capacidad de transmisión
 era escasa y nadie enviaba correos con grandes archivos adjuntos.
 Pero, ahora, esta restricción dificulta mucho la implementación: obliga
 a codificar la información binaria a ASCII antes de ser enviada sobre SMTP,
 y, por supuesto, estos datos codificados, deben ser decodificados en recepción.
\end_layout

\begin_layout Standard
\align left
Para ver el funcionamiento de SMTP, supongamos que A quiere enviar un mensaje
 ASCII a B.
\end_layout

\begin_layout Enumerate
\align left
A inicia su user agent, le proporciona la dirección e-mail de B, escribe
 el mensaje y le dice al user agent que lo envíe.
\end_layout

\begin_layout Enumerate
\align left
El user agent de A envía el mensaje a su servidor mail, donde se almacena
 en una cola de mensajes.
\end_layout

\begin_layout Enumerate
\align left
La parte cliente de SMTP, ejecutándose en el servidor mail de A, ve el mensaje
 en la cola.
 Abre una conexión TCP con un servidor SMTP que se ejecuta en el servidor
 mail de B.
\end_layout

\begin_layout Enumerate
\align left
Tras el saludo inicial STMP, el el cliente SMTP envía el mensaje de A por
 la conexión TCP.
\end_layout

\begin_layout Enumerate
\align left
En el servidor mail de B, la parte servidor de SMTP recibe el mensaje.
 El servidor mail de B lo coloca en el mailbox de B.
\end_layout

\begin_layout Enumerate
\align left
B ejecuta su user agent para leer el mensaje cuando lo vea conveniente.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/smtp.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align left
SMTP normalmente no usa servidores mail intermedios para enviar correos,
 ni siquiera cuando los servidores emisor y receptor están muy alejados.
\end_layout

\begin_layout Standard
\align left
Ahora vamos a ver algunos de estos mismos pasos en más detalle:
\end_layout

\begin_layout Enumerate
\align left
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
3.
 
\end_layout

\end_inset

 El cliente SMTP establece una conexión por el puerto 25 en el servidor
 SMTP del receptor.
 Si el servidor está caído, el cliente lo intenta de nuevo más tarde.
 
\end_layout

\begin_layout Enumerate
\align left
\begin_inset Argument item:1
status open

\begin_layout Plain Layout
4.
 
\end_layout

\end_inset

 Una vez esta conexión qeuda establecida, el servidor y el cliente realizan
 un saludo inicial a nivel de aplicación.
 Durante esta fase de saludo, el cliente SMTP indica la dirección email
 del receptor y la del emisor.
 Tras esta fase, la parte del cliente envía el mensaje, contando con la
 entrega asegurada de TCP para ello.
 
\end_layout

\begin_deeper
\begin_layout Standard
\align left
Si el cliente tiene más mensajes que enviar al servidor, repite este proceso
 sobre la misma conexión TCP.
 En otro caso, cierra la conexión TCP.
\end_layout

\end_deeper
\begin_layout Itemize
\align left

\bar under
¿Cómo el cliente SMTP sabe quién es el servidor SMTP al que debe enviar
 el mensaje?
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/smtpDiscov.png
	scale 90

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\align left
Como parte del diálogo, el cliente puede utilizar cinco comandos:
\end_layout

\begin_layout Itemize
\align left
HELO
\end_layout

\begin_layout Itemize
\align left
FROM
\end_layout

\begin_layout Itemize
\align left
RCPT TO
\end_layout

\begin_layout Itemize
\align left
DATA
\end_layout

\begin_layout Itemize
\align left
QUIT
\end_layout

\begin_layout Standard
\align left
También puede indicar una línea con un solo punto, lo que indica el final
 del mensaje al servidor.
\end_layout

\begin_layout Standard
\align left
Para cada comando, el servidor responde con un código de respuesta y posiblement
e alguna explicación.
\end_layout

\begin_layout Standard
\align left
Si el servidor mail del emisor tiene varios mensajes para enviar al mismo
 servidor receptor, puede enviarlos todos sobre la misma conexión TCP.
 Para cada mensaje, el cliente comienza el proceso con un nuevo 'MAIL FROM:',
 indica el el final del mensaje con un único punto y solo usa 'QUIT' cuando
 ha enviado todos los mensajes.
\end_layout

\begin_layout Subsubsection
Comparación con HTTP
\end_layout

\begin_layout Standard
Similitudes:
\end_layout

\begin_layout Itemize
Ambos protocolos se usan para transferir ficheros de un host a otro: HTTP
 transfiere ficheros (objetos) desde un servidor Web a un cliente Web; SMTP
 transfiere ficheros (emails) desde un servidor mail a otro servidor mail.
\end_layout

\begin_layout Itemize
Ambos usan conexiones persistentes.
\end_layout

\begin_layout Standard
Diferencias:
\end_layout

\begin_layout Itemize
HTTP es un 
\series bold
pull protocol
\series default
 (protocolo de pedir ('tirar')), alguien carga información en un servidor
 Web y los usuarios usan HTTP para pedir la información desde el servidor
 en conveniencia.
 Concretamente, la conexión TCP la inicia la máquina que desea recibir el
 fichero.
 Por otro lado, SMTP es un 
\series bold
push protocol 
\series default
(protocolo de dar ('empujar')), el servidor mail emisor envía el fichero
 al servidor receptor.
 En particular, la conexión TCP la comienza la máquina que quiere enviar
 el fichero.
\end_layout

\begin_layout Itemize
SMTP presenta la restricción de la codificación en 7-bit ASCII, pero HTTP
 no.
\end_layout

\begin_layout Itemize
HTTP encapsula cada objeto en su propio mensaje de respuesta HTTP, mientras
 que SMTP coloca todos los objetos del mensaje en un mensaje
\end_layout

\begin_layout Subsubsection
Formato de los mensajes de correo electrónico
\end_layout

\begin_layout Standard
Consiste en:
\end_layout

\begin_layout Itemize
Una cabecera que contiene información general.
 Esta está contenida en una serie de líneas de cabecera.
 Las líneas de cabecera y el cuerpo del mensaje se separan por una línea
 en blanco.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/headersŚMTP.png

\end_inset


\end_layout

\begin_layout Standard
Como en HTTP, cada línea de cabecera contiene texto leíble, consistente
 en una palabra clave seguida de ':' seguida de un valor.
 Algunas keyword son obligatorias y otras son opcionales.
\end_layout

\begin_layout Standard
Toda cabecera debe contener las líneas de cabecera 'From:' y 'To:'.
\end_layout

\end_deeper
\begin_layout Itemize
Tras la cabecera, una línea en blanco y después el cuerpo del mensaje (en
 ASCII).
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/formatoSMTP.png

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Protocolos de acceso al email
\end_layout

\begin_layout Standard
\align left
El acceso al email utiliza una arquitectura cliente-servidor.
 El usuario típico lee emails con un cliente que se ejecuta en el sistema
 final del usuario.
 Ejecutando un cliente mail en un ordenador local, los usuarios disfrutan
 de muchas características, como la habilidad de ver mensajes con contenido
 multimedia y archivos adjuntos.
\end_layout

\begin_layout Standard
\align left
Si suponemos que B (el receptor) ejecuta su user agent en su ordenador local,
 es natural considerar colocar un servidor mail en su ordenador local también.
 Con esta enfoque, el servidor mail de A (el emisor) dialogaría directamente
 con el ordenador de B.
 El problema está en que, en este caso, el ordenador de B debería quedar
 permanentemente encendido y conectado a internet, para poder recibir nuevos
 correos, pues estos pueden llegar en cualquier momento.
 Esto no es práctico para la mayoría de usuarios.
\end_layout

\begin_layout Standard
\align left
En lugar de esto, los usuarios suelen ejecutar un user agent en ordenador
 local pero acceden a su mailbox almacenado en un servidor mail compartido
 y siempre en línea.
 Este servidor se comparte con otros usuarios y normalmente lo mantiene
 el ISP del usuario.
\end_layout

\begin_layout Standard
\align left
Ahora bien, normalmente el user agent de A no dialoga directamente con el
 servidor mail de B, sino que usa SMTP para dar el mensaje email a su servidor
 mail, entonces el servidor mail de A usa SMTP (como cliente) para entregar
 el mensaje email al servidor mail de B.
\end_layout

\begin_layout Standard
\align left

\bar under
¿Por qué un procedimiento en dos pasos?
\end_layout

\begin_layout Standard
\align left
Porque sin retransmitir por el servidor mail de A, el user agent de A no
 tiene ninguna salida a un servidor mail destino inalcanzable.
 Haciendo que A primero deposite su email en su servidor mail, este puede
 intentar reenviar el mensaje repetidamente al servidor mail de B, hasta
 que este esté operativo.
\end_layout

\begin_layout Standard
\align left
Ahora bien, falta ver cómo B, ejecutando un user agent en su ordenador local,
 obtiene sus mensajes, que están en un servidor mail del ISP de B.
 Nótese que el user agent de B no puede usar SMTP para obtener los mensajes
 porque obtener los mensajes es una operación pull, mientras que SMTP es
 un protocolo push.
 Para este propósito se introduce un porotoclo especial de correo que transfiere
 mensajes del servidor mail de B a su ordenador local.
\end_layout

\begin_layout Itemize

\series bold
POP3:
\series default
 es un procotolo de acceso al correo extremadamente simple, por lo que su
 funcionalidad es limitada.
\end_layout

\begin_deeper
\begin_layout Standard
POP3 coienza cuando el user agent (el cliente) inicia una conexión TCP con
 el servidor mail (el servidor) en el puerto 110.
 Con la conexión TCP establecida, POP3 progresa por tres fases: authorization,
 transaction y update.
\end_layout

\begin_layout Itemize

\series bold
Authorization: 
\series default
el user agent envía un nombre de usaurio y contraseña para autenticar al
 usuario
\end_layout

\begin_layout Itemize

\series bold
Transaction: 
\series default
el user agent obtiene los mensajes.
 También durante esta fase el user agent puede marcar mensajes para su borrado,
 quitar marcas de borrado y obtener estadísticas
\end_layout

\begin_layout Itemize

\series bold
Update:
\series default
 cuando el cliente ejecuta el comando 'quit' acaba la sesión POP3.
 En este momento, el servidor mail elimina los mensajes que fueron marcados
 para borrado.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/estaodsPOP3.png

\end_inset


\end_layout

\begin_layout Standard
En una transación POP3, el user agent emite comandos y el servidor responde
 a cada comando.
 Hay dos posibles respuestas:
\end_layout

\begin_layout Itemize

\series bold
+OK: 
\series default
a veces seguido de datos del servidor para el cliente.
 Lo usa el servidor para indicar que el comando anterior estaba bien
\end_layout

\begin_layout Itemize

\series bold
-ERR:
\series default
 usado por el servidor para indicar que hubo algún error con el comando
 anterior.
\end_layout

\begin_layout Standard
La fase de autorización tiene dos comandos principales: 'user <username>'
 y 'pass <password>'
\end_layout

\begin_layout Standard
Si escribes mal un comando, el servidor POP3 responderá con mensaje -ERR.
\end_layout

\begin_layout Standard
Un user agent que usa POP3 puede ser configurado de dos modos:
\end_layout

\begin_layout Itemize

\series bold
download-and-delete mode: 
\series default
el user agent ejecuta los comandos 'list', 'retr' y 'dele'.
 Es decir, el user agent primero pide al servidor mail que liste el tamaño
 de cada uno de los mensajes almacenados.
 Entocnes el user agent obtiene y elimina cada mensaje del servidor.
 Tras procesar el comando 'quit', el servidor POP3 entra en la fase update
 y elimina los mensajes del mailbox.
 Un problema de este modo es que B podría ser nómada y quere acceso a sus
 emails desde distintas máquinas.
 En este modo, una vez que lea un mensaje en una máquina, se eliminará del
 servidor y no podrá acceder a él desde otras máquinas.
\end_layout

\begin_layout Itemize

\series bold
download-and-keep mode:
\series default
 el user agente deja los mensajes en el servidor después de descargarlos
\end_layout

\begin_layout Standard
Durante una sesión POP3 entre un user agent y un servidor mail, el servidor
 POP3 mantiene alguna información de estado.
 Hace un seguimiento de qué mensajes del usuario han sido marcados para
 borrado.
 Sin embargo, el servidor POP3 no mantiene información de estado entre diferente
s sesiones.
 Esta falta de información de estado entre distintas sesiones simplifica
 mucho la implementación de un servidor POP3.
\end_layout

\begin_layout Standard
Con el acceso POP3, una vez que B ha descargado sus mensajes a su máquina
 local, puede crear carpetas de correo y mover los mensajes descargados
 a estas.
 B puede entonces eliminar mensajes, moverlos de carpeta y buscar mensajes.
 Pero este paradigma (
\series bold
carpetas y mensajes en la máquina local
\series default
) posee un problema para el usuario nómada, que prefiere mantener una jerarquía
 de correos en un servidor remoto que puede ser accedido desde cualquier
 orndeador.
 Esto no es posible con POP3.
 Para solucionar este y otros problemas, se inventa el protocolo IMAP.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
IMAP: 
\series default
es un procotolo de acceso a correo.
 Tiene muchas más caracterísitcas que POP3, pero es también mucho más complejo.
\end_layout

\begin_deeper
\begin_layout Standard
Un servidor IMAP asocia cada mensaje con una carpeta.
 Cuando un mensaje llega por primera vez al servidor, se asocia a la carpeta
 INBOX del receptor.
 El receptor puede entonces mover el mensaje a una nueva carpeta creada
 por él, leer el mensaje, eliminarlo,...
\end_layout

\begin_layout Standard
Luego, todas las comunicaciones toman la forma de comandos enviados por
 el cliente y respuestas retornadas por el servidor (como POP3).
 Es posible enviar varios comandos a la vez y posee cuatro estados: NOT
 AUTHENTICATED, AUTHENTICATED, SELECTED, LOGOUT.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/estadosIMAP.png
	scale 90

\end_inset


\end_layout

\begin_layout Standard
IMAP proporciona comandos para permitir a los usuarios crear carpetas y
 mover mensajes entre carpetas.
 IMAP también proporciona comandos que permiten a los usuarios buscar en
 carpetas remotas mensajes que verifiquen ciertos criterios.
 
\end_layout

\begin_layout Standard
Nótese que para esto IMAP debe mantener información de estado del usuario
 entre sesiones IMAP diferentes.
\end_layout

\begin_layout Standard
También tiene comando que permiten a un user agent obtener componentes de
 mensajes
\end_layout

\begin_layout Standard
IMAP funciona sobre TCP en el puerto 143, en un modelo cliente-servidor.
 Primero se establece la conexión IMAP.
 
\end_layout

\begin_layout Standard
Pero presenta una desventaja: si no hay conexión IP no se puede acceder
 a este servicio y, por tanto, el correo no está disponible.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Web Mail: 
\series default
Con este servicio, el user agent es un navegador Web normal, y el usuario
 se comunica con su mailbox remoto via HTTP.
 Cuando un receptor quiere acceder a un mensaje en su mailbox, el email
 es enviado desde el servidor mail del receptor al navegadir del receptor
 usando el protocolo HTTP en lugar de POP3 o IMAP.
 Cuando un emisor quiere enviar un mensaje, el email es enviado desde su
 navegador a su servidor mail sobre HTTP en lugar de sobre SMTP.
\end_layout

\begin_layout Subsection
MIME
\end_layout

\begin_layout Standard
\align left

\series bold
Multipurpose Internet Mail Extension (MIME)
\series default
 es una extensión en el marco del RFC 5322 que intenta solventar algunos
 de los problemas y limitaciones del uso de SMTP.
\end_layout

\begin_layout Standard
\align left
Las limitaciones del esquema SMTP/5322 son:
\end_layout

\begin_layout Itemize
\align left
SMTP no puede transmitir ficheros ejecutables u otros objetos binarios
\end_layout

\begin_layout Itemize
\align left
SMTP no puede transmitir datos que incluyan caracteres nacionales de algunos
 lenguajes por la representación en códigos de 8 bits
\end_layout

\begin_layout Itemize
\align left
Los servidores SMTP pueden rechazar emails que sobrepasen cierto tamaño
\end_layout

\begin_layout Itemize
\align left
Los mecanismos SMTP que traducen entre ASCII y el código EBCDIC no usan
 un conjunto consistente de mapeado, resultando en problemas de traducción
\end_layout

\begin_layout Itemize
\align left
Las interfaces SMTP de redes email X.400 no pueden manejar datos no textuales
 incluidos en los mensajes X.400
\end_layout

\begin_layout Itemize
\align left
Algunas implementaciones SMTP no se ajustan totalmente al estándar SMTP
\end_layout

\begin_layout Standard
\align left
MIME intenta resolver estos problemas de una forma que sea compatible con
 el estándar 5322.
 La especificación de MIME incluye los elementos siguientes:
\end_layout

\begin_layout Enumerate
\align left
Se definen 5 nuevos campos de cabecera, que proporcionan información sobre
 el cuerpo del mensaje
\end_layout

\begin_layout Enumerate
\align left
Se define una cantidad de formatos de contenido, lo que estandariza las
 representaciones que permiten el email multimedia
\end_layout

\begin_layout Enumerate
\align left
Las codificaciones se definen de forma que permitan la conversión de cualquier
 formato de contenido a una forma que quede protegida de cualquier alteración
 por el sistema de mensajes
\end_layout

\begin_layout Standard
\align left
Los 
\series bold
campos de cabecera
\series default
 definidos en MIME son:
\end_layout

\begin_layout Itemize
\align left

\series bold
MIME-version:
\series default
 debe tener el valor 1.0.
 Este campo indica que el mensaje se adecúa a los RFCs 2045 y 2046
\end_layout

\begin_layout Itemize
\align left

\series bold
Content-type:
\series default
 describe los datos contenidos en el cuerpo con suficiente detalle que el
 user agent receptos puede elegir el mecanismo correcto de representación
 de datos para el usuario o tratar esos datos de la forma adecuada
\end_layout

\begin_layout Itemize
\align left

\series bold
Content-Transfer-Encoding:
\series default
 indica el tipo de transformación que ha sido usada para representar el
 cuerpo del mensaje de una forma que sea aceptable para el transporte
\end_layout

\begin_layout Itemize
\align left

\series bold
Content-ID:
\series default
 usado para identificar entidades MIME de forma unívoca en múltiples contextos
\end_layout

\begin_layout Itemize
\align left

\series bold
Content-Description:
\series default
 una descripción de texto del objeto con el cuerpo.
 Esto es útil cuando el objeto no es leíble.
\end_layout

\begin_layout Subsubsection*
MIME content types
\end_layout

\begin_layout Standard
\align left
El bulto de la especificación MIME se preocupa de la definición de una variedad
 de tipos de contenido.
 Esto refleja la encesidad de proporcionar maneras estandarizadas de tratar
 con una amplia variedad de representaciones de la información en un entorno
 multimedia.
\end_layout

\begin_layout Standard
\align left
Para el 
\series bold
text type
\series default
 del cuerpo, no se requiere ningún software especial para conseguir el total
 significado del texto aparte del soporte para el conjunto de caracteres
 (character set) indicado.
\end_layout

\begin_layout Standard
\align left
El campo 
\series bold
multipart type
\series default
 indica que el cuerpo contiene partes múltiples e independientes.
 El campo de cabecera Content-Type incluye un parámetro, llamado boundary,
 que define el delimitador entre partes del cuerpo.
 Este boundary no debe aparecer en ninguna parte del mensaje.
 Cada boundary comienza en una nueva línea y consiste en dos guiones seguidos
 del valor de boundary.
 El boundary final, que indica el final de la última parte, también tiene
 un sufijo con dos guiones.
 En cada parte, puede haber un encabezado opcional MIME.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/mimeMultipart.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align left
Hay 4 subtipos del multipart type, y todos tienen la misma sintaxis general.
 
\end_layout

\begin_layout Itemize
\align left
El 
\series bold
multipart/mixed subtype
\series default
 se usa cuando hay múltiples partes independientes en el cuerpo que necesitan
 ser tratadas en un orden en particular.
 
\end_layout

\begin_layout Itemize
\align left
Para el 
\series bold
multipar/parallel subtype
\series default
 el orden de las partes no es significativo.
\end_layout

\begin_layout Itemize
\align left
El 
\series bold
multipart/alternative subtype
\series default
 indica que las distintas partes son diferentes representaciones de la misma
 información.
 Las partes se ordenan en términos de preferencia creciente
\end_layout

\begin_layout Itemize
\align left
El 
\series bold
multipart/digest subtype
\series default
 se usa cuando cada parte del cuerpo se interpreta como un mensaje RFC 5322
 con cabeceras.
 Este subtipo permite la construcción de un mensaje cuyas partes son mensajes
 individuales
\end_layout

\begin_layout Standard
\align left
El 
\series bold
message type
\series default
 proporciona una cantidad importante de capacidades en MIME:
\end_layout

\begin_layout Itemize
\align left

\series bold
message/rfc822 subtype
\series default
 indica que el cuerpo es un mensaje completo, incluyendo cabecera y cuerpo.
 A pesar el nombre del subtipo, el mensaje encapsulado podría no ser solo
 un mensaje RFC 5322 sino cualquier mensaje MIME
\end_layout

\begin_layout Itemize
\align left

\series bold
message/partial subtype
\series default
 permite la fragmentación de un mensaje grande en partes, que deben ser
 reunidas en destino.
 Se especifican tres parámetros en el Content-Type: 
\end_layout

\begin_deeper
\begin_layout Itemize
\align left
Message/Partial: un id común a todos los fragmentos de todo el mensaje
\end_layout

\begin_layout Itemize
\align left
Un número de secuencia único para cada fragmento
\end_layout

\begin_layout Itemize
\align left
El número total de fragmentos
\end_layout

\end_deeper
\begin_layout Itemize
\align left

\series bold
message/external-body subtype
\series default
 indica que los datos transmitidos en este mensaje no están contenidos en
 el cuerpo.
 En su lugar, el cuerpo contiene la información necesaria para acceder los
 datos.
 Tiene una cabecera externa y un mensaje encapsulado con su propia cabecera.
 El único campo necesario en la cabecera exterior es el Content-Type, que
 indicará que es un message/external-body subtype.
 La cabecera itnerior es la cabecera del mensaje para el mensaje encapsulado.
 El campo Content-Type en la cabecera exterior debe incluir un parámetro
 access-type, que indica el método de acceso, como FTP
\end_layout

\begin_layout Itemize
\align left

\series bold
application type
\series default
 refiere a otros tipos de datos, tipicamente o datos binarios sin interpretar
 o información para ser procesada por una aplicación basada en mail
\end_layout

\begin_layout Subsubsection*
MIME transfer encodings
\end_layout

\begin_layout Standard
\align left
El otro componente principal de la especificación MIME es la definición
 de las codificaciones de transferencia para los cuerpos de los mensajes.
 El objetivo es proporcionar una entrega asegurada a través del mayor rango
 posible de entornos.
\end_layout

\begin_layout Standard
\align left
El estandar MIME define dos métodos de codificación de datos.
 El campo 
\series bold
Content.Transfer-Encoding
\series default
 puede tomar 6 valores.
 Sin embargo, tres de estos valores (7bit, 8bit y binario) indican que ninguna
 codificación se ha efectuado, solo proporciona información sobre el futuro
 de los datos.
\end_layout

\begin_layout Standard
\align left
Otro valor es 
\series bold
x-token
\series default
, que indica que algún otro esquema de codificación se ha utilizado pero
 su nombre debe ser proporcionado.
 Esto puede ser un esquema específico de una aplicación concreta.
\end_layout

\begin_layout Standard
\align left
La codificación 
\series bold
quoted-printable
\series default
 es útil cuando los datos consisten mayoritariamente en octetos que se correspon
den con caracteres ASCII printables.
 Representa caracteres inseguros para la representación hexadecimal de su
 código e introduce line breaks reversibles para limitar las líneas del
 mensaje a 76 caracteres.
\end_layout

\begin_layout Standard
\align left
La codificación 
\series bold
base64
\series default
 es común para codificar datos binarios de tal forma que sea invulnerable
 al procesamiento por los programas de transporte mail
\end_layout

\begin_layout Subsubsection*
Forma Canónica
\end_layout

\begin_layout Standard
Es el formato apropiado para el content type, que se estandariza para el
 uso entre sistemas.
 Esto está en ocntraste con la forma nativa, que es el formato que puede
 ser peculiar para un sistema concreto.
\end_layout

\begin_layout Section
Protocolos de acceso a la red: DNS
\end_layout

\begin_layout Standard
El identificador de un host es su 
\series bold
hostname
\series default
, que son mnemotécnicos y por tanto entendibles por los humanos.
 Sin embargo, proporcionan muy poca o ninguna información sobre la localización
 en Internet del host.
 Además, como los hostnames consisten en cadenas de texto de longitud variable,
 serían muy difíciles de procesar por los routers.
 Por estas razones, los hosts también se identifican por las llamadas 
\series bold
direcciones IP,
\series default
 que consisten en 4 bytes y tienen una estructura jerárquica rígida.
 Es jerárquica porque conforme procesamos la dirección de izquierda a derecha,
 obtenemos más y más información específica sobre dónde está el host en
 internet.
\end_layout

\begin_layout Subsection
Servicios proporcionados por el DNS
\end_layout

\begin_layout Standard
El 
\series bold
domain name system (DNS)
\series default
 es (1) una base de datos distribuida implementada en una jerarquía de servidore
s DNS y (2) un protocol de la capa de aplicación que permite a los host
 hacer peticiones a la base de datos distribuida.
\end_layout

\begin_layout Standard
El protocolo DNS se ejecuta sobre UDP y usa el puerto 53.
\end_layout

\begin_layout Standard
DNS es comúnment empleado por otros protocolos del nivel de aplicación para
 traducir los hostnames proporcionados por los usuarios a direcciones IP.
 Esto se hace de la siguiente forma:
\end_layout

\begin_layout Enumerate
La máquina del usuario ejecuta la parte del cliente de la aplicación DNS
\end_layout

\begin_layout Enumerate
El navegador extrae el hostname de la URL y pasa el hostname a la parte
 del cliente de la aplicación DNS
\end_layout

\begin_layout Enumerate
El cliente DNS envía una petición que contiene el hostname a un servidor
 DNS
\end_layout

\begin_layout Enumerate
El cliente DNS recibirá una respuesta, que incluirá la dirección IP para
 ese hostname
\end_layout

\begin_layout Enumerate
Una vez el navegador recibe la dirección IP desde el DNS, puede iniciar
 una conexión TCP con el servidor HTTP localizado en el puerto 80 de esa
 dirección IP
\end_layout

\begin_layout Standard
Vemos como el uso del DNS añade un delay adicional a la aplicaciones que
 lo usan.
\end_layout

\begin_layout Standard
Además de traducir hostnames a direcciones IP, DNS proporciona otros servicios
 importantes:
\end_layout

\begin_layout Itemize

\series bold
Host aliasing:
\series default
 un host con un hostname complejo puede tener uno o más alias.
 Uno de ellos será el 
\series bold
hostname canónico
\series default
, los demás son los 
\series bold
hostname alias
\series default
, que cuando están presentes son normalmente más fáciles de recordar que
 los canónicos.
 Así, DNS puede ser invocado por una aplicación para obtener el hostname
 canónico para un alias proporcionado, así como la dirección IP del host.
\end_layout

\begin_layout Itemize

\series bold
Mail server aliasing:
\series default
 es altamente deseable que las direcciones email sean fáciles de recordar.
 DNS puede ser invocado por una aplicación mail para obtener el hostname
 canónico para un alias proporcionado, así como la dirección IP del host.
 De hecho, el 
\series bold
registro MX
\series default
 permite al servidor mail y web de una compañía tener hostnames idénticos
\end_layout

\begin_layout Itemize

\series bold
Distribución de carga:
\series default
 DNS se usa también para dsitribuir la carga entre servidores replicados.
 Sitios muy visitados se replican en distintos servidores, con cada servidor
 ejecutándose en diferentes sistemas finales y cada uno con una dirección
 IP distinta.
 Para servidores web replicados, un conjunto de direcciones IP se asocia
 con el hostname canónico.
 La base de datos DNS contiene este conjunto de direcciones IP.
 Cuando los clientes hacen una petición DNS por un nombre mapeado a un conjunto
 de direcciones, el servidor responde con el conjunto completo de direcciones
 IP, pero rota el orden de las direcciones con cada respuesta.
 Como un cliente normalmente envía sus peticiones HTTP a la dirección IP
 listada en primera posición, la rotación que hace DNS distribuye el tráfico
 entre los servidores replicados
\end_layout

\begin_layout Subsection
Visión general del funcionamiento de DNS
\end_layout

\begin_layout Standard
\align left
Supongamos que alguna aplicación que está ejecutándose en la máquina de
 un usuario necesita traducir un hostname a una dirección IP.
 La aplicación invocará la parte de cliente del DNS, especificando el hostname
 que quiere traducir.
 Ahora DNS toma el control, enviando una petición a la red.
 Todos los mensajes de petición y respuesta DNS se envían mediante datagramas
 UDP al puerto 53.
 Tras un delay (desde ms a s), el DNS en la máquina del usuario recibe un
 mensaje de respuesta DNS que proporciona la traducción deseada.
 Esta traducción se pasa entonces a la aplicación que la requirió.
\end_layout

\begin_layout Standard
\align left
Desde la perspectiva de la aplicación en el ordenador del usuario, el DNS
 es una caja negra que le da un servicio de traducción simple y directa.
 Pero, de hecho, la caja negra que implementa el servicio es compleja y
 consiste de un gran número de servidores DNS distribuidos por el mundo,
 así como un protocolo en la capa de aplicación que especifica cómo los
 servidores y clientes DNS se comunican.
\end_layout

\begin_layout Standard
\align left
Un diseño simple para DNS sería tener un solo servidor DNS que contuviera
 todas las traducciones.
 En este 
\series bold
diseño centralizado
\series default
 los clientes envían las peticiones directamente al único servidor DNS,
 que responde directamente a los clientes solicitantes.
 Aunque la simplicidad del diseño es atractiva, no es apropiada para el
 Internet actual.
 Presenta los siguientes problemas:
\end_layout

\begin_layout Itemize
\align left
Tiene un único punto de fallo: si el servidor DNS falla, cae todo Internet
\end_layout

\begin_layout Itemize
\align left
Volumen de tráfico: un único servidor DNS debería manejar todas las peticiones
\end_layout

\begin_layout Itemize
\align left
Base de datos centralizada y distante: un único servidor DNS no puede estar
 cerca de todos los clientes solicitantes
\end_layout

\begin_layout Itemize
\align left
Mantenimiento: el único servidor DNS debería mantener la información de
 todos los hosts de Internet.
 No solo debería ser enorme, sino que debería de actualizarse constantemente
 para tener en cuenta a todos los nuevos hosts
\end_layout

\begin_layout Standard
\align left
Por tanto, una base de datos centralizada en un único servidor DNS no escala.
 Consecuentemente, DNS debe ser distribuido.
\end_layout

\begin_layout Subsubsection*
Una base de datos jerárquica y distribuida
\end_layout

\begin_layout Standard
\align left
Para tratar el problema de la escalabilidad, DNS usa un gran número de servidore
s, organizados de forma jerárquica y distribuidos por el mundo.
 Ningún servidor tiene por sí solo todas las traducciones para todos los
 hosts de Internet.
\end_layout

\begin_layout Standard
\align left
En una primera aproximación, hay tres grandes clase de servidores DNS, organizad
os jerárquicamente.
\end_layout

\begin_layout Standard
\align left
El cliente primero contacta uno de los 
\series bold
servidores raíz 
\series default
(root servers), que devuelven la dirección de los 
\series bold
servidores TLD 
\end_layout

\begin_layout Standard
\align left
(top level domain).
 El cliente entonces contacta uno de estos servidores TLD, que le devuelve
 la dirección de un 
\series bold
servidor autorizado 
\series default
(authoritative).
 Finalemente, el cliente contacta uno de estos servidores autorizados, que
 le devuelve la dirección IP del hostname buscado.
\end_layout

\begin_layout Itemize
\align left

\series bold
Servidores DNS raíz:
\series default
 en Internet hay 13 servidores DNS raíz, la mayoría de los cuales están
 en Norteamérica.
 Aunque nos hayamos referido a cada uno de los 13 servidores DNS raíz como
 si fueran un único servidor, cada servidor es en realidad una red de servidores
 replicados, para proporcionar seguridad y fiabilidad.
 En total hay 247 servidores raíz.
\end_layout

\begin_layout Itemize
\align left

\series bold
Servidores TLD:
\series default
 estos servidores son responsables de los dominios de alto nivel como com,
 org, net, edu o gov, además de los dominios de alto nivel de cada país.
\end_layout

\begin_layout Itemize
\align left

\series bold
Servidores DNS autorizados:
\series default
 toda organización con hosts públicamente accesibles en Internet deben proporcio
nar registros DNS accesibles públicamente que mapeen los nombres de esos
 hosts con direcciones IP.
 Un DNS autorizado de una organización almacena estos registros DNS.
 Una organización puede elegir implementar su propio servidor DNS autorizado
 o pagar por tener estos registros almacenados en un servidor DNS autorizado
 de algún proveedor de servicios.
\end_layout

\begin_layout Standard
\align left
Hay otro tipo importante de servidor DNS llamado 
\series bold
servidor DNS local
\series default
, que no pertenece estrictamente a la jerarquía de servidores pero es importante
 en la arquitectura de DNS.
 Cada ISP tiene un servidor DNS local.
 Cuando un host conecta con un ISP, este proporciona al host la IP de uno
 o más de sus servidores DNS locales.
 Cuando un host hace una petición DNS, la petición es enviada al servidor
 DNS local, que actúa como un proxy, reenviando la petición a la jerarquía
 de servidores DNS.
\end_layout

\begin_layout Standard
\align left
La solicitud de 
\series bold
búsqueda iterativa
\series default
 realiza una búsqueda en la base de datos de la dirección IP relacionada
 con el nombre de dominio, si no la obtiene pregunta al dominio donde realizar
 la próxima búsqueda.
 Si la consulta es 
\series bold
recursiva
\series default
, la resolución prevé la dirección de nuevo sin necesidad de realizar ningún
 otra consulta.
 Si es iterativa, el servidor DNS devuelve una dirección donde puede estar
 ubicada la dirección y si no, se conserva en la misma dirección.
 La resolución depende de la posibilidad de contactar la dirección o si
 se debe ubicar una ruta a través de su propia lista de servidores DNS.
 
\end_layout

\begin_layout Standard
Iterativa:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/dnsiter.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
Recursiva:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/dnsrec.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align left
Lo más común es que la petición del cliente al DNS local sea recursiva,
 pero las siguientes sean iterativas.
\end_layout

\begin_layout Subsubsection*
DNS Caching
\end_layout

\begin_layout Standard
\align left
DNS explota el DNS caching para mejorar los delays y reducir el número de
 mensajes DNS circulando por la red.
 En una cadena de peticiones, cuando un servidor DNS recibe una respuesta
 DNS, puede cachear la traducción en su memoria local.
\end_layout

\begin_layout Standard
\align left
Si un par hostname/IP es cacheado en un servidor DNS y una nueva petición
 llega al servidor preguntando por el mismo hostname, ahora puede dar la
 traducción directamente, aunque no sea un servidor autorizado para el hostname.
 Como los hosts y las traducciones entre hostnames y direcciones IP no son
 permanentes, los servidores DNS descartan la información cacheada tras
 un período de tiempo.
\end_layout

\begin_layout Subsection
Registros y mensajes DNS
\end_layout

\begin_layout Standard
\align left
Los servidores DNS implementan la base de datos distribuida DNS y almacenan
 
\series bold
resource records (RRs)
\series default
.
 Cada mensaje de respuesta DNS lleva uno o más RRs.
 Un RR es una cuádrupla que contiene los campos:
\end_layout

\begin_layout Standard
\align center
(Name, Value, Type, TTL)
\end_layout

\begin_layout Standard
\align left

\series bold
TTL
\series default
 es el tiempo de vida del RR, determina cuándo un RR debería ser eliminado
 de la caché.
 El significado de 
\series bold
name 
\series default
y 
\series bold
value
\series default
 depende de 
\series bold
type:
\end_layout

\begin_layout Itemize
\align left

\series bold
type=A
\series default
: entonces Name es el hostname y Value es la dirección IP asociada al hostname
\end_layout

\begin_layout Itemize
\align left

\series bold
type=NS:
\series default
 entonces Name es un domiio y Value es el hostname de un servidor DNS autorizado
 que conoce cómo obtener las direcciones IP de hosts en ese dominio
\end_layout

\begin_layout Itemize
\align left

\series bold
type=CNAME:
\series default
 entonces Value es el hostname canónico del hostname alias Name
\end_layout

\begin_layout Itemize
\align left

\series bold
type=MX:
\series default
 entonces Value es el hostname canónico de un servidor mail que tiene un
 hostname alias Name
\end_layout

\begin_layout Standard
\align left
Si un servidor DNS es autorizado para un hostname particular, entonces el
 DNS contendrá un registro Type A para el hostname.
\end_layout

\begin_layout Standard
\align left
Si un servidor no es autorizado para un hostname, entonces el servidor contendrá
 un registro Type NS para el dominio que incluye el hostname.
 También contendrá un registro Type A que proporcionará la dirección IP
 del servidor DNS en el campo Value del registro NS.
\end_layout

\begin_layout Subsubsection*
Mensajes DNS
\end_layout

\begin_layout Standard
Los mensajes de petición y respuesta tienen el mismo formato.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/dnsmes.png
	scale 60

\end_inset


\end_layout

\begin_layout Itemize
Los primeros 12 bytes son la 
\series bold
sección de cabecera
\series default
.
 El primer campo es un número de 16 bits que identifica la petición.
 Este identificador se copia en el mensaje de respuesta a una petición,
 permitiendo al cliente asociar respuestas recibidas con peticiones enviadas.
 Hay una cantidad de flags en el 
\series bold
campo de flags
\series default
.
 Un flag query/reply de 1 bit que indica si el mensaje es una petición (0)
 o una respuesta (1).
 Un flag autorizado de 1 bit que vale 1 cuando el servidor DNS es autorizado
 para un nombre requerido.
 Un flag de recursion-desired de 1 bit que se pone a 1 cuando el cliente
 desea que el servidor DNS efectúe recursión cuando no encuentre el registro.
 Un flag de recursion-available de 1 bit que se pone a 1 en una respuesta
 cuando el servidor DNS soporta recursión.
 En la cabecera, también hay cuatro campos de números, que indican la cantidad
 de ocurrencias de los cuatro tipos de secciones de datos que siguen a la
 cabecera.
\end_layout

\begin_layout Itemize

\series bold
Sección de pregunta:
\series default
 contiene información sobre la petición que se está haciendo.
 Incluye (1) un campo de nombre que contiene el nombre por el que se pregunta
 y (2) y campo de tipo que indica el tipo de pregunta que se está haciendo
 acerca del nombre
\end_layout

\begin_layout Itemize

\series bold
Sección de respuesta:
\series default
 contiene los RRs para el nombre por el que se preguntó.
 Una pregunta puede retornar varios RRs en la respuesta, porque un hostname
 puede tener múltiples direcciones IP
\end_layout

\begin_layout Itemize

\series bold
Sección de autoridad:
\series default
 contiene registros de otros servidores autorizados
\end_layout

\begin_layout Itemize

\series bold
Sección adicional:
\series default
 contiene otros registros útiles
\end_layout

\begin_layout Subsubsection*
Insertando Registros en la base de datos DNS
\end_layout

\begin_layout Standard
Un 
\series bold
registrador (registrar)
\series default
 es una entidad comercial que verifica la unicidad de un nombre de dominio,
 introduce el nombre de dominio en la base de datos DNS y recibe una tasa
 por estos servicios.
\end_layout

\begin_layout Standard
Cuando registras el nombre de dominio networkutopia.com con algún registrador,
 necesitas proporcionar al registrador los nombres y direcciones IP de tus
 servidores DNS autorizados primario y secundario.
 Para cada uno de los servidores DNS autorizados, el registrador debe asegurar
 que los registros Type NS y Type A se introducen en los servidores TLD
 com.
 También debes asegurarte de que los RR Type A de tu servidor web y el RR
 Type MX de tu servidor de correo están introducidos en tus servidores DNS
 autorizados.
\end_layout

\begin_layout Subsection
DNS primario y secundario
\end_layout

\begin_layout Standard
Existen dos tipos de servidores DNS:
\end_layout

\begin_layout Itemize

\series bold
Primario o Maestro:
\series default
 almacenan en el mismo ordenador la información referente a las zonas que
 gestiona
\end_layout

\begin_layout Itemize

\series bold
Secundario o Esclavo:
\series default
 obtiene información sobre una zona copiando la que tiene el servidor primario
 que la administra
\end_layout

\begin_layout Standard
Los dos están autorizados a responder sobre una zona, y se encuentran en
 direcciones IP distintas.
\end_layout

\begin_layout Subsection
Vulnerabilidades del DNS
\end_layout

\begin_layout Itemize

\series bold
Ataque DDoS de inundación de ancho de banda:
\series default
 un atacante podría intentar enviar a cada servidor raíz un diluvio de paquetes,
 de forma que la mayor parte de peticiones DNS legítimas no puedan ser respondid
as.
 Un ataque DDoS a tan gran escala tuvo lugar.
 Los atacantes usaron una botnet para enviar muchísimos mensajes ping ICMP
 a cada uno de los 13 servidores raíz.
 Sin embargo, el daño fue mínimo.
 Los atacantes consiguieron enviar un diluvio de paquetes a los servidores
 raíz, pero muchos de estos servidores estaban protegidos con filtros de
 paquetes, configurados para bloquear siempre los ping ICMP dirigidos a
 los servidores raíz.
 Estos servidores protegidos estaban funcionando de forma normal.
\end_layout

\begin_deeper
\begin_layout Standard
Un ataque DDoS potencialmente más peligroso sería enviar un aluvión de peticione
s DNS a un servidor TLD.
 Sería más complicado filtrar las peticiones DNS dirigidas a los servidores
 DNS, y los servidores TLD se acceden más comúnmente que los servidores
 raíz.
 De todas formas, la severidad de estos ataques sería parcialmente mitigada
 por el caching en los servidores DNS locales
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Ataque Man-in-the-middle: 
\series default
el atacante intercepta peticiones desde los host y devuelve respuestas falsas.
\end_layout

\begin_layout Itemize

\series bold
Ataque DNS poisoning:
\series default
 el atacante envía respuestas falsas a un servidor DNS, engañando al servidor
 aceptando registros falsos en su caché.
 
\end_layout

\begin_deeper
\begin_layout Standard
Cualquiera de estos ataques podría ser utilizado para redirigir a un usuario
 despistado a la web del atacante.
 Sin embargo, la implementación de estos ataques es compleja.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Ataque DDoS a un host objetivo:
\series default
 el atacante envía peticiones DNS a muchos servidores DNS autorizados, cada
 petición conteniendo como dirección de origen la del host objetivo.
 El servidor DNS entonces envía sus respuestas directamente al host objetivo.
 Si las peticiones pueden hacerse de tal forma que la respuesta sea mucho
 más larga que la petición, entonces el atacante puede, potencialmente,
 abrumar al objetivo sin generar mucho de su propio tráfico.
 Pero este ataque ha tenido muy poco impacto hasta el momento.
\end_layout

\begin_layout Standard
Así, DNS ha demostrado ser sorprendentemente robusto contra ataques.
\end_layout

\begin_layout Section
Protocolos de acceso a la red: DHCP
\end_layout

\begin_layout Standard
\align left
Un host normalmente tiene un único enlace a la red.
 Cuando IP en el host quiere enviar un datagrama, lo hace por ese enlace.
 La frontera entre el host y el enlace fñisico se denomina 
\series bold
interfaz
\series default
.
\end_layout

\begin_layout Standard
\align left
Un router tiene múltiples interfaces, una para cada enlace.
 Como cada host y router es capaz de enviar y recibir datagramas IP, IP
 requiere que cada host y cada interfaz de un router tenfa su propia dirección
 IP.
 Por tanto, una dirección IP técnicamente está asociada con una interfaz,
 y no al equipo que tiene la interfaz.
\end_layout

\begin_layout Standard
\align left
Cada dirección IP tiene 32 bits, por lo que hay 
\begin_inset Formula $2^{32}$
\end_inset

 posibles direcciones IP.
 Estas direcciones normalmente se escriben en 
\series bold
notación decimal con puntos (dotted-decimal)
\series default
, en la que cada byte de la dirección se escribe en su forma decimal y se
 separa por un punto de los otros bytes de la dirección (e.g.
 192.32.217.9).
\end_layout

\begin_layout Standard
\align left
Cada interfaz en todo host y router en el Internet global debe tener una
 dirección IP que sea globalmente única (excepto para NATs).
 Estas direcciones no pueden ser elegidas al azar.
 Una porción de la dirección IP de la interfaz será determinada por la subred
 a la que está conectado.
\end_layout

\begin_layout Standard
\align left
Para determinar las subredes, desconecta cada interfaz de su host o router,
 creando islas de redes aisladas, con interfaces marcando el final de las
 redes aisladas.
 Cada una de estas redes aisladas se denomina 
\series bold
subred
\series default
.
\end_layout

\begin_layout Standard
\align left
Una organización con múltiples segmentos Ehternet y enlaces punto a punto
 tendrá varias subredes, con todos los dispositivos en una misma subred
 teniendo la misma dirección de subnet.
 En principio, diferentes subredes podrían tener bastante distinta dirección
 de subred.
 En la práctica las direcciones de subred suelen tener bastante en común.
\end_layout

\begin_layout Standard
\align left
La estrategia de asignación de direcciones en Internet se conoce como 
\series bold
Classless Interdomain Routing (CIDR)
\series default
 y generaliza la noción del direccionamiento de subredes.
 Como en estas, la dirección de 32 bits se divide en dos partes y ahora
 tiene la forma en decimal punteado 
\begin_inset Formula $a.b.c.d/x$
\end_inset

, donde 
\begin_inset Formula $x$
\end_inset

 indica los números de bits que son la primera parte de la dirección, que
 constituye la porción de red de la dirección IP, y se suele denominar 
\series bold
prefijo
\series default
.
\end_layout

\begin_layout Standard
\align left
A una organización normalmente se le asigna un bloque de direcciones contiguas
 (con prefijo común).
 
\end_layout

\begin_layout Standard
\align left
El prefijo es considerado por los routers fuera de la red de la organización.
\end_layout

\begin_layout Standard
\align left
Los restantes 
\begin_inset Formula $32-x$
\end_inset

 bits de la dirección pueden pensarse como un distintivo entre los dispositivos
 dentro de la organización, todos con el mismo prefijo.
 Estos son los bits que se considerarán cuando se reenvíen paquetes en los
 routers dentro de la organización.
\end_layout

\begin_layout Standard
\align left
Antes de CIDR, las porciones de una dirección IP estaban restringidas a
 ser los primeros 8,16 o 24 primeros bits.
 Este esquema de direccionamiento se conoce como 
\series bold
Classful Addressing
\series default
, y las clases se denominaban A, B o C, respectivamente.
\end_layout

\begin_layout Standard
\align left
Hay un tipo especial de dirección IP, la 
\series bold
dirección de broadcast 255.255.255.255
\series default
.
 Cuando un host envia un datagrama con esta dirección como destino, el mensaje
 se entregará a todos los hosts de la misma subnet.
 Opcionalmente los routers pueden derivar el mensaje a las subredes vecinas.
\end_layout

\begin_layout Subsection
Obteniendo un bloque de direcciones
\end_layout

\begin_layout Standard
Para obtener un bloque de direcciones IP para usar en una subred de una
 organización, un administrador de red debe contactar con su ISP, que le
 proporcionará direcciones de un bloque mayor de direcciones que ha sido
 asignado al ISP.
\end_layout

\begin_layout Subsection
Obteniendo una dirección de host: el DHCP (Dynamic Host Configuration Protocol)
\end_layout

\begin_layout Standard
\align left
Una vez que una organización ha obtenido un bloque de direcciones, puede
 asignar direcciones IP individuales a los hosts y las interfaces de los
 routers en su organización.
 Un administrador del sistema normalmente configurará manualmente las direccione
s IP en el router.
 
\end_layout

\begin_layout Standard
\align left
Las direcciones IP de los host pueden ser configuradas manualmente, pero
 lo más común es usar DHCP, que permite a un host obtener una dirección
 IP automáticamente.
 Un administrador de red puede configurar DHCP de forma que un determinado
 host reciba siempre la misma dirección IP cuando se conecta a la red, o
 un host puede ser asignado con una 
\series bold
dirección IP temporal
\series default
, que sera distinta cada vez que el host se conecte a la red.
 Además de la asignación de direcciones IP a los hosts, DHCP tabién permite
 a un host aprender información adicional, como la máscara de subred, la
 dirección de su router más cercano y la dirección de su servidor DNS local.
\end_layout

\begin_layout Standard
\align left
Suele decirse que es un 
\series bold
protocolo plug-and-play
\series default
.
\end_layout

\begin_layout Standard
\align left
DHCP es un protocolo cliente-servidor.
 El cliente normalmente es un nuevo host que quiere obtener la información
 de configuración de la red, incluyendo una dirección IP para sí.
 En el caso más simple, cada subred tedrá un servidor DHCP.
 Si no hay un servidor en la subred, habrá un 
\series bold
agente DHCP relay
\series default
, que conoce la dirección de un servidor DCHP.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/dhcprelay.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align left
El protocolo DHCP tiene cuatro pasos:
\end_layout

\begin_layout Enumerate
\align left

\series bold
DHCP server discovery:
\series default
 la primera tarea de un nuevo host es encontrar un servidor DHCP con el
 que itneractuar.
 Esto se hace usando un mensaje DHCP discover, que un cliente manda en un
 paquete UDP por el puerto 67.
 Este se encapsula en un datagrama IP.
 El host no conoce ni siquiera la dirección IP de la red en la que opera.
 El cliente crea un datagrama IP que contiene el mensaje DHCP discover y
 dirección de destino la dirección de broadcast y dirección de origen 0.0.0.0.
 El cliente DHCP pasa el datagrama IP a la capa de enlace, que entonces
 retransmite la trama a todos los nodos de la subred
\end_layout

\begin_layout Enumerate
\align left

\series bold
DHCP server offer(s):
\series default
 un servidor DHCP que recibe un mensaje DHCP discover responde al cliente
 con un mensaje DHCP offer que se retransmite a todos los nodos de la subred,
 usando de nuevo la dirección de broadcast.
 Como varios servidores DHCP pueden estar presentes en una subred, el cliente
 puede encontrarse en la posición de tener que elegir entre varias ofertas.
 Cada mensaje de oferta contendrá la ID de transacción del mensaje DHCP
 discover recibido, la dirección IP propuesta al cliente, la máscara de
 red, y el tiempo de préstamo de la dirección IP (lease time), o sea la
 cantidad de tiempo por la que esa dirección IP será válida.
\end_layout

\begin_layout Enumerate
\align left

\series bold
DCHP request:
\series default
 el nuevo cliente elegirá entre una o más ofertas de los servidores y responderá
 a la que elija con un mensaje DHCP request, devolviendo los parámetros
 de configuración.
\end_layout

\begin_layout Enumerate
\align left

\series bold
DHCP ACK:
\series default
 el servidor responde al mensaje DHCP request con un mensaje DHCP ACK, confirman
do los parámetros requeridos.
\end_layout

\begin_layout Standard
\align left
Otros mensajes DCHP son DHCP Release, enviado por el cliente para liberar
 su dirección DHCP; DHCP Nak, que indica que un préstamo ha expirado o que
 la solicitud del cliente no pudo ser llevada a cabo; y DHCP Inform, que
 es enviado por el cliente para solicitar más información de la que el servidor
 le ha enviado con el DHCP ACK.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/dhcp.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align left
Una vez que el cliente recibe el DHCP ACK, la interacción termina y el cliente
 puede utilizar la dirección IP asignada mediante DHCP durante el tiempo
 de préstamo.
 Para ello:
\end_layout

\begin_layout Itemize
\align left
Envía un DHCP Request solicitando la misma IP que ya posee
\end_layout

\begin_layout Itemize
\align left
Se se renueva el servidor envía un DHCP ACK
\end_layout

\begin_layout Itemize
\align left
Si no se puede renovar la IP, el servidor envía un DHCP Nak.
 En este caso se inicia de nuevo el proceso general.
\end_layout

\begin_layout Standard
\align left
DHCP también proporciona un mecanismo que permite al cliente renovar el
 préstamo de una dirección IP.
\end_layout

\begin_layout Standard
\align left
El valor de la característica plug-and-play queda claro considerando el
 hecho de que la alternativa es configurar manualmente la dirección IP de
 cada host (pensemos, por ejemplo, qué ocurriría en una biblioteca pública).
\end_layout

\begin_layout Standard
\align left
Desde el aspecto de la movilidad, sin embargo, DHCP tiene defectos.
 Como una nueva dirección IP es obtenida con DHCP cada vez que un nodo se
 conecta a una red, una conexión TCP a una aplicación remota no puede ser
 mantenida mientras un nodo móvil se desplaza entre redes.
\end_layout

\begin_layout Section
Protocolos de aplicación: File Transfer Protocol (FTP)
\end_layout

\begin_layout Standard
\align left
En una sesión FTP típica, el usuario quiere transferir ficheros a/desde
 un host desde/a un host remoto.
 Para que el usuario pueda acceder la cuenta remota, el usuario debe proporciona
r una identificación de usuario y una contraseña.
 Tras esto, el usuario puede transferir archivos desde el sistema de ficheros
 local al sistema remoto y viceversa.
\end_layout

\begin_layout Standard
\align left
El usuario interactúa con FTP a través de un 
\series bold
FTP user agente
\series default
.
 El usuario primero proporciona el hostname del host remoto, haciendo que
 el proceso cliente FTP en el host local establezca una conexión TCP con
 el proceso servidor FTP en el host remoto.
 El usuario entonces proporciona el ID de usuario y la contraseña, qu se
 envían sobre una conexión TCP como parte de comandos FTP.
 Una vez el servidor ha autorizado al usuario, el usuario copia uno o más
 archivos almacenados en el sistema de ficheros local al remoto.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/ftp.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
\align left
HTTP y FTP son ambos protocolos de transferencia y tienen muchas características
 en común.
 Sin embargo, los dos protocolos del nivel de aplicación tienen importantes
 diferencias.
 La más importante es que FTP usa dos conexiones TCP paralelas para transmitir
 un fichero.
 La 
\series bold
conexión de control
\series default
 se usa para mandar información de control entre los dos hosts.
 La 
\series bold
conexión de datos
\series default
 se usa para enviar los ficheros.
\end_layout

\begin_layout Standard
\align left
Por este motivo, se dice que FTP envía la información de control 
\series bold
out-of-band (fuera de banda)
\series default
.
 HTTP se dice que envía la información de control 
\series bold
in-band
\series default
.
\end_layout

\begin_layout Standard
\align left
Cuando un usuario comienza una sesión FTP con un host remoto, la parte cliente
 de FTP primero inicia una conexión TCP de control con la parte servidor
 en el puerto 21 del servidor.
 La parte cliente de FTP envía ID+contraseña por esta conexión de control.
 La parte cliente de FTP envía también comandos para cambiar el directorio
 remoto.
 Cuando la parte del servidor recibe un comando requiriendo una transferencia
 de un archivo el servidor inicia una conexión TCP de datos con la parte
 del cliente.
 Si, durante la misma sesión, el usuario quiere transferir otro fichero,
 FTP abrirá otra conexión de datos.
 Por tanto, la conexión de control permanece abierta durante la duración
 de la sesión completa, pero las conexiones de datos se crean para cada
 fichero transferido en una sesión.
\end_layout

\begin_layout Standard
\align left
A lo largo de una sesión, el servidor FTP debe mantener el estado del usuario.
 Debe asociar la conexión de control con una cuenta de usuario específica,
 y debe hacer un seguimiento del directorio actual del usuario mientras
 el usuario se mueve por el árbol de directorios remoto.
\end_layout

\begin_layout Subsection
FTP: modos de operación
\end_layout

\begin_layout Subsubsection
Modo activo
\end_layout

\begin_layout Enumerate
El cliente inicia la conexión usando
\begin_inset Formula 
\[
IPOrigen=cliente,\ PuertoOrigen=x
\]

\end_inset


\begin_inset Formula 
\[
IPDestino=servidor,\ PuertoDestino=21
\]

\end_inset


\end_layout

\begin_layout Enumerate
El cliente envía el comando PORT, indicando el número de puerto en el cliente
 que debe usar el servidor para el envío de datos (
\begin_inset Formula $Y$
\end_inset

)
\end_layout

\begin_layout Enumerate
El servidor crea nueva conexión TCP usando:
\begin_inset Formula 
\[
IPOrigen=servidor,\ PuertoOrigen=20
\]

\end_inset


\begin_inset Formula 
\[
IPDestino=cliente,\ PuertoDestino=Y
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Modo pasivo
\end_layout

\begin_layout Enumerate
(Igual) El cliente inicia la conexión usando
\begin_inset Formula 
\[
IPOrigen=cliente,\ PuertoOrigen=x
\]

\end_inset


\begin_inset Formula 
\[
IPDestino=servidor,\ PuertoDestino=21
\]

\end_inset


\end_layout

\begin_layout Enumerate
El cliente envía el comando PASV para activar el modo pasivo, el servidor
 devuelve un número de puerto libre (
\begin_inset Formula $Z$
\end_inset

)
\end_layout

\begin_layout Enumerate
El cliente crea nueva conexión TCP usando:
\begin_inset Formula 
\[
IPOrigen=cliente,\ PuertoOrigen=Y
\]

\end_inset


\begin_inset Formula 
\[
IPDestino=servidor,\ PuertoDestino=Z
\]

\end_inset


\end_layout

\begin_layout Subsection
Comandos y respuestas FTP
\end_layout

\begin_layout Standard
Los comandos, del cliente al servidor, y las respuestas, del servidor al
 cliente, se envían a través de la conexión de control en formato ASCII
 de 7 bits.
 Así, como los comandos HTTP, son entendibles por los humanos.
 Un retorno de carro y un line feed terminan cada comando.
\end_layout

\begin_layout Itemize

\series bold
USER username:
\series default
 usado para enviar la identificación del usuario al servidor
\end_layout

\begin_layout Itemize

\series bold
PASS password:
\series default
 usado para enviar la contraseña al servidor
\end_layout

\begin_layout Itemize

\series bold
LIST:
\series default
 usado para pedir al servidor que envíe una lista de todos los ficheros
 del directorio remoto actual.
 La lista de ficheros se envñia sobre una conexión de datos nueva
\end_layout

\begin_layout Itemize

\series bold
RETR filename:
\series default
 usado para transferir un fichero desde el directorio remoto actual
\end_layout

\begin_layout Itemize

\series bold
STOR filename:
\series default
 usado para almacenar un fichero en el directorio remoto actual
\end_layout

\begin_layout Standard
Normalmente hay una correspondencia uno-a-uno entre los comandos del usuario
 y los comandos FTP enviados a lo largo de la conexión de control.
 Cada comando va seguido de una respuesta, enviada desde el servidor al
 cliente.
 Las respuestas son números de tres dígitos, con un mensaje opcional a continuac
ión.
\end_layout

\begin_layout Itemize

\series bold
331 Username OK, password required
\end_layout

\begin_layout Itemize

\series bold
125 Data connection already open; transfer starting
\end_layout

\begin_layout Itemize

\series bold
425 Can't open data connection
\end_layout

\begin_layout Itemize

\series bold
452 Error writing file
\end_layout

\begin_layout Section
Introducción a la seguridad en redes
\end_layout

\begin_layout Subsection
¿Qué es la seguridad en redes?
\end_layout

\begin_layout Standard
\align left
Cuando Alicia envía un mensaje a Bob, es probable que quiere que Bob sea
 el único que pueda leer el mensaje que ella le envía, aunque se estén comunican
do sobre un medio inseguro, en el que un intruso, al que vamos a llamar
 Truso, podría interceptar el mensaje.
 Bob también querrá estar seguro de que lo que recibe efectivamente lo ha
 enviado Alicia, así como Alicia quiere asegurarse de que se está comunicando
 con Bob.
 Alicia y Bob también quieren asegurarse de que el contenido de los mensajes
 no se ha alterado en el camino.
 Así, podemos identificar las siguientes propiedades deseables en una 
\series bold
comunicación segura
\series default
:
\end_layout

\begin_layout Itemize
\align left

\series bold
Confidencialidad: 
\series default
solo el emisor y el receptor requerido deben ser capaces de entender el
 contenido del mensaje transmitido.
 Como un espía puede interceptar el mensaje, esto requiere que el mensaje,
 de alguna forma, sea 
\series bold
encriptado
\series default
 de forma que un mensaje interceptado no pueda ser entendido por el interceptor.
\end_layout

\begin_layout Itemize
\align left

\series bold
Integridad:
\series default
 Alicia y Bob quiere asegurarse de que el contenido de su comunicación no
 se altera en tránsito.
\end_layout

\begin_layout Itemize
\align left

\series bold
Autenticación end-point:
\series default
 el emisor y el receptor deben ser capaces de confirmar la identidad del
 otro.
\end_layout

\begin_layout Itemize
\align left

\series bold
Seguridad operacional:
\series default
 casi todas las organizaciones tienen redes y están conectadas a Internet.
 Estas redes, potencialmente, pueden quedar comprometidas.
 Los atacantes pueden intentar depositar worms en los hosts de la red, obtener
 secretos corporativos,...
\end_layout

\begin_layout Standard
\align left
Por otro lado, in intruso podría:
\end_layout

\begin_layout Itemize
\align left

\series bold
Espiar (eavesdrop)
\end_layout

\begin_layout Itemize
\align left

\series bold
Modificar, insertar o eliminar mensajes o parte de estos
\end_layout

\begin_layout Standard
\align left
Mientras no se tomen las contramedidas apropiadas, estas capacidades habilitan
 a un intruso para llevar a cabo una gran variedad de ataques a la seguridad:
 
\series bold
fisgonear
\series default
 la comunicación, 
\series bold
impersonar
\series default
 a una entidad, 
\series bold
secuestrar
\series default
 una sesión de comunicación, 
\series bold
denegar el servicio
\series default
 a una red legítima de usuarios sobrecargando el sistema,...
\end_layout

\begin_layout Standard
\align left
La utilidad de la criptografía para proporcionar confidencialidad es evidente,
 pero también es central en proporcionar autenticación end-point e integridad
 en los mensajes.
\end_layout

\begin_layout Subsection
Principios de la criptografía
\end_layout

\begin_layout Standard
Las técnicas crptográficas permiten a un emisor disfrazar los datos, de
 forma que un intruso no pueda obtener información de ellos aunque los intercept
e.
 El receptor debe ser capaz de recuperar los datos originales desde los
 datos camuflados.
\end_layout

\begin_layout Standard
El mensaje de Alicia en su forma original se conoce como 
\series bold
plaintext (texto plano)
\series default
.
 Alicia encripta su mensaje en texto plano usando un 
\series bold
algoritmo de encriptación
\series default
 de forma que el mensaje encriptado, llamado 
\series bold
ciphertext (tecto cifrado)
\series default
, sea ininteligible para cualquier intruso.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/cyphertext.png

\end_inset


\end_layout

\begin_layout Standard
Si todos saben el método para encriptar los datos, entonces debe haber alguna
 información secreta que prevenga a un intruso de desencriptar los datos
 transmitidos.
 Aquí es donde entran las keys.
\end_layout

\begin_layout Standard
En la figura anterior, Alicia proporciona una 
\series bold
clave (key)
\series default
, 
\begin_inset Formula $K_{A}$
\end_inset

, que no es más que una cadena de números o caracteres, al algoritmo de
 encriptación.
 Este toma la key y el mensaje en texto plano, 
\begin_inset Formula $m$
\end_inset

, como input y produce como output el texto cifrado, 
\begin_inset Formula $K_{A}\left(m\right)$
\end_inset

.
 De forma similar, Bob proporcionará una key, 
\begin_inset Formula $K_{B}$
\end_inset

, al 
\series bold
algoritmo de decriptación
\series default
, que toma el texto cifrado y la key de Bob como input y produce el texto
 plano original como output.
 Es decir, 
\begin_inset Formula $K_{B}$
\end_inset

 es tal que 
\begin_inset Formula $K_{B}\left(K_{A}\left(m\right)\right)=m$
\end_inset

.
\end_layout

\begin_layout Standard
En los 
\series bold
sistemas de clave simétrica
\series default
, las keys de Alicia y Bob son idénticas y secretas.
\end_layout

\begin_layout Standard
En los 
\series bold
sistemas de clave pública
\series default
, se usa un par de keys.
 Una de ellas es conocida tanto por Alicia como por Bob.
 La otra solo es conocida por uno de ellos.
\end_layout

\begin_layout Subsubsection
Criptografía de clave simétrica
\end_layout

\begin_layout Subsubsection*
Cifrado César
\end_layout

\begin_layout Standard
Toma cada letra del abecedario en el texto plano y la sustituye por una
 letra que está 
\begin_inset Formula $k$
\end_inset

 letras después en el alfabeto.
 La clave es el valor de 
\begin_inset Formula $k$
\end_inset

.
 Nótese que no llevaría mucho tiempo descifrar el código, ya que solo hay
 tantas claves posibles como letras tiene el abecedario.
\end_layout

\begin_layout Subsubsection*
Cifrado monoalfabético
\end_layout

\begin_layout Standard
Es una mejora del cifrado César.
 También sustituye una letra del alfabeto por otra.
 Sin embargo, ahora no se desplazan todas las letras una distancia 
\begin_inset Formula $k$
\end_inset

, sino que cualquier letra puede ser sustituida por cualquier otra, siempre
 y cuando dos letras distintas no se sustituyan por la misma y una misma
 letra siempre se sustituya por la misma letra.
 Como se puede observar, esto son las permutaciones de las letras del alfabeto,
 por lo que habrá 
\begin_inset Formula $26!$
\end_inset

 posibilidades para la clave (en alfabeto inglés).
 Por fuerza bruta es infactible probar todas las combinaciones.
 Pero hay técnicas estadísticas y conocimientos lingüísticos que pueden
 facilitar mucho la decodificación del mensaje.
\end_layout

\begin_layout Standard
Cuando consideramos cómo de fácil sería para Truso romper el esquema de
 codificación de Alicia y Bob, podemos distinguir 3 escenarios, dependiendo
 de la información que posee Truso:
\end_layout

\begin_layout Itemize

\series bold
Ataque solo al texto cifrado:
\series default
 el intruso podría tener acceso solo al texto cifrado interceptado, sin
 información sobre le contenido del mensaje original
\end_layout

\begin_layout Itemize

\series bold
Ataque conociendo el texto plano:
\series default
 cuando un intruso conoce algunos de los emparejameintos 
\begin_inset Formula $(plaintext,\ ciphertext)$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Ataque con texto plano seleccionado:
\series default
 el intruso puede elegir el texto plano y obtener el correspondiente texto
 cifrado
\end_layout

\begin_layout Subsubsection*
Cifrado polialfabético
\end_layout

\begin_layout Standard
La idea es usar varios cifrados monoalfabéticos, con un cifrado monoalfabñetico
 específico para codificar una letra en una determinada posición del mensaje
 en texto plano.
 Así, la misma letra, en distintas posiciones del mensaje en texto plano,
 podría estar codificada de forma distinta.
\end_layout

\begin_layout Subsubsection*
Cifrado de Flujo
\end_layout

\begin_layout Standard
\align left
Se utiliza una clave con el mismo número de bits que el mensaje a cifrar.
 Se utiliza un generador de números pseudo-aleatorios (PRNG) para generar
 la clave.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/cifradoflujo.png
	scale 60

\end_inset


\end_layout

\begin_layout Subsubsection*
Cifrado de Bloque
\end_layout

\begin_layout Standard
\align left
El mensaje a encriptar se procesa en bloques de 
\begin_inset Formula $k$
\end_inset

 bits.
 Para codificar un bloque, el cifrador usa una asociación uno-a-uno para
 asociar el bloque de 
\begin_inset Formula $k$
\end_inset

-bits de plaintext con un bloque de 
\begin_inset Formula $k$
\end_inset

-bits de ciphertext.
\end_layout

\begin_layout Standard
\align left
Podemos ver cada una de estas asociaciones como una clave.
 
\end_layout

\begin_layout Standard
\align left
El ataque por fuerza bruta para este cifrado es intentar desencriptar el
 ciphertext usando todas las asociaciones.
 Pero nótese que el número de posibles asociaciones para un 
\begin_inset Formula $k$
\end_inset

-bloque en general es 
\begin_inset Formula $2^{k}!$
\end_inset


\end_layout

\begin_layout Standard
\align left
Aunque cifrados de bloque que usan una tabla de asociaciones, para valores
 moderados de 
\begin_inset Formula $k$
\end_inset

 pueden producir esquemas de encriptación de clave simétrica muy robustos,
 son difíciles de implementar.
 Para 
\begin_inset Formula $k=64$
\end_inset

 y una asociación dada, Alicia y Bob deberían mantener una tabla con 
\begin_inset Formula $2^{64}$
\end_inset

 valores de entrada, lo que es una tarea infactible.
 Además, si Alicia y Bob quisieran intercambiar claves, deberían, cada uno,
 regenerar la tabla.
\end_layout

\begin_layout Standard
\align left
En su lugar, los cifrados de bloque normalmente usan funciones que simulan
 tablas permutadas de forma aleatoria.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/cifradobloque.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align left
Los cifrados de bloque más populares son:
\end_layout

\begin_layout Itemize
\align left

\series bold
DES (Data Encryption Standard): 
\series default
es el estándar de cifrado US encryption standard.
 Usa clave simétrica de 56-bits, con entrada plaintext de 64-bits.
 Es un cifrado de bloque con cipher block chaining.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/des.png
	scale 70

\end_inset


\end_layout

\begin_layout Standard
\align left
Una frase cifrada con una clave de 56 bits se descifra en menos de un día.
 Pero no se le concoe un buen ataque analítico.
\end_layout

\end_deeper
\begin_layout Itemize
\align left

\series bold
DES3:
\series default
 surge para hacer DES más seguro.
 Consiste en cifrar 3 veces con 3 claves distintas:
\begin_inset Formula 
\[
E_{K3}\left(D_{K2}\left(E_{K1}\left(m\right)\right)\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
\align left

\series bold
AES (Advanced Encryption Standard):
\series default
 sustituye a DES como estándar.
 Procesa los datos en bloques de 128 bits.
 Puede trabajar con claves de 128, 192 y 256 bits.
 Una máquina que pudiera descifrar DES en un segundo, tardaría 149 billones
 de años en descifrar AES.
\end_layout

\begin_layout Subsubsection*
Cipher Block Chaining
\end_layout

\begin_layout Standard
\align left
Si aplicamos cifrado de bloque como hemos visto, simplemente cortando el
 mensaje en trozos de 
\begin_inset Formula $k$
\end_inset

-bits y encriptando cada bloque independientemente, un problema sutil pero
 importante ocurre.
 Observemos que dos o más bloques del texto pueden ser idénticos.
 Para estos bloques idénticos, el cifrado en bloque produciría el mismo
 ciphertext.
 Un atacante podría potencialmente adivinar el plaintext cuando ve bloques
 de ciphertext idénticos y podría conseguir desencriptar el mensaje indentifican
do estos bloques y usando conocimiento específico de la estructura del protocolo.
\end_layout

\begin_layout Standard
\align left
Para solucionar este problema, podemos añadir un poco de aleatoriedad al
 ciphertext de forma que bloques de plaintext idénticos produzcan bloques
 de ciphertext distintos.
\end_layout

\begin_layout Standard
\align left
Sea 
\begin_inset Formula $m\left(i\right)$
\end_inset

 el bloque 
\begin_inset Formula $i$
\end_inset

 del plaintext, 
\begin_inset Formula $c\left(i\right)$
\end_inset

 el bloque 
\begin_inset Formula $i$
\end_inset

 del ciphertext, y 
\begin_inset Formula $a\varoplus b$
\end_inset

 la operación XOR entre dos cadenas 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

.
 Denotemos, también, el algoritmo de encriptación de cifrado en bloque con
 clave 
\begin_inset Formula $S$
\end_inset

 como 
\begin_inset Formula $K_{S}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\align left
La idea básica es la siguiente:
\end_layout

\begin_layout Enumerate
\align left
El emisor crea un número de 
\begin_inset Formula $k$
\end_inset

-bits aleatorio 
\begin_inset Formula $r\left(i\right)$
\end_inset

 para el bloque 
\begin_inset Formula $i$
\end_inset

 y calcula 
\begin_inset Formula $c\left(i\right)=K_{S}\left(m\left(i\right)\varoplus r\left(i\right)\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
El emisor entonces envía 
\begin_inset Formula $c\left(1\right),r\left(1\right),c\left(2\right),r\left(2\right),...$
\end_inset

 Como el receptor recibe 
\begin_inset Formula $c\left(i\right),r\left(i\right)$
\end_inset

 entonces puede recuperar clada bloque del plaintext calculando 
\begin_inset Formula $m\left(i\right)=K_{S}\left(c\left(i\right)\right)\varoplus r\left(i\right)$
\end_inset


\end_layout

\begin_layout Standard
\align left
Aunque 
\begin_inset Formula $r\left(i\right)$
\end_inset

 es enviado en claro y puede ser atrapado por Truso, no puede obtener el
 plaintext 
\begin_inset Formula $m\left(i\right)$
\end_inset

 porque no conoce la clave 
\begin_inset Formula $K_{S}$
\end_inset

.
 
\end_layout

\begin_layout Standard
\align left
Pero introducir esta aleatoriedad soluciona un problema, pero añade uno
 nuevo: ahora Alicia debe transmitir el doble de bits que antes.
 Aquí entra la técnica llamada 
\series bold
Cipher Block Chaining (CBC)
\series default
.
 La idea es enviar solo un valor random con el primer mensaje, y después
 usar los bloques anteriormente calculados en lugar de un nuevo número aleatorio.
 Queda, entonces:
\end_layout

\begin_layout Enumerate
\align left
Antes de encriptar el mensaje, el emisor genera una cadena random de 
\begin_inset Formula $k-$
\end_inset

bits, llamada 
\series bold
Vector de Inicialización (IV)
\series default
.
 A este lo denotamos 
\begin_inset Formula $c\left(0\right)$
\end_inset

.
 El emisor envía al receptor el IV en texto plano.
\end_layout

\begin_layout Enumerate
\align left
Para el primer bloque, el emisor calcula 
\begin_inset Formula $c\left(1\right)=K_{S}\left(m\left(1\right)\varoplus c\left(0\right)\right)$
\end_inset

 y envía 
\begin_inset Formula $c\left(1\right)$
\end_inset

 al receptor.
\end_layout

\begin_layout Enumerate
\align left
Para el 
\begin_inset Formula $i$
\end_inset

-ésimo bloque, el emisor genera el 
\begin_inset Formula $i$
\end_inset

-ésimo bloque de ciphertext haciendo 
\begin_inset Formula 
\[
c\left(i\right)=K_{S}\left(m\left(i\right)\varoplus c\left(i-1\right)\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\align left
Esta técnica tiene las siguientes consecuencias:
\end_layout

\begin_layout Itemize
\align left
El receptor debe seguir siendo capaz de obtener el mensaje original.
 Y efectivamente es así, porque cuando recibe 
\begin_inset Formula $c\left(i\right)$
\end_inset

, ya ha calculado 
\begin_inset Formula $c\left(i-1\right)$
\end_inset

, por lo que solo tiene que hacer 
\begin_inset Formula $m\left(i\right)=K_{S}\left(c\left(i\right)\right)\varoplus c\left(i-1\right)$
\end_inset


\end_layout

\begin_layout Itemize
\align left
Si dos bloques de plaintext son idénticos, es casi seguro que sus correspondient
es bloques de ciphertext no lo serán
\end_layout

\begin_layout Itemize
\align left
Aunque el emisor envía el IV en claro, el intruso no conoce la clave secreta
\end_layout

\begin_layout Itemize
\align left
El emisor solo envía un mensaje adicional a los bloques, el IV, por lo que
 el ancho de banda necesario para la comunicación no aumenta
\end_layout

\begin_layout Subsubsection
Encriptación de Clave Pública
\end_layout

\begin_layout Standard
\align left
La comunicación encriptada con clave simétrica requiere que las dos partes
 en comunicación compartan un secreto común.
 Una dificultad de este enfoque es que las dos partes deben, de alguna forma,
 ponerse de acuerdo en la clave compartida, pero esto tambiénr equiere comunicac
ión segura.
 Quizás las partes podrían reunirse primero y hacer este acuerdo en persona,
 y tras esto comunicarse con encriptación.
 En un mundo en red, sin embargo, las partes en comunicación puede que nunca
 se reunan y que nunca conversen aparte de sobre la red.
\end_layout

\begin_layout Standard
\align left
Ahora, Alicia y Bob, en lugar de compartir una clave secreta compartida,
 tienen dos claves cada uno.
\end_layout

\begin_layout Standard
\align left
Una 
\series bold
clave pública
\series default
 ,
\begin_inset Formula $K_{B}^{+}$
\end_inset

, que está disponible para cualquiera y una 
\series bold
clave privada
\series default
 ,
\begin_inset Formula $K_{B}^{-}$
\end_inset

, que solo la conoce el poseedor.
 La 
\begin_inset Formula $B$
\end_inset

 es porque estamos suponiendo que es la de Bob.
\end_layout

\begin_layout Standard
\align left
Para comunicarse con Bob, Alicia busca la clave pública de Bob y encripta
 el mensaje, 
\begin_inset Formula $m$
\end_inset

, con esta clave y un algoritmo de encriptación conocido, o sea, Alicia
 calcula 
\begin_inset Formula $K_{B}^{+}\left(m\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Bob recibe el mensaje encriptado y calcula 
\begin_inset Formula $K_{B}^{-}\left(K_{B}^{+}\left(m\right)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Hay algoritmos de encriptación y desencriptación para elegir las claves
 públicas y privadas de tal forma que se obtenga 
\begin_inset Formula $K_{B}^{-}\left(K_{B}^{+}\left(m\right)\right)=K_{B}^{+}\left(K_{B}^{-}\left(m\right)\right)=m$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Una 
\series bold
primera consideración
\series default
 es que aunque un intruso que intercepta el mensaje de Alicia no puede entenderl
o, el intruso conoce tanto la clave (la pública de Bob), como el algoritmo
 de encriptación.
 Truso puede entonces montar un ataque de plaintext seleccionado, usando
 los algoritmos de encriptación estandarizados y la clave pública de Bob
 para codificar cualqueir mensaje que quiera.
 Entonces podría codificar mensajes o partes de mensajes que sospeche que
 Alicia podría enviar a Bob.
 Por tanto, para que la criptografía de clave pública funcione, la elección
 de claves debe ser hecha de forma que sea imposible para un intruso determinar
 la clave privada de Bob o desencriptar el mensaje de Alicia para Bob.
\end_layout

\begin_layout Standard
\align left
Una 
\series bold
segunda consideración
\series default
 es que como la clave de encriptación de Bob es pública, cualquiera puede
 enviar un mensaje a Bob, incluyendo alguien que se hace pasar por Alicia.
 En el caso de una única clave secreta compartida, el hecho de que el emisor
 conoce la clave secreta implícitamente lo identifica.
 En el caso de la criptorgrafía con clave pública, sin embargo, esto no
 funciona.
 Una firma digital es necesario para asociar un emisor a un mensaje.
\end_layout

\begin_layout Subsubsection*
RSA
\end_layout

\begin_layout Standard
\align left
Hace uso de la aritmética modular.
 Se verifican las propiedades:
\begin_inset Formula 
\[
\left[a\mod n+b\mod n\right]\mod n=\left(a+b\right)\mod n
\]

\end_inset


\begin_inset Formula 
\[
\left[a\mod n-b\mod n\right]\mod n=\left(a-b\right)\mod n
\]

\end_inset


\begin_inset Formula 
\[
\left[a\mod n\cdot b\mod n\right]\mod n=\left(a\cdot b\right)\mod n
\]

\end_inset


\begin_inset Formula 
\[
\left(a\mod n\right)^{k}\mod n=a^{k}\mod n
\]

\end_inset

 Como un mensaje no es más que un patrón de bits, todo mensaje puede ser
 representado por un número entero.
\end_layout

\begin_layout Standard
\align left
Entonces, encriptar un mensaje con RSA es equivalente a encriptar el único
 entero que representa el mensaje.
 
\end_layout

\begin_layout Standard
\align left
Hay dos componentes interrelacionados de RSA:
\end_layout

\begin_layout Itemize
\align left
La elección de las claves públicas y privadas
\end_layout

\begin_layout Itemize
\align left
El algoritmo de encriptación y desencriptación
\end_layout

\begin_layout Standard
\align left
Para 
\series bold
generar las claves públicas y privadas RSA
\series default
, Bob hace los siguientes pasos:
\end_layout

\begin_layout Enumerate
\align left
Elige dos primos grandes, 
\begin_inset Formula $p,q$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
Calcula 
\begin_inset Formula $n=pq$
\end_inset

 y 
\begin_inset Formula $z=\left(p-1\right)\left(q-1\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
Elige un número, 
\begin_inset Formula $e<n$
\end_inset

, coprimo con 
\begin_inset Formula $z$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
\align left
Encuentra un número, 
\begin_inset Formula $d$
\end_inset

, tal que 
\begin_inset Formula $ed-1$
\end_inset

 es múltiplo de 
\begin_inset Formula $z$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
La clave pública de Bob es el par 
\begin_inset Formula $\left(n,e\right)$
\end_inset

 y la clave privada es 
\begin_inset Formula $\left(n,d\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
El proceso de encriptación por Alicia y desencriptación por Bob es como
 sigue:
\end_layout

\begin_layout Standard
\align left
Supongamos que Alicia quiere enviar el mensaje que, expresado como número,
 es 
\begin_inset Formula $m<n$
\end_inset

.
 Para obtener el mensaje codificado, hace
\begin_inset Formula 
\[
c=m^{e}\mod n
\]

\end_inset


\end_layout

\begin_layout Standard
\align left
Y envía el mensaje codificado, 
\begin_inset Formula $c$
\end_inset

, a Bob.
\end_layout

\begin_layout Standard
\align left
Para desencriptar el mensaje, Bob calcula
\begin_inset Formula 
\[
m=c^{d}\mod n
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
¿Por qué funciona RSA?
\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $p,q$
\end_inset

 son primos, 
\begin_inset Formula $n=pq$
\end_inset

 y 
\begin_inset Formula $z=\left(p-1\right)\left(q-1\right)$
\end_inset

 entonces 
\begin_inset Formula 
\[
x^{y}\mod n=x^{\left(y\mod z\right)}\mod n
\]

\end_inset

 Y, por tanto
\begin_inset Formula 
\[
c^{d}\mod n=\left(m^{e}\mod n\right)^{d}\mod n=m^{ed}\mod n\overset{ed\mod z=1}{=}m
\]

\end_inset

 La seguridad de RSA se apoya en el hecho de que no hay algoritmos conocidos
 para factorizar rápidamente un número.
 En nuestro caso el número es 
\begin_inset Formula $n$
\end_inset

 y sus factores 
\begin_inset Formula $p$
\end_inset

 y 
\begin_inset Formula $q$
\end_inset

.
 Si alguien conociera 
\begin_inset Formula $p,q$
\end_inset

 entonces dada la clave pública uno poría encontrar fácilmente la clave
 privada.
 Aunque, dado que no hay conocimiento sobre si tal algoritmo de factorización
 puede existir o no, la seguridad de RSA no puede estar totalmente garantizada.
\end_layout

\begin_layout Subsubsection*
Claves de sesión
\end_layout

\begin_layout Standard
La exponenciación que hay que realizar en RSA es un proceso que consume
 mucho tiempo.
 DES es al menos 100 veces más rápido en software y entre 1000-10000 veces
 más rápido en hardware.
 
\end_layout

\begin_layout Standard
RSA es normalmente usado en combinación con criptografía de clave simétrica.
 Si Alicia quiere enviar a Bob una gran cantidad de datos encriptados, ella
 podría hacer lo siguiente:
\end_layout

\begin_layout Enumerate
Alicia elige una clave que usará para codificar los datos.
 Esta clave se conoce como 
\series bold
clave de sesión
\series default
, 
\begin_inset Formula $K_{S}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Alicia debe informar a Bob de la clave de sesión, que será una clave simétrica
 compartida.
 Por lo que encripta la clave usando la clave pública de Bob.
\end_layout

\begin_layout Enumerate
Bob recibe la clave de sesión encriptada y la desencripta usando su clave
 privada.
\end_layout

\begin_layout Enumerate
Ahora Bob también tiene la clave de sesión compartida, transmitida de forma
 segura y la comunicación puede comenzar usando la clave simétrica.
\end_layout

\begin_layout Standard
\align left
Diffie y Hellman (el de la mayonesa no, otro) crearon un algoritmo que soluciona
 esta limitación.
\end_layout

\begin_layout Subsubsection*
Intercambio de Claves Diffie-Hellman
\end_layout

\begin_layout Standard
\align left
El propósito del algoritmo es permitir a dos usuarios intercambiar de forma
 segura una clave que pueda después ser usada para encriptación simétrica
 de los mensajes.
 El algoritmo se limita al intercambio de valores secretos compartidos.
\end_layout

\begin_layout Standard
\align left
El algoritmo es efectivo por la dificultad de calcular logaritmos discretos.
\end_layout

\begin_layout Standard
\align left
Se denomina 
\series bold
raíz primitiva
\series default
 de un primo 
\begin_inset Formula $p$
\end_inset

 es un número cuyas potencias módulo 
\begin_inset Formula $p$
\end_inset

 generan todos los enteros desde 1 hasta 
\begin_inset Formula $p-1$
\end_inset

.
 O sea, si 
\begin_inset Formula $a$
\end_inset

 es raíz primitiva de 
\begin_inset Formula $p$
\end_inset

, entonces
\begin_inset Formula 
\[
a\mod p,\ a^{2}\mod p,...,a^{p-1}\mod p
\]

\end_inset

 don distintos y son los enteros del 1 al 
\begin_inset Formula $p-1$
\end_inset

 en alguna permutación.
\end_layout

\begin_layout Standard
\align left
Para cualquier entero 
\begin_inset Formula $b$
\end_inset

 y una raíz primitiva 
\begin_inset Formula $a$
\end_inset

 de un primo 
\begin_inset Formula $p$
\end_inset

, podemos definir un único exponente 
\begin_inset Formula $i$
\end_inset

 tal que
\begin_inset Formula 
\[
b\equiv a^{i}\mod p
\]

\end_inset

 El exponente 
\begin_inset Formula $i$
\end_inset

 es el 
\series bold
logaritmo discreto 
\series default
de 
\begin_inset Formula $b$
\end_inset

 con base 
\begin_inset Formula $a$
\end_inset

 módulo 
\begin_inset Formula $p$
\end_inset

, o sea 
\begin_inset Formula $i=dlog_{a,p}\left(b\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\align left

\series bold
El algoritmo
\end_layout

\begin_layout Standard
\align left
Hay dos números conocidos públicamente: un primo 
\begin_inset Formula $q$
\end_inset

 y un entero 
\begin_inset Formula $a$
\end_inset

 que es raíz primitiva de 
\begin_inset Formula $q$
\end_inset

.
 Supongamos que Alicia y Bob quieren crear un secreto compartido.
\end_layout

\begin_layout Standard
\align left
Alicia escoge un entero aleatorio 
\begin_inset Formula $X_{A}<q$
\end_inset

 y calcula 
\begin_inset Formula $Y_{A}=a^{X_{A}}\mod q$
\end_inset

 y Bob hace lo propio 
\begin_inset Formula $X_{B}<q$
\end_inset

 y 
\begin_inset Formula $Y_{B}=a^{X_{B}}\mod q$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Cada parte guarda el valor de 
\begin_inset Formula $X$
\end_inset

 y hace el valor de 
\begin_inset Formula $Y$
\end_inset

 público.
 Así, 
\begin_inset Formula $X_{A}$
\end_inset

 es la clave privada de Alicia y 
\begin_inset Formula $Y_{A}$
\end_inset

 su clave pública, y de forma similar con Bob.
\end_layout

\begin_layout Standard
\align left
Alicia entonces calcula el secreto como 
\begin_inset Formula $K=\left(Y_{B}\right)^{X_{A}}\mod q$
\end_inset

 y Bob hace lo propio 
\begin_inset Formula $K=\left(Y_{A}\right)^{X_{B}}$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Estas dos claves resultan ser iguales:
\begin_inset Formula 
\[
K=\left(Y_{B}\right)^{X_{A}}\mod q=\left(a^{X_{B}}\mod q\right)^{X_{A}}\mod q=a^{X_{B}X_{A}}\mod q=\left(a^{X_{A}}\mod q\right)^{X_{B}}\mod q=\left(Y_{A}\right)^{X_{B}}\mod q
\]

\end_inset

 Este sereto compartido se puede usar como clave secreta simétrica compartida.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/diffiehell.png
	scale 60

\end_inset


\end_layout

\begin_layout Standard
\align left

\series bold
Ataque Man in the Middle
\end_layout

\begin_layout Standard
\align left
Supongamos que Alicia y Bob quieren intercambiar las claves y Truso quiere
 infiltrarse.
 El ataque procede así:
\end_layout

\begin_layout Enumerate
\align left
Truso se prepara generando dos claves privadas aleatorias 
\begin_inset Formula $X_{T1}$
\end_inset

 y 
\begin_inset Formula $X_{T2}$
\end_inset

 y calcula 
\begin_inset Formula $Y_{T1}$
\end_inset

 e 
\begin_inset Formula $Y_{T2}$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
Alicia transmite 
\begin_inset Formula $Y_{A}$
\end_inset

 a Bob
\end_layout

\begin_layout Enumerate
\align left
Truso intercepta 
\begin_inset Formula $Y_{A}$
\end_inset

 y transmite a Bob 
\begin_inset Formula $Y_{D1}$
\end_inset

.
 Truso calcula 
\begin_inset Formula $K2=\left(Y_{A}\right)^{X_{T2}}\mod q$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
Bob recibe 
\begin_inset Formula $Y_{D1}$
\end_inset

 y calcula 
\begin_inset Formula $K1=\left(Y_{D1}\right)^{X_{B}}\mod q$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
Bob transmite 
\begin_inset Formula $Y_{B}$
\end_inset

 a Alicia
\end_layout

\begin_layout Enumerate
\align left
Truso intercepta 
\begin_inset Formula $Y_{B}$
\end_inset

 y trnasmite 
\begin_inset Formula $Y_{D2}$
\end_inset

 a Alicia.
 Truso calcula 
\begin_inset Formula $K1=\left(Y_{B}\right)^{X_{T1}}\mod q$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
Alicia recibe 
\begin_inset Formula $Y_{D2}$
\end_inset

 y calcula 
\begin_inset Formula $K2=\left(Y_{D2}\right)^{X_{A}}\mod q$
\end_inset


\end_layout

\begin_layout Standard
\align left
En este punto, Bob y Alicia creen que comparten una clave secreta, pero
 en su lugar Bob y Truso comparten el secreto 
\begin_inset Formula $K1$
\end_inset

 y Alicia y Truso comparten el secreto 
\begin_inset Formula $K2$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Todos los mensajes posteriores están comprometidos.
\end_layout

\begin_layout Standard
\align left
Vemos como el protocolo de itnercambio de claves es vulnerable a este ataque.
 Pero esta vulnerabilidad se solucionar con el uso de firmas digitales y
 certificados de clave pública.
\end_layout

\begin_layout Subsection
Integridad de los mensajes y firmas digitales
\end_layout

\begin_layout Standard
Supongamos que Bob recibe un mensaje y cree que ha sido enviado por Alicia.
 Para autenticar el mensaje, Bob necesita verificar que (1) el mensaje es
 originario de Alicia y (2) no ha sido modificado en el camino.
\end_layout

\begin_layout Subsubsection
Funciones Hash criptográficas
\end_layout

\begin_layout Standard
\align left
Una función hash toma un input, 
\begin_inset Formula $m,$
\end_inset

 y obtiene una cadena de longitud fija 
\begin_inset Formula $H\left(m\right)$
\end_inset

 conocida como hash.
\end_layout

\begin_layout Standard
\align left
Una 
\series bold
función hash criptográfica 
\series default
debe tener la propiedad adicional de que sea computacionalmente infactible
 encontrar dos mensajes diferentes 
\begin_inset Formula $x,y$
\end_inset

 tales que 
\begin_inset Formula $H\left(x\right)=H\left(y\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Si 
\begin_inset Formula $\left(m,H\left(m\right)\right)$
\end_inset

 son el mensaje y el hash del mensaje creados por el emisor, entonces un
 intruso no puede forjar otro mensaje, 
\begin_inset Formula $y$
\end_inset

, de forma que tenga el mismo valor que el mensaje original.
\end_layout

\begin_layout Subsubsection*
Algoritmo MD5
\end_layout

\begin_layout Standard
Se usa ampliamente hoy en día.
 Calcula un hash de 128-bits en un proceso de 4 pasos consistente en:
\end_layout

\begin_layout Enumerate
Paso de relleno: añadir un 1 seguido de tantos 0s como sea necesario para
 que la longitud del mensaje satisfaga las condiciones requeridas
\end_layout

\begin_layout Enumerate
Paso de añadir: añadir una representación de 64-bit de la longitud del mensaje
 antes de rellenar
\end_layout

\begin_layout Enumerate
Inicialización de un acumulador
\end_layout

\begin_layout Enumerate
Paso final de bucle: los bloques de 16 palabras del mensaje son procesados
 en cuatro rondas
\end_layout

\begin_layout Subsubsection*
Secure Hash Algorithm (SHA-1)
\end_layout

\begin_layout Standard
Este algoritmo se basa en unos principios similares a los usados en el diseño
 de MD4, el predecesor de MD5.
 SHA-1, que es un estándar federal de EEUU, se requiere siempre que un algoritmo
 de hash cirptográfico se requiere en aplicaciones federales.
 Produce un mensaje de 160-bits.
\end_layout

\begin_layout Subsubsection
Message Authentication Code
\end_layout

\begin_layout Standard
Veamos cómo podríamos llevar a cabo integridad de los mensajes:
\end_layout

\begin_layout Enumerate
Alicia crea un mensaje 
\begin_inset Formula $m$
\end_inset

 y calcula su hash 
\begin_inset Formula $H\left(m\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Alicia añade 
\begin_inset Formula $H\left(m\right)$
\end_inset

 al final de 
\begin_inset Formula $m$
\end_inset

, creando un mensaje extendido 
\begin_inset Formula $\left(m,H\left(m\right)\right)$
\end_inset

 y lo envía a Bob
\end_layout

\begin_layout Enumerate
Bob recibe el mensaje extendido 
\begin_inset Formula $\left(m,h\right)$
\end_inset

 y calcula 
\begin_inset Formula $H\left(m\right)$
\end_inset

.
 Si 
\begin_inset Formula $H\left(m\right)=h\implies$
\end_inset

todo ha ido bien.
\end_layout

\begin_layout Standard
Este enfoque es obvio que tiene fallos.
 Truso podría crear un mensaje trampa 
\begin_inset Formula $m'$
\end_inset

 en el que dice que es Alicia, calcula 
\begin_inset Formula $H\left(m'\right)$
\end_inset

 y envía a Bob 
\begin_inset Formula $\left(m',H\left(m'\right)\right)$
\end_inset

.
 La comprobación del paso 3 no informará a Bob de que no es Alicia quien
 le ha enviado el mensaje.
\end_layout

\begin_layout Standard
Además de usar la función hash criptográfica, Alicia y Bob necesitan un
 secreto compartido 
\begin_inset Formula $s$
\end_inset

.
 Este secreto compartido es la 
\series bold
clave de autenticación
\series default
.
 Usando esta, la integridad de los mensajes se realiza como sigue:
\end_layout

\begin_layout Enumerate
Alicia crea el mensaje 
\begin_inset Formula $m$
\end_inset

, concatena 
\begin_inset Formula $s$
\end_inset

 con 
\begin_inset Formula $m$
\end_inset

 para crear 
\begin_inset Formula $m+s$
\end_inset

 y calcula el hash 
\begin_inset Formula $H\left(m+s\right)$
\end_inset

.
 A este hash se le denomina 
\series bold
message authentication code (MAC)
\end_layout

\begin_layout Enumerate
Alicia envía a Bob el mensaje extendido 
\begin_inset Formula $\left(m,H\left(m+s\right)\right)$
\end_inset


\end_layout

\begin_layout Enumerate
Bob recibe 
\begin_inset Formula $\left(m,h\right)$
\end_inset

 y calcula 
\begin_inset Formula $H\left(m+s\right)$
\end_inset

.
 Si 
\begin_inset Formula $H\left(m+s\right)=h\implies$
\end_inset

Todo ha ido bien
\end_layout

\begin_layout Standard
Una buena propiedad de una MAC es que no requiere un algoritmo de encriptación.
 Usando una MAC, las endidades pueden autenticar los mensajes que se envían
 entre ellas sin tener que integrar algoritmos complejos de encriptación
 en el proceso de integridad.
 El estándar más popular hoy en día es HMAC, que puede ser usado con MD5
 o SHA-1.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/mac.png
	scale 50

\end_inset


\end_layout

\begin_layout Subsubsection
Firmas digitales
\end_layout

\begin_layout Standard
\align left
Una 
\series bold
firma digital
\series default
 es una técnica criptográfica que hace las veces de una firma en el mundo
 digital.
\end_layout

\begin_layout Standard
\align left
Debe ser posible probar que un documento firmado por un individuo fue realmente
 firmado por ese individuo y solo por ese individuo.
\end_layout

\begin_layout Standard
\align left
Supongamos que Bob quiere firmar digitalmente un documento 
\begin_inset Formula $m$
\end_inset

.
 Para ello, Bob simplemente usa su clave privada, 
\begin_inset Formula $K_{B}^{-}$
\end_inset

 para calcular 
\begin_inset Formula $K_{B}^{-}\left(m\right)$
\end_inset

.
 En un principio, puede parecer extraño que Bob use su propia clave privada
 para firmar un documento.
 Pero recordemos que la encriptación y desencriptación no son más que operacione
s matemáticas y que el objetivo de Bob es no revolver el contenido del documento
, pero firmar el documento de forma que sea verificable y no modificable.
 La firma digital de Bob del documento es 
\begin_inset Formula $K_{B}^{-}\left(m\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
¿Es esta clave verificable y no modificable?
\end_layout

\begin_layout Standard
\align left
Supongamos que Alicia tiene 
\begin_inset Formula $m$
\end_inset

 y 
\begin_inset Formula $K_{B}^{-}\left(m\right)$
\end_inset

.
 Quiere probar que Bob firmó el documento y que es la única persona que
 pudo haberlo hecho.
 Alicia calcula 
\begin_inset Formula $K_{B}^{+}\left(K_{B}^{-}\left(m\right)\right)$
\end_inset

 y obtiene 
\begin_inset Formula $m$
\end_inset

.
 Esto significa que quien firmó el documento tiene la clave privada de Bob.
 Por tanto debe ser Bob y hemos comprobado la verificabilidad.
\end_layout

\begin_layout Standard
\align left
Si el documento original se modificase y pasase a ser 
\begin_inset Formula $m'$
\end_inset

, entonces la firma que Bob hizo para 
\begin_inset Formula $m$
\end_inset

 no servirá para 
\begin_inset Formula $m'$
\end_inset

 y por tanto se tiene la inalterabilidad.
\end_layout

\begin_layout Standard
\align left
Una consideración respecto a firmar datos por encriptación es que encriptación
 y desencriptación son operaciones costosas.
 Una forma más eficiente de hacerlo es introducir funciones Hash en la firma
 digital.
 Usando una función hash, Bob firma el hash de un mensaje en lugar del mensaje
 en sí mismo.
 O sea, Bob hace 
\begin_inset Formula $K_{B}^{-}\left(H\left(m\right)\right)$
\end_inset

.
 Como 
\begin_inset Formula $H\left(m\right)$
\end_inset

 suele ser mucho más pequeño que el mensaje original, el esfuerzo computacional
 es mucho menor.
\end_layout

\begin_layout Subsubsection
Comparación de MAC y firma digital
\end_layout

\begin_layout Standard
\align left
Ambos comienzan con un mensaje.
\end_layout

\begin_layout Standard
\align left
Para crear un MAC de este mensaje, añadimos una clave de autenticación al
 mensaje, y tomamos el hash del resultado.
 
\end_layout

\begin_layout Standard
\align left
Para crear una firma digital, primero tomamos el hash del mensaje y después
 encriptamos el mensaje con la clave privada.
\end_layout

\begin_layout Standard
\align left
Por tanto, la firma digital es una técnica más pesada.
\end_layout

\begin_layout Subsubsection
Certificación de clave pública
\end_layout

\begin_layout Standard
Para que la criptografía de clave pública sea útil, debemos poder verificar
 que tenemos la clave pública de la entidad con la que nos queremos comunicar.
\end_layout

\begin_layout Standard
La asociación de una clave pública con una entidad particular la hacen las
 
\series bold
Certification Authority (CA)
\series default
, cuyo trabajo es validar entidades y emitir certificados.
 Una CA tiene los siguientes roles:
\end_layout

\begin_layout Itemize
Verificar que una entidad es quien dice ser.
 No hay procesos estandar para esto.
 Cuando tratas con una CA, debes confiar en que la CA ha hecho una verificación
 rigurosa de la identidad
\end_layout

\begin_layout Itemize
Una vez que la CA verifica la identidad de la entidad, la CA crea un certificado
 que asocia la clave pública de la entidad con su identidad.
 El certitificado contiene la clave púbñica e información única de identificació
n sobre el poseedor de la clave pública.
 El certificado es digitalmente firmado por la CA
\end_layout

\begin_layout Section
Certificados de identidad X.509
\end_layout

\begin_layout Standard
\align left
Un 
\series bold
directorio
\series default
 es un servidor o conjunto de servidores distribuidos que mantiene una base
 de datos de información sobre usuarios.
\end_layout

\begin_layout Standard
\align left

\series bold
X.509
\series default
 define un marco de referencia para la provisión de servicios de autenticación
 por el directorio X.500 a sus usuarios.
 El directorio puede servir como repositorio de certificados de clave públic.
 Cada certificado contiene la clave pública de un usuario y está firmado
 con la clave privada de una CA de confianza.
 Además, X.509 define protocolos de autenticación alternativos basados en
 el uso de certificados de clave pública.
\end_layout

\begin_layout Standard
\align left
Se basa en el uso de criptografía de clave pública y firmas digitales.
 El estandar no dicta el uso de un algoritmo concreto pero recomienda RSA.
 El esquema de firma digital se asume que requiere el uso de una función
 hash.
 El estándar tampoco dicta el uso de un algoritmo hash específico.
\end_layout

\begin_layout Subsection
Certificados
\end_layout

\begin_layout Standard
\align left
El núcleo del esquema X.509 es el certificado de clave pública asociado con
 cada usuario.
 Estos certificados de usuario se asumen creados por alguna CA de confianza
 y que fueron puestos en el directorio por la CA o por el usuario.
 El directorio no es responsable de la creación de claves públicas o de
 la función de certificación.
 Solamente proporciona un lugar de fácil acceso para que los usuarios obtengan
 certificados.
\end_layout

\begin_layout Standard
\align left
Un certificado tiene los siguientes campos:
\end_layout

\begin_layout Itemize
\align left

\series bold
Version
\end_layout

\begin_layout Itemize
\align left

\series bold
Serial number:
\series default
 un entero único dentro del CA emisor 
\end_layout

\begin_layout Itemize
\align left

\series bold
Signature algorithm identifier:
\series default
 el algoritmo usado para firmar el certificado junto con cualquier parámetro
 asociado
\end_layout

\begin_layout Itemize
\align left

\series bold
Issuer name:
\series default
 nombre X.500 de la CA que creó y firmó el certificado
\end_layout

\begin_layout Itemize
\align left

\series bold
Period of validity:
\series default
 consiste en dos fechas: la primera y la última en las que el certificado
 es válido
\end_layout

\begin_layout Itemize
\align left

\series bold
Subject name:
\series default
 nombre del usuario al que refiere el certificado
\end_layout

\begin_layout Itemize
\align left

\series bold
Subject's public-key information:
\series default
 la clave pública del usuario, más un identificador del algoritmo para el
 que esta clave debe usarse, junto con cualquier parámetro asociado
\end_layout

\begin_layout Itemize
\align left

\series bold
Issuer unique identifier:
\series default
 un parámetro opcional usado para identificar al CA emisor en el evento
\end_layout

\begin_layout Itemize
\align left

\series bold
Subject unique identifier:
\series default
 parámetro opcional que identifica al usuario en el evento
\end_layout

\begin_layout Itemize
\align left

\series bold
Signature:
\series default
 cubre todos los otros campos del certificado: contiene el código hash de
 los otros campos encriptados con la clave privada del CA.
 Incluye el identificador del algoritmo de firma
\end_layout

\begin_layout Standard
\align left
\begin_inset Formula $Y\left\langle \left\langle A\right\rangle \right\rangle $
\end_inset

 denota que el certificado del usuario 
\begin_inset Formula $A$
\end_inset

 ha sido emitido por la CA 
\begin_inset Formula $Y$
\end_inset


\end_layout

\begin_layout Standard
\align left
La CA firma el certificado con su clave privada.
 Si la correspondiente clave pública es conocida por un usario, entocnes
 el usuario puede verificar que un certificado firmado por la CA es válido.
\end_layout

\begin_layout Subsection
Obteniendo el certificado de un usuario
\end_layout

\begin_layout Standard
Los certificados generados por un CA tienen las siguientes características:
\end_layout

\begin_layout Itemize
Cualquier usuario con acceso a la clave pública del CA puede verificar la
 clave pública que fue certificada
\end_layout

\begin_layout Itemize
Nadie aparte del CA emisor puede modificar el certificado sin ser detectado
\end_layout

\begin_layout Standard
Como los certificados no son modificables, pueden ponerse en un directorio
 sin necesidad de protegerlos especialmente.
\end_layout

\begin_layout Standard
Si todos los usuarios se suscribiesen al mismo CA, entonces habría una confianza
 generalizada en ese CA.
 Todos los certificados podrían ser puestos en el directorio para acceso
 de todos los usuarios.
 Además, un usuario puede transmitir su certificado directamente a otros
 usuarios.
 En cualquier caso, una vez que B tiene el certficado de A, B tiene la confianza
 de que los mensajes que encripte con la clave pública de A estarán seguros
 del espionaje y que los mensajes firmados con la clave privada de A no
 son modificables.
\end_layout

\begin_layout Standard
Si hay una gran comunidad de usuarios, puede no ser práctico que todos se
 suscriban al mismo CA.
 Como el CA firma certificados, cada participante debe tener una copia de
 la clave pública del CA para verificar firmas.
 Esta clave pública debe ser transmitida a cada usuario con total seguridad
 para que el usuario tenga confianza en los certificados asociados.
 Por tanto, con muchos usuarios, podría ser más práctico que hubiera varios
 CAs, cada uno proviendo su clave pública de forma segura a una porción
 de los usuarios.
\end_layout

\begin_layout Standard
Supongamos ahora que Alicia ha obtenido un certificado de una CA X y Bob
 lo ha obtenido de una CA Y.
 Si Alicia no conoce la clave pública de Y de forma segura, entonces el
 certificado de Bob es inútil para Alicia.
 Para solucionar esto, basta que las dos CAs intercambien de forma segura
 sus claves públicas:
\end_layout

\begin_layout Enumerate
Alicia obtiene del directorio el certificado de Y firmado por X.
 Como Alicia conoce de forma segura la clave pública de X, puede obtener
 la clave pública de Y de su certificado y verificarlo
\end_layout

\begin_layout Enumerate
Alicia entonces vuelve al directorio y obtiene el certificado de Bob firmado
 por Y.
 Como Alicia ya tiene una copia segura de la clave pública de Y, puede verificar
 la firma y obtener la clave pública de Bob de forma segura.
\end_layout

\begin_layout Standard
O sea, hace
\begin_inset Formula 
\[
X\left\langle \left\langle Y\right\rangle \right\rangle Y\left\langle \left\langle B\right\rangle \right\rangle 
\]

\end_inset


\end_layout

\begin_layout Standard
Todos estos certificados de CAs por CAs necesitan estar en el directorio,
 y el usuario debe saber cómo están relacionadas para encontrar el camino
 a la clave pública de otro usuario.
 X.509 sugiere que las CAs se ordenen de forma jerárquica de forma que la
 navegación sea obvia.
\end_layout

\begin_layout Standard
La entrada del directorio para cada CA incluye dos tipos de certificados:
\end_layout

\begin_layout Itemize

\series bold
certificados directos:
\series default
 certificados de X generados por otras CAs
\end_layout

\begin_layout Itemize

\series bold
certificados inversos:
\series default
 certificados generados por X que son certificados de otras CAs
\end_layout

\begin_layout Subsection
Revocación de certificados
\end_layout

\begin_layout Standard
Recordemos que cada certificado incluye un período de validez.
 Un nuevo certificado suele ser emitido justo antes de la expiración del
 antiguo.
 Además, puede ser deseable revocar certificados antes de que expiren, por
 alguna de las razones siguientes:
\end_layout

\begin_layout Itemize
Se cree que la clave privada del usuario ha sido comprometida
\end_layout

\begin_layout Itemize
El usaurio ya no está certificado por la CA
\end_layout

\begin_layout Itemize
El certificado de la CA se cree que está comprometido
\end_layout

\begin_layout Standard
Cada CA debe mantener una lista consistente en todos los certificados revocados
 pero no expirados emitidos por esa CA, incluyendo tanto los emitidos para
 usuarios como para otras CAs.
 Estas listas deben estar en el directorio.
\end_layout

\begin_layout Standard
Estas listas se denominan 
\series bold
certificate revocation list (CRL)
\series default
 y son firmadas por el emisor.
 Incluyen el nombre del emisor, la fecha en que se creó la lista, la fecha
 en la que la siguiente lista está programada para ser emitida, y una entrada
 por cada certificado revocado.
\end_layout

\begin_layout Standard
Cuando un usuario recibe un certificado en un mensaje, debe determinar si
 el certificado ha sido revocado.
 El usuario podría comprobar el directorio cada vez que recibe un certificado.
 Pero para ahorrar delays es probable que el usuario quiera mantener una
 caché local de certificados y de CRLs.
\end_layout

\begin_layout Subsection
Public Key Infraestructure (PKI)
\end_layout

\begin_layout Standard
Es el conjunto de hardware, software, gente, políticas y procedimientos
 necesarios para crear, administrar, almacenar, distribuir y revocar certificado
s digitales basados en criptografía asimétrica.
\end_layout

\begin_layout Standard
El objetivo es permitir la adquisición segura, conveniente y eficiente de
 claves públicas.
\end_layout

\begin_layout Standard
El grupo de trabajo PKIX ha dirigido la fuerza detrás de establecer un modelo
 formal basado en X.509 que sea adecuado para desplegar una arquitectura
 de certificación en Internet.
\end_layout

\begin_layout Standard
Los elmentos clave de PKIX son:
\end_layout

\begin_layout Itemize

\series bold
Entidad final:
\series default
 término genérico usado para denotar usuarios finales, dispositivos o cualquier
 otra entidad que pueda ser identificada como sujeto de un certificado de
 clave pública
\end_layout

\begin_layout Itemize

\series bold
Autoridad de certificación (CA):
\series default
 el emisor de certificados y de CRLs.
 Puede dar soporte a diversas tareas administrativas, aunque estas pueden
 ser delegadas a una o más autoridades de registro
\end_layout

\begin_layout Itemize

\series bold
Autoridad de registro (RA):
\series default
 componente opcional que puede asumir funciones administrativas del CA.
 El RA se suele asociar con el proceso de registro de una entidad final
 pero puede asistir en otras áreas.
\end_layout

\begin_layout Itemize

\series bold
Emisor CRL:
\series default
 componente opcional en el que la CA puede delegar la emisión de CRLs
\end_layout

\begin_layout Itemize

\series bold
Repositorio:
\series default
 término genérico usado para denotar cualquier método para almacenar certificado
s y CRLs para que puedan ser recuperados por las entidades finales
\end_layout

\begin_layout Section
Protocolos para comunicaciones seguras: SSL/TLS
\end_layout

\begin_layout Subsection
Secure Socket Layer (SSL)
\end_layout

\begin_layout Standard
\align left
Dos de los servicios de seguridad más extendidos son SSL y su sucesor TLS.
\end_layout

\begin_layout Standard
\align left

\series bold
SSL
\series default
 es un servicio de propósito general implementado como un conjunto de protocolos
 que se apoya en TCP.
 Hay dos opciones de implementación.
\end_layout

\begin_layout Standard
\align left
SSL puede ser provisto como parte de la suite de protocolos inferior y ser
 transparente a las aplicaciones o puede ser embebido en paquetes específicos.
\end_layout

\begin_layout Subsubsection
Arquitectura de SSL
\end_layout

\begin_layout Standard
SSL está diseñado para hacer uso de TCP para proporcionar un servicio punto
 a punto confiable.
 SSL no es un protocolo único,sino dos capas de protocolos.
\end_layout

\begin_layout Standard
Dos conceptos importantes son:
\end_layout

\begin_layout Itemize

\series bold
Conexión:
\series default
 es un transporte que proporciona un tipo apropiado de servicio.
 Para SSL, las conexiones son relaciones P2P.
 Las conexiones son transitorias.
 Toda coenxión está asociada a una sesión.
\end_layout

\begin_layout Itemize

\series bold
Sesión:
\series default
 es una asociación entre un cliente y un servidor.
 Las sesiones se crean por el Hanshake Protocol.
 Definen un conjunto de parámetros criptográficos de seguridad que pueden
 ser compartidos en múltiples conexiones.
 Las sesiones se usan para evitar la negociación cara de nuevos parámetros
 de seguridad para cada conexión.
\end_layout

\begin_layout Standard
Entre todo par de partes puede haber múltiples conexiones seguras.
 En teoría podría haber también múltiples sesiones simultáneas entre partes,
 pero esta característica no se usa en la práctica.
\end_layout

\begin_layout Standard
Hay cantidad de estados asociados con una sesión.
 El 
\series bold
estado de una sesión
\series default
 se define por los parámetros:
\end_layout

\begin_layout Itemize

\series bold
Session identifier
\end_layout

\begin_layout Itemize

\series bold
Peer certificate:
\series default
 un certificado X509v3 del peer
\end_layout

\begin_layout Itemize

\series bold
Compression method:
\series default
 el algoritmo usado para comprimir datos antes de encriptar
\end_layout

\begin_layout Itemize

\series bold
Cipher spec:
\series default
 especifica el algoritmo de encriptación y el algoritmo de hash usado para
 el cálculo de MAC.
 También define atributos criptográficos.
\end_layout

\begin_layout Itemize

\series bold
Master secret:
\series default
 secreto de 48 bits compartido entre el cliente y el servidor
\end_layout

\begin_layout Itemize

\series bold
Is resumable:
\series default
 un flag que indica si la sesión se puede usar para iniciar nuevas conexiones
\end_layout

\begin_layout Standard
El 
\series bold
estado de una conexión 
\series default
se define por los parámetros:
\end_layout

\begin_layout Itemize

\series bold
Server and client random:
\series default
 secuencias de bytes elegidas por el servidor y el cliente para cada conexión
\end_layout

\begin_layout Itemize

\series bold
Server write MAC secret:
\series default
 la clave secreta usada en las operaciones MAC en los datos enviados por
 el servidor
\end_layout

\begin_layout Itemize

\series bold
Client write MAC secret:
\series default
 la clave secreta usada en las operaciones MAC en los datos enviados por
 el cliente
\end_layout

\begin_layout Itemize

\series bold
Server write key:
\series default
 clave de encriptación secreta para los datos encriptados por el servidor
 y desencriptados por el cliente
\end_layout

\begin_layout Itemize

\series bold
Client write key: 
\series default
clave de encriptación secreta para los datos encriptados por el servidor
 y desencriptados por el cliente
\end_layout

\begin_layout Itemize

\series bold
Initialization vectors: 
\series default
cuando un cifrado de bloque en modo CBC se usa, se mantiene un IV para cada
 clave
\end_layout

\begin_layout Itemize

\series bold
Sequence numbers:
\series default
 cada parte mantiene números de secuencia distintos para los mensajes transmitid
os y recibidos para cada conexión
\end_layout

\begin_layout Subsubsection
SSL Record Protocol
\end_layout

\begin_layout Standard
\align left
Proporciona dos servicios para las conexiones SSL:
\end_layout

\begin_layout Itemize
\align left

\series bold
Confidencialidad:
\series default
 el Handshake Protocol define una clave secreta compartida que se usa para
 encriptación convencional de carga SSL
\end_layout

\begin_layout Itemize
\align left

\series bold
Message integrity: 
\series default
el Handshake Protocol define una clave secreta compartida que se usa para
 formar un MAC
\end_layout

\begin_layout Standard
\align left
El Record Protocol toma un mensaje de aplicación para ser transmitido, lo
 fragmenta en bloques manejables (
\series bold
fragmentación
\series default
), opcionalmente comprime los datos (
\series bold
compresión
\series default
), aplica una MAC, encripta, añade una cabecera, y transmite la unidad resultant
e en un segmento TCP.
 
\end_layout

\begin_layout Standard
\align left
Los datos recibidos se desencriptan, verifican, descomprimen y se ensamblan
 antes de ser entregados a los usuarios de niveles superiores.
\end_layout

\begin_layout Standard
\align left
La cabecera añadida tiene los siguientes campos:
\end_layout

\begin_layout Itemize
\align left

\series bold
Content type
\end_layout

\begin_layout Itemize
\align left

\series bold
Major version
\end_layout

\begin_layout Itemize
\align left

\series bold
Minor version
\end_layout

\begin_layout Itemize
\align left

\series bold
Compressed Length
\end_layout

\begin_layout Subsubsection
Change Cipher Spec Protocol
\end_layout

\begin_layout Standard
\align left
Es uno de los 3 protocoloos específicos de SSL que utiliza el SSL Record
 Protocol y es el más simple.
\end_layout

\begin_layout Standard
\align left
Consiste en un único mensaje que contiene un único byte con el valor 1.
 El propósito de este mensaje es causar que el estado pendiente se copie
 al estado actual, que actualiza la suite de cifrado que será usada en la
 conexión.
\end_layout

\begin_layout Subsubsection
Alert Protocol
\end_layout

\begin_layout Standard
Se usa para transmitir alertas relacionadas con SSL al peer.
 Como con otras aplicaciones que usan SSL, los mensajes de alerta son comprimido
s y encriptados, como se especifique en el estado actual.
 Cada mensaje de este protocolo consiste en dos bytes:
\end_layout

\begin_layout Enumerate
Toma los valores de warning (1) o de fatal (2) para transmitir la severidad
 de la alerta.
 Si el nivel es fatal, SSL termina la conexión.
 Otras sesiones abiertas pueden continuar, pero no se establecerán sesiones
 nuevas.
\end_layout

\begin_layout Enumerate
Contiene un código que indicala alerta en específico.
 Las alertas fatales son:
\end_layout

\begin_deeper
\begin_layout Itemize
unexpected_message
\end_layout

\begin_layout Itemize
bad_record_mac
\end_layout

\begin_layout Itemize
decompression_failure
\end_layout

\begin_layout Itemize
handshake_failure
\end_layout

\begin_layout Itemize
illegal_parameter
\end_layout

\begin_layout Standard
Las alertas de warning son:
\end_layout

\begin_layout Itemize
close_notify
\end_layout

\begin_layout Itemize
no_certificate
\end_layout

\begin_layout Itemize
bad_certificate
\end_layout

\begin_layout Itemize
unsupported_certificate
\end_layout

\begin_layout Itemize
certificate_revoked
\end_layout

\begin_layout Itemize
certificate_expired
\end_layout

\begin_layout Itemize
certificate_unknown
\end_layout

\end_deeper
\begin_layout Subsubsection
Handshake Protocol
\end_layout

\begin_layout Standard
Este protocolo permite al servidor y al cliente autenticar al otro y negociar
 algoritmos de encriptación y MAC y claves criptográficas a usar para proteger
 los datos enviados por el record SSL.
 
\end_layout

\begin_layout Standard
Este protocolo se usa antes de que los datos de aplicación se transmitan
 y conssite en una serie de mensajes intercambiados por cliente y servidor.
 Cada mensaje tiene tres campos:
\end_layout

\begin_layout Itemize

\series bold
Type:
\series default
 indica uno de 10 tipos de mensajes
\end_layout

\begin_layout Itemize

\series bold
Length:
\series default
 la longitud del mensaje en bytes
\end_layout

\begin_layout Itemize

\series bold
Content:
\series default
 los parámetros asociados al mensaje
\end_layout

\begin_layout Subsubsection*
Fase 1: Estableciendo las Prestaciones de Seguridad
\end_layout

\begin_layout Standard
\align left
Esa fase se usa para comenzar una conexión lógica y para establecer las
 prestaciones de seguridad que serán asociadas con ella.
 El intercambio es iniciado por el cliente, que envía un mensaje 
\series bold
client_hello
\series default
 con los siguientes parámetros:
\end_layout

\begin_layout Itemize
\align left

\series bold
Version:
\series default
 la version SSL más alta entendida por el cliente
\end_layout

\begin_layout Itemize
\align left

\series bold
Random:
\series default
 una estructura random generada por el cliente consistente en un timestamp
 de 32 bits y 28 bytes generados por un generador de números aleatorios
 seguro.
 Estos valores sirven como nonce (number that can be only used once) y se
 usan durante el intercambio de claves para prevenir ataques de replicación
\end_layout

\begin_layout Itemize
\align left

\series bold
Session ID:
\series default
 un identificar de sesión de longitud variable.
 Un valor distinto de 0 indica que el cliente quiere actualizar los parámetros
 de una conexión existente o crear una nueva conexión en esta sesión
\end_layout

\begin_layout Itemize
\align left

\series bold
CipherSuite:
\series default
 lista que contiene las combinaciones de algoritmos criptográficos soportados
 por el cliente, el orden decreciente de preferencia.
 Cada elemento de la lista define un algoritmo de intercambio de claves
 y un algoritmo de cifrado
\end_layout

\begin_layout Itemize
\align left

\series bold
Compression Method:
\series default
 lista de los métodos de compresión que soporta el cliente
\end_layout

\begin_layout Standard
\align left
Ahora el cliente espera el mensaje 
\series bold
server_hello
\series default
 que contiene los mismos parámetros que el client_hello.
\end_layout

\begin_layout Standard
\align left
El primer elemento del parámetro CipherSuite es el método de intercambio
 de claves.
 Se soporta:
\end_layout

\begin_layout Itemize
\align left

\series bold
RSA
\end_layout

\begin_layout Itemize
\align left

\series bold
Fixed
\series default
 
\series bold
Diffie-Hellman: 
\series default
es un DH en el que el certificado de blace pública contiene los parámetros
 de la clave pública de DH.
 Este método resulta en una clave secreta fija entre dos peers basada en
 DH usando claves públicas fijas.
\end_layout

\begin_layout Itemize
\align left

\series bold
Ephemeral DH:
\series default
 se usa para crear claves secretas temporales.
 Las claves públicas de DH se intercambian firmadas usando la clave privada
 RSA o DSS del emisor.
 El receptor puede usar la correspondiente clave pública para verificar
 la firma.
 Los certificados se usan para autenticar las claves públicas.
\end_layout

\begin_layout Itemize
\align left

\series bold
Anonymous DH:
\series default
 DH sin autenticación, como vimos este proceso es vulnerable al ataque man
 in the middle.
\end_layout

\begin_layout Itemize
\align left

\series bold
Fortezza
\end_layout

\begin_layout Standard
\align left
El segundo parámetro es el CipherSpec, que tiene los siguientes campos:
\end_layout

\begin_layout Itemize
\align left

\series bold
CipherAlgorithm 
\series default
(DES, 3DES,...)
\end_layout

\begin_layout Itemize
\align left

\series bold
MACAlgorithm 
\series default
(MD5 o SHA-1)
\end_layout

\begin_layout Itemize
\align left

\series bold
CypherType 
\series default
(de serie o de bloque)
\end_layout

\begin_layout Itemize
\align left

\series bold
IsExportable
\series default
 (true o false)
\end_layout

\begin_layout Itemize
\align left

\series bold
HashSize
\end_layout

\begin_layout Itemize
\align left

\series bold
Key Material 
\series default
(secuencia de bytes que contiene datos usados para generar las claves de
 escritura)
\end_layout

\begin_layout Itemize
\align left

\series bold
IV Size 
\series default
(tamaño del IV)
\end_layout

\begin_layout Subsubsection*
Fase 2: Autenticación del servidor e intercambio de claves
\end_layout

\begin_layout Standard
\align left
El servidor comienza esta fase enviando su certificado si nevesita ser autentica
do.
 El mensaje contiene un certificado x509 o una cadena de estos.
\end_layout

\begin_layout Standard
\align left
El 
\series bold
certificate message
\series default
 se requiere para cualquier método de intercambio de claves acordado excepto
 anonymous DH.
\end_layout

\begin_layout Standard
\align left
Después, un mensaje 
\series bold
server_key_exchange
\series default
 se envía si es requerido.
 No se requiere si: (1) el servidor ha enviado un certificado con fixed
 DH o (2) se va a utilizar intercambio de claves RSA.
 Se necesita en los demás casos:
\end_layout

\begin_layout Itemize
\align left

\series bold
Anonymous DH:
\series default
 el contenido del mensaje consiste en los dos valores globales de DH y la
 clave pública DH del servidor
\end_layout

\begin_layout Itemize
\align left

\series bold
Ephemeral DH:
\series default
 contiene los tres mismos àrámetros anteriores y una firma en esos parámetros
\end_layout

\begin_layout Itemize
\align left

\series bold
Intercambio de vlaces RSA 
\series default
(cuando el servidor usa RSA pero tiene una clave RSA de solo firma): el
 cleinte no puede simplemente enviar una clave secreta encriptada con la
 clave pública del servidor.
 Tiene que crear un par temporal RSA de claves pública y privada y usar
 el mensaje server_key_exchange para enviar la clave pública.
 El contenido del mensaje incluye los dos parámetros de la clave pública
 RSA temporal y una firma de esos parámetros
\end_layout

\begin_layout Itemize
\align left

\series bold
Fortezza
\end_layout

\begin_layout Standard
\align left
La firma se crea tomando el hash de un mensaje y encriptándolo con la clave
 privada del emisor.
\end_layout

\begin_layout Standard
\align left
El hash cubre no solo los parámetros DH o RSA sino también los dos nonces
 de los mensajes hello iniciales.
 Esto asegura ante ataques de replicación.
\end_layout

\begin_layout Standard
\align left
Después, un servidor no anónimo puede requerir un certificado del cliente.
 El mensaje 
\series bold
certificate_request
\series default
 incluye dos parámetros: 
\series bold
certificate_type
\series default
 y 
\series bold
certificate_authorities
\series default
.
 El certificate type indica el algoritmo de clave pública y su uso:
\end_layout

\begin_layout Itemize
\align left
RSA, solo firma
\end_layout

\begin_layout Itemize
\align left
DSS, solo firma
\end_layout

\begin_layout Itemize
\align left
RSA para fixed DH: la firma solo se usa para autenticación, enviando un
 certificado firmado con RSA
\end_layout

\begin_layout Itemize
\align left
DSS para fixed DH: igual que el anterior pero con DSS
\end_layout

\begin_layout Itemize
\align left
RSA para ephemeral DH
\end_layout

\begin_layout Itemize
\align left
DSS para ephemeral DH
\end_layout

\begin_layout Itemize
\align left
Fortezza
\end_layout

\begin_layout Standard
\align left
El segundo parámetro es una lista de los nombres de CAs aceptables.
\end_layout

\begin_layout Standard
\align left
El mensaje final de la fase dos es el mensaje 
\series bold
server_done
\series default
, enviado por el servidor para indicar el fin del hello y los mensajes asociados.
 Después de este mensaje, el servidor esperará a que el cliente responda.
 Este mensaje no tiene parámetros.
\end_layout

\begin_layout Subsubsection*
Fase 3: Autenticación del cliente e intercambio de claves
\end_layout

\begin_layout Standard
\align left
Tras recibir el mensaje server_done, el cliente debe verificar que el servidor
 ha proporcionado un certificado válido y comprobar que los parámetros del
 server_hello son aceptables.
 Si todo es correcto, el cliente envía uno o más mensajes para responder
 al servidor.
\end_layout

\begin_layout Standard
\align left
Si el servidor requiere un certificado, el cliente comienza esta fase enviando
 un 
\series bold
certificate message
\series default
.
 Si no hay certificados apropiados disponibles, el cliente envia una alerta
 no_certificate.
\end_layout

\begin_layout Standard
\align left
Ahora viene el mensaje 
\series bold
client_key_exchange
\series default
, que debe ser enviado ahora.
 El contenido de este mensaje depende del tipo de intercambio de claves:
\end_layout

\begin_layout Itemize
\align left

\series bold
RSA:
\series default
 el cliente genera un secreto pre-master de 48 bytes y lo encripta con la
 clave pública del certificado del servidor o una clave RSA temporal del
 mensaje server_key_Exchange.
 Se usa más tarde para calcular un secreto master.
\end_layout

\begin_layout Itemize
\align left

\series bold
Ephemeral y anonymous DH:
\series default
 los parámetros públicos de DH se envían
\end_layout

\begin_layout Itemize
\align left

\series bold
Fixed DH:
\series default
 los parámetros públicos de DH se envían en un certificate message, por
 lo que el contenido del mensaje es nulo
\end_layout

\begin_layout Itemize
\align left

\series bold
Fortezza
\end_layout

\begin_layout Standard
\align left
Finalmente, en esta fase el cliente podría enviar un mensaje 
\series bold
certificate_verify
\series default
 para proporcionar una verificacióne xplícita de un certificado de cliente.
 Este mensaje solo se envía tras algún certificado del cliente que tenga
 capacidad de firma.
 Este mensaje firma un código hash basado en los mensajes anteriores.
\end_layout

\begin_layout Subsubsection*
Fase 4: Final
\end_layout

\begin_layout Standard
\align left
Esta fase completa el establecimiento de una conexión segura.
 El cliente envía un mensaje 
\series bold
change_cipher_spec
\series default
 y copia el CipherSpec pendiente al CipherSpec actual.
 Este mensaje no se considera parte del Handshake Protocol sino del Change
 Cipher Spec Protocol.
 El cliente entonces envía el mensaje 
\series bold
finished
\series default
 bajo los nuevos algoritmos, claves y secretos.
 El mensaje finished verifica que el intercambio de claves y los procesos
 de autenticación fueron exitosos.
 
\end_layout

\begin_layout Standard
\align left
En respuesta a estos dos mensajes, el servidor envía su propio mensaje change_ci
pher_spec, transfiere el CipherSpec pendiente al actual y envía su mensaje
 finished.
\end_layout

\begin_layout Standard
\align left
En este momento, el hanshake es completado y cliente y servidor pueden comenzar
 a intercambiar datos del nivel de aplicación.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/ssl.png

\end_inset


\end_layout

\begin_layout Subsubsection*
Creación del secreto master
\end_layout

\begin_layout Standard
El secreto master compartido es un valor de 48 bytes de un único uso generado
 para esta sesión para un intercambio de claves seguro.
 La creación se hace en dos estapas:
\end_layout

\begin_layout Enumerate
Se intercambia la pre_master_secret
\end_layout

\begin_layout Enumerate
El master_secret se calcula por ambas pates.
 
\end_layout

\begin_layout Standard
Para el intercambio del pre_master_secret hay dos posibilidades:
\end_layout

\begin_layout Itemize

\series bold
RSA:
\series default
 el cliente genera el pre_master_secret de 48 bytes y lo encripta con la
 clave pública RSA del servidor, y se lo envía.
 El servidor lo desencripta usando su clave privada.
\end_layout

\begin_layout Itemize

\series bold
DH:
\series default
 cliente y servidor generan una clave pública DH.
 Cuando estas son intercambiadas, cada lado hace un cálculo DH para crear
 la pre_master_secret compartida.
\end_layout

\begin_layout Standard
Para generar el secreto master usan alguna función hash sobre la pre_master_secr
et y algunos más valores.
\end_layout

\begin_layout Subsection
Transport Layer Security (TLS)
\end_layout

\begin_layout Standard
Tiene como objetivo producir una versión estándar, no dependiente de un
 solo fabricante, de SSL.
 TLS se define como un estándar propuesto de Internet y es muy similar a
 SSLv3.
 Las principales diferencias son:
\end_layout

\begin_layout Itemize

\series bold
Número de versión:
\series default
 versión mayor 3, menor 1
\end_layout

\begin_layout Itemize

\series bold
MAC
\series default
: TLS tiene un algoritmo de firma basado en HMAC estándar
\end_layout

\begin_layout Itemize

\series bold
Función pseudoaleatoria:
\series default
 usa una función pseudoaleatoria conocida como PRF para expandir valores
 secretos en bloques de datos útiles para generación de claves o validación.
 El objetivo es utilizar un valor secreto compartido relativamente pequeño,
 pero generar bloques de datos más grandes de forma segura contra los ataques
 a las funciones hash y a los MAC
\end_layout

\begin_layout Itemize

\series bold
Códigos de alerta:
\series default
 TLS admite todos los códigos de alerta de SSLv3 con la excepción de la
 alerta no_certificate y define nuevos códigos de alerta
\end_layout

\begin_layout Itemize

\series bold
Padding variable:
\series default
 siempre múltiplo de la longitud del bloque de cifrado
\end_layout

\begin_layout Itemize

\series bold
Suite de algoritmos de cifrado disponible:
\series default
 no admite nulo ni Fortezza
\end_layout

\begin_layout Itemize

\series bold
Define más tipos de certificados de cliente
\end_layout

\begin_layout Itemize

\series bold
Mensajes certificate_verify y finished:
\series default
 en el mensaje certificate_verify se tiene campos extra.
 Los cálculos del mensaje finished son ligeramente diferentes.
 En ambos mensajes lo que cambia es el cáclulo del hash.
\end_layout

\begin_layout Standard
TLS 1.1: protege contra atauqes CBC
\end_layout

\begin_layout Standard
TLS 1.2: reemplaza MD5-SHA-1 por SHA-1 en PRF, mensaje finished y en el elemento
 firmado en el handshake (1 solo hash).
 Mejora en la especificación de los algoritmos soportados.
 Algoritmos de cifrado autenticado y suites AES.
 Extensiones TLS.
\end_layout

\begin_layout Standard
TLS 1.3: ha sido propuesto como Internet Standard.
 Mejora el rendimiento de als comunicaciones web.
 Principales mejoras respecto a TLS 1.2:
\end_layout

\begin_layout Itemize
Separación de los algoritmos de intercambio de claves y de autenticación
 en las suites
\end_layout

\begin_layout Itemize
Modo 0-RTT
\end_layout

\begin_layout Itemize
Todos los mensajes después del Server_hello están cifrados
\end_layout

\begin_layout Itemize
Rediseño de las funciones de derivación de clave: HDKF
\end_layout

\begin_layout Itemize
Curvas elípticas en la especificación base y nuevos algoritmos
\end_layout

\begin_layout Itemize
Resumen de sesión basado en PSK
\end_layout

\begin_layout Section
Protocolos para comunicaciones seguras: IPsec
\end_layout

\begin_layout Subsection
Conceptos básicos de IPSec
\end_layout

\begin_layout Standard
\align left
IPSec es una extensión de IP para proteger comunicaciones, diseñada para
 funcionar modo transparente en redes existentes.
\end_layout

\begin_layout Standard
\align left
Proporciona la capacidad de asegurar las comunicaciones a través de una
 LAN, de una WAN privada y pública y de Internet.
 Se usa, por rjemplo, para establecer una conexión segura entre oficinas
 sucursales a través de Internet, acceso remoto seguro a través de Internet,
 o mejorar la seguridad en el comercio electrónico.
\end_layout

\begin_layout Standard
\align left
La característica principal que tiene es que permite dar soporte a esta
 variedad de aplicaciones y puede cifrar y/o autenticar todo el tráfico
 en el nivel IP usando criptografóa.
 Por tanto, pueden asegurarse todas las aplicaciones distribuidas, incluyendo
 conexión remota, cliente/servidor, correo electrónico, transferencia de
 ficheros,...
\end_layout

\begin_layout Standard
\align left
Es independiente de los algoritmos de cifrado y firma y es aplicable para
 proteger IPv4 e IPv6
\end_layout

\begin_layout Subsubsection
Beneficios de IPSec
\end_layout

\begin_layout Itemize
\noindent
\align left

\series bold
IPSec puede ser transparente a usuarios finales
\end_layout

\begin_layout Itemize
\noindent
\align left

\series bold
IPSec puede proporcionar seguridad a usuarios individuales si es necesario
\end_layout

\begin_layout Itemize
\noindent
\align left

\series bold
IPSec protege la entrada a través de un firewall a una red:
\series default
 cuando IPSec se implementa en un cortafuegos o un router, proporciona una
 gran seguridad que se puede aplicar a todo el tráfico que lo cruza.
 
\end_layout

\begin_layout Subsubsection
Servicios IPSec
\end_layout

\begin_layout Standard
\align left
Proporciona servicios de seguridad en la capa IP, permitiendo que un sistema
 elija los protocolos de seguridad necesarios, determine los algoritmos
 que va a usar para el servicio o servicios y ubique las claves criptográficas
 necesarias para proporcionar los servicios solicitados.
 Se usan dos protocolos para proporcionar seguridad: un protocolo de autenticaci
ón designado por la cabecera del protocolo, AH, y un protocolo combinado
 de cifrado/autenticación designado por el formato del paquete para ese
 protocolo, ESP.
\end_layout

\begin_layout Standard
\align left
Los servicios son los siguientes: 
\end_layout

\begin_layout Itemize
\align left
Control de acceso
\end_layout

\begin_layout Itemize
\align left
Integridad por paquete
\end_layout

\begin_layout Itemize
\align left
Autenticación de los datos origen
\end_layout

\begin_layout Itemize
\align left
Rechazo de paquetes reenviados
\end_layout

\begin_layout Itemize
\align left
Condifencialidad de los datos
\end_layout

\begin_layout Itemize
\align left
Confidencialidad limitada en el flujo de tráfico
\end_layout

\begin_layout Subsubsection
Modos de operación
\end_layout

\begin_layout Itemize

\series bold
Modo transporte: 
\series default
proporciona protección a los protocolos de capas superiors.
 O sea, la protección del modo transporte se extiende a la carga útil del
 paquete IP.
 Normalmente el modo transporte se usa para la comunicación extremo a extremo
 entre dos hosts.
\end_layout

\begin_deeper
\begin_layout Standard
Con AH autentica la carga útil y algunas porciones de la cabecera IP.
\end_layout

\begin_layout Standard
Con ESP encripta la carga útil y cualquier cabecera de extensión de IPv6
 que vaya tras la cabecera ESP.
\end_layout

\begin_layout Standard
Con ESP con autenticación encripta la carga útil y las cabeceras de extensión
 de IPv6 que vayan tras la cabecera ESP y autentica la carga útil aunque
 no la cabecera IP.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Resumen/Imágenes/transpote1.png
	scale 60

\end_inset


\begin_inset Graphics
	filename Resumen/Imágenes/transporte2.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Modo túnel:
\series default
 proporciona protección al paquete PI completo.
 Para conseguirlo después de que se han añadido los campos AH y ESP al paquete
 IP, el paquete completo más los campos de seguridad se tratan como carga
 útil de un paquete IP exterior nuevo con una nueva cabecera IP exterior.
 El paquete IP original entero viaja a través de un túnel desde un punto
 de la red IP a otro; ningún router a lo largo del camino puede examinar
 la cabecera IP interior.
 Como el paquete original está encapsulado, el nuevo paquete, que es mayor,
 puede tener direcciones de origen y destino totalmente diferentes, añadiendo
 seguridad.
 El modo túnel se usa cuando uno de los extremos implementa IPSec.
\end_layout

\begin_deeper
\begin_layout Standard
AH autentica el paquete interior IP completo más porciones seleccionadas
 de la cabecera IP exterior.
\end_layout

\begin_layout Standard
ESP encripta el paquete IP interior completo.
\end_layout

\begin_layout Standard
ESP con autenticación encripta el paquete IP interior completo y lo autentica.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Resumen/Imágenes/tunel1.png
	scale 60

\end_inset


\begin_inset Graphics
	filename Resumen/Imágenes/tunel2.png
	scale 60

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Arquitectura general
\end_layout

\begin_layout Standard
Es importante la política de seguridad aplicada a cada paquete IP que transita
 desde origen hasta su destino.
 La política de IPSec está determinada principalmente por la interacción
 de dos bases de datos, la base de datos de asociación de seguridad (SAD)
 y la base de datos de política de seguridad.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/arqIPSEC.png
	scale 70

\end_inset


\end_layout

\begin_layout Subsubsection*
Asociación de seguridad (SA)
\end_layout

\begin_layout Standard
Una SA es una relación unidireccional entre un emisor y un receptor que
 ofrece servicios de seguridad al tráfico que se transporta.
 Si se necesita una relación que haga posible un itnercambio bidireccional
 seguro, entonces se requieren dos asociaciones de seguridad, una en cada
 sentido.
 Los servicios de seguridad se suministran a una SA para que se use AH o
 ESP, pero no los dos.
\end_layout

\begin_layout Standard
Una AS se identifica por tres parámetros:
\end_layout

\begin_layout Itemize

\series bold
Índice de parámetros de seguridad (SPI)
\end_layout

\begin_layout Itemize

\series bold
Dirección IP de destino
\end_layout

\begin_layout Itemize

\series bold
Identificador del protocolo de seguridad
\end_layout

\begin_layout Standard
Tiene asociados otros parámetros como un contador de número de secuencia,
 algoritmos criptográficos negociados, tiempo de vida,...
\end_layout

\begin_layout Subsubsection*
SAD
\end_layout

\begin_layout Standard
En cada implementación de IPSec hay una base de datos cuya funcionalidad
 debe estar presente en cada implementación de IPSec, pero la forma en que
 se proporciona dicha funcionalidad es decisión del implementador, de asociacion
es de seguridad que define los parámetros asociados con cada SA.
 Una asociación de seguridad se define, normalmente, por los siguientes
 parámetros:
\end_layout

\begin_layout Itemize

\series bold
SPI:
\series default
 número de 32 bits seleccionado por el receptor de un SA y que identifica
 el SA
\end_layout

\begin_layout Itemize

\series bold
AH information: 
\series default
algoritmos de autenticación, claves, tiempo de vida y parámetros relacionados
 con AH
\end_layout

\begin_layout Itemize

\series bold
ESP information:
\series default
 algoritmos de cifrado, de autenticación, vectores de inicialización, claves
 de autenticación y cifrado, tiempo de vida de las claves,...
\end_layout

\begin_layout Itemize

\series bold
Tiempo de vida de la SA
\end_layout

\begin_layout Itemize

\series bold
IPSec Protocol Mode:
\series default
 túnel o transporte
\end_layout

\begin_layout Itemize

\series bold
Path MTU:
\series default
 cualquier MTU (maximum transmission unit) descubierto
\end_layout

\begin_layout Itemize

\series bold
Sequence number counter, sequence counter overflow,...
\end_layout

\begin_layout Subsubsection*
SPD
\end_layout

\begin_layout Standard
El medio por el que el tráfico IP se relaciona con SAs específicas es la
 base de datos de políticas de seguridad.
 En su forma más simple una SPD contiene entradas, cada una de las cuales
 define un subconjunto de tráfico IP y señala una SA para ese tráfico.
\end_layout

\begin_layout Standard
Cada entrada de la SPD se define por un conjunto de valores de campos del
 protocolo IP y de protocolos de capas superiores, llamados 
\series bold
selectores
\series default
.
 Estos selectores se usan para filtrar tráfico saliente y establecer la
 correspondencia con una SA en particular.
 El procesamiento de tráfico saliente obedece a los siguientes pasos:
\end_layout

\begin_layout Enumerate
Comparar los valores de los campos adecuados del paquete con la SPD para
 encontrar una entrada coincidente, que señalará 0 o más SAs
\end_layout

\begin_layout Enumerate
Determinar la SA, si la hubiera, para este paquete y su SPI asociado
\end_layout

\begin_layout Enumerate
Llevar a cabo el procesamineto IPSec necesario
\end_layout

\begin_layout Standard
Los siguientes selectores determinan una entrada de la SPD:
\end_layout

\begin_layout Itemize

\series bold
Remote IP address
\end_layout

\begin_layout Itemize

\series bold
Local IP address
\end_layout

\begin_layout Itemize

\series bold
Next layer protocol:
\series default
 el protocolo qiue transporte IP sobre el cual se quiere realizar la acción
 IPSec
\end_layout

\begin_layout Itemize

\series bold
Name:
\series default
 identificador para el sistema operativo
\end_layout

\begin_layout Itemize

\series bold
Local and Remote ports
\end_layout

\begin_layout Subsubsection
Procesamiento de tráfico
\end_layout

\begin_layout Standard
IPSec se ejecuta paquete por paquete.
 Cuando se implementa IPSec cada paquete IP es procesado por IPSec antes
 de ser transmitido y cada paquete entrante también es procesado por IPSec
 después de su recepción y antes de su entrega a la capa superior.
\end_layout

\begin_layout Subsubsection*
Paquetes salientes
\end_layout

\begin_layout Standard
Un bloque de datos de una capa superior, como TCP, se pasa a la capa de
 IP y se forma un paquete IP que consiste en una cabecera IP y un cuerpo
 IP.
 Ocurre lo siguiente:
\end_layout

\begin_layout Enumerate
IPSec busca en el SPD una coincidencia con este paquete
\end_layout

\begin_layout Enumerate
Si no encuentra ninguna, el paquete se descarta y se genera un mensaje de
 error
\end_layout

\begin_layout Enumerate
Si se encuentra una coincidencia, el procesamiento adicional se determina
 por la primera entrada coincidente en el SPD.
 
\end_layout

\begin_deeper
\begin_layout Standard
Si la política para este paquete es DESECHAR, entonces el paquete se descarta.
\end_layout

\begin_layout Standard
Si la política es BYPASS, entonces no hay más procesamiento IPSec.
 El paquete se reenvía a la red para su transmisión.
\end_layout

\end_deeper
\begin_layout Enumerate
Si la política es PROTEGER, entonces se realiza una búsqueda de SAD para
 una entrada coincidente.
 Si no se encuentra ninguna entrada, se invoca IKE para crear una SA con
 las claves apropiadas y se crea una entrada en la SAD.
\end_layout

\begin_layout Enumerate
La entrada coincidente en el SAD determina el procesamiento de este paquete.
 Se puede realizar cifrado, autenticaicón o ambos, y se puede utilizar modo
 transporte o túnel.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/saliente.png

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection*
Paquetes entrantes
\end_layout

\begin_layout Enumerate
IPSec determina si se trata de un paquete IP no seguro o uno que tiene encabezad
os ESP o AH.
 
\end_layout

\begin_layout Enumerate
Si el paquete no es seguro, IPSec busca en el SPD una coincidencia con este
 paquete.
 Si la primera entrada coincidente tiene política de BYPASS, el encabezado
 IP se procesa y elimina y el cuerpo del paquete se entrega a la capa superior.
 
\end_layout

\begin_deeper
\begin_layout Standard
Si la primera entrada coincidente tiene política PROTEGER o DESECHAR, o
 si no hay una entrada coincidente, el paquete se descarta.
\end_layout

\end_deeper
\begin_layout Enumerate
Para un paquete seguro, IPSec busca el SAD.
 Si no se encuentra ninguna coincidencia, paquete se descarta.
 De lo contrario, IPSec aplica el procesamiento ESP o AH apropiado.
 Luego, el encabezado IP se procesa y se elimina y el cuerpo del paquete
 se encuentra a la siguiente capa.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/entrante.png

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Protocolo Internet Key Exchange (IKE)
\end_layout

\begin_layout Standard
\align left
Para establecer una asociación de seguridad IPSec es necesario negociar
 algoritmos criptográficos, un proceso de autenticación de las partes comunicant
es, distribuir el material criptográfico y seleccionar las cabeceras IPSec
 y el modo de operación.
 Para esto está el protocolo IKE.
\end_layout

\begin_layout Standard
\align left

\series bold
IKEv2
\series default
 implica el intercambio de mensajes en pares.
 Los primeros dos pares de intercambios se denominan 
\series bold
intercambios iniciales
\series default
.
 En el primer intercambio, los dos pares intercambian información sobre
 algoritmos criptográficos y otros parámetros de seguridad que están dispuestos
 a usar junto con los valores nonces y DH.
 El resultado de este intercambio es configurar una SA especial llamada
 IKE SA.
 Esta SA define los parámetros para un canal seguro entre los pares sobre
 los que tienen lugar los siguientes intercambios de mensajes.
 Por tanto, todos los intercambios de mensajes IKE posteriores están protegidos
 por cifrado y autenticación de mensajes.
\end_layout

\begin_layout Standard
\align left
En el segundo intercambio, las dos partes se autentican entre sí y configuran
 un primer IPSec SA que se colocará en el SADB y se usará para proteger
 las comunicaciones ordinarias entre los pares.
 Por tanto, se necesitan cuatro mensajes para establecer la primera SA para
 uso general.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/ikev2.png
	scale 75

\end_inset


\end_layout

\begin_layout Subsection
Cabeceras ESP (Encapsulating Security Payload)
\end_layout

\begin_layout Standard
\align left
El ESP se puede utilizar para proporcionar confidencialidad, autenticación
 de los datos de origen, integridad sin conexión, un servicio antireenvío.
\end_layout

\begin_layout Standard
Selección opcional de servicios: solo integridad, solo cifrado o ambos.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/cabESP.png

\end_inset


\end_layout

\begin_layout Standard
\align left
El 
\series bold
modo de transporte ESP
\series default
 se utiliza para cifrar y, opcionalmente, autenticar los datos transportados
 por IP.
 Para este modo, usando IPv4, el encabezado ESP se inserta en el paquete
 IP inmediatamente antes del encabezado de la capa de transporte y se coloca
 un finalizador ESP (con campos Relleno, Longitud del rello y Siguiente
 encabezado) después del paquete IP.
 Si se selecciona la autenticación, el campo Datos de autenticación ESP
 se agrega al final del paquete.
 Todo el segmento de nivel de transporte más el finalizador están cifrados.
 La autenticación cubre todo el texto cifrado más el encabezado ESP.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/transporteesp.png

\end_inset


\end_layout

\begin_layout Standard
\align left
El 
\series bold
modo túnel ESP
\series default
 se utiliza para cifrar un paquete IP completo.
 Para esto modo, el encabezado ESP es prefijado al paquete y se encripta
 todo el paquete interior más el finalizador ESP.
 Este método se puede utilizar para contrarrestar el análisis de tráfico.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/unelESP.png

\end_inset


\end_layout

\begin_layout Standard
\align left
Como el encabezado IP contiene la dirección de destino y posiblemente las
 directivas de enrutamiento de origen y la informción de la opción salto
 por salto, no es posible simplmente transmitir el paquete IP cifrado prefijado
 por el encabezado ESP.
 Los routers intermedios no podrían procesar tal paquete.
 Por tanto, es ecesario encapsular todo el bloque con un nuevo encabezado
 IP que contendrá información suficiente para el enrutamiento pero no para
 el análisis del tráfico.
\end_layout

\begin_layout Standard
\align left
El modo transporte es adecuado para proteger las conexiones entre hosts
 que admiten la función ESP y el modo túnel es útil en una configuración
 que incluye un firewall u otro tipo de gateway de seguridad que protege
 una red confiable de redes externas.
\end_layout

\begin_layout Subsection
Escenarios de despliegue
\end_layout

\begin_layout Enumerate
Toda la seguridad se proporciona entre los sitemas finales que implementan
 IPSec.
 Para que los dos sistemas finales se comuniquen a través de una SA, deben
 compartir las claves secretas apropiadas.
 Entre las posibles combinaciones se encuentran:
\end_layout

\begin_deeper
\begin_layout Itemize
AH en modo transporte
\end_layout

\begin_layout Itemize
ESP en modo transporte
\end_layout

\begin_layout Itemize
ESP seguido de AH en modo de transporte (un ESP SA dentro de un AH SA)
\end_layout

\begin_layout Itemize
Cualquiera de las anteriores dentro de un AH o ESP en modo túnel
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/ipsec1.png

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
La seguridad se proporciona solo entre las puertas de enlace y ningún host
 implementa IPSec.
 Este caso ilustra el soporte de la red privada virtual simple.
 El documento de arquitectura de seguridad especifica que solo se necesita
 un solo túnel SA para este caso.
 El túnel podría admitir AH, ESP o ESP con autenticación.
 No se requieren túneles anidados, porque los servicios de IPSec se aplican
 a todo el paquete interno.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/ipsec2.png

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Protocolos para comunicaciones seguras: SSH
\end_layout

\begin_layout Standard
\align left
SSH es un protocolo para asegurar comunicaciones en la red diseñado para
 ser relativamente simple y barato de implementar.
 Se pensó para proporcionar una forma de login remoto regura para reemplazar
 TELNET y otros esquemas de login remotos que no proporcionaban sguridad.
 SSH también proporciona una capacidad más general cliente/servidor y puede
 ser usada para funciones de red como correo o transferencia de archivos.
\end_layout

\begin_layout Standard
\align left
SSH2 arregla cantidad de errores de seguridad en el esquema original.
\end_layout

\begin_layout Standard
\align left
Las aplicaciones cliente y servidor SSH están ampliamente disponiles para
 casi todos los sistemas operativos.
\end_layout

\begin_layout Standard
\align left
SSh se organiza en tres protocolos normalmente ejecutados sobre TCP:
\end_layout

\begin_layout Itemize
\align left

\series bold
Transport Layer Protocol:
\series default
 proporciona autenticación del servidor, confidencialidad de datos e integridad
 de los datos con forward secrecy (esto quiere decir que si una clave se
 compromete ahora, no puede afectar a sesiones anteriores).
 Opcionalmente puede proporcionar compresión.
\end_layout

\begin_layout Itemize
\align left

\series bold
User Authentication Protocol: 
\series default
autentica el usuario al servidor.
\end_layout

\begin_layout Itemize
\align left

\series bold
Connection protocol: 
\series default
multiplexa varios canales de comunicación lógicos sobre una única conexión
 SSH subyacente
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/ssharq.png

\end_inset


\end_layout

\begin_layout Subsection
Transport Layer Protocol
\end_layout

\begin_layout Subsubsection
Claves de Host
\end_layout

\begin_layout Standard
La autenticación del servidor ocurre en el transport layer, y se basa en
 que el servidor posea un par de claves pública/privada.
 Un servidor podría tener múltiples claves de host usando distintos algoritmos
 de encriptación asimétrica.
 La clave de host del servidor se usa durante el intercambio de claves para
 autenticar la identidad del host.
 El cliente debe tener conocimiento previo de la clave de host pública del
 servidor.
 
\end_layout

\begin_layout Standard
Hay dos modelos alternativos:
\end_layout

\begin_layout Itemize
El cliente tiene una base de datos local que asocia cada nombre de host
 con la correspondiente clave de host.
 El problema es que la base de datos puede ser muy costosa de mantener.
\end_layout

\begin_layout Itemize
La asociación nombre-clave del host es certificada por una CA de confianza.
 El cliente solo sabe la clave raíz del CA y puede verificar la validez
 de todas las claves de host certificadas por CAs aceptadas.
 Esta alternativa elimina el problema de la manutención de la base de datos.
 Por otro lado, cada clave de host debe estar apropiadamente certificada
 por una CA antes de hacer posible la autorización.
\end_layout

\begin_layout Subsubsection
Intercambio de paquetes
\end_layout

\begin_layout Standard
Primero, el cliente establece una conexión TCP con el servidor.
 Esto se hace mediante el protocolo TCP y no es parte del Transport Layer
 Protocol.
 Una vez la conexión está establecida, el cliente y el servidor intercambian
 datos, llamados paquetes, en el campo de datos de los segmentos TCP.
 Cada paquete tiene el siguiente formato:
\end_layout

\begin_layout Itemize

\series bold
Packet length
\end_layout

\begin_layout Itemize

\series bold
Padding length
\end_layout

\begin_layout Itemize

\series bold
Payload:
\series default
 contenido útil del paquete.
 Antes de la negociación del algoritmo, este campo no se comprime.
 Si se negocia compresión, en los siguientes paquetes sí se comprimirá.
\end_layout

\begin_layout Itemize

\series bold
Random padding:
\series default
 una vez se negocia un algoritmo de encriptación, se añade este campo.
 Contiene una cantidad random de bytes de relleno de forma que la longitud
 total del paquete sea múltiplo del tamaño de un bloque de cifrado.
\end_layout

\begin_layout Itemize

\series bold
MAC:
\series default
 si se negocia autenticación, este campo contiene el valor de la MAC.
\end_layout

\begin_layout Standard
Una vez que el algoritmo de encriptación se negocia, el paquete completo
 se encripta tras calcular el valor de la MAC.
\end_layout

\begin_layout Standard
El intercambio de paquetes consiste en una serie de pasos:
\end_layout

\begin_layout Enumerate

\series bold
Identification string exchange:
\series default
 comienza con el cliente enviando un paquete con una cadena de identificación
 de la forma:
\begin_inset Formula 
\[
SS-protoversion-sorftwareversion\ SP\ comments\ CR\ LF
\]

\end_inset

 El servidor responde con su propia cadena de identificación.
 Estas cadenas se utilizan en el intercambio de claves DH.
\end_layout

\begin_layout Enumerate

\series bold
Negociación del algoritmo:
\series default
 cada parte envía un SSH_MSG_KEXINIT que contiene la lista de algoritmos
 soportados en orden de preferencia del emisor.
 Hay una lista para cada tipo de algoritmo criptográfico.
 Los algoritmos incluyen el intercambio de claves, encriptación, algoritmo
 de MAC y algoritmo de compresión.
\end_layout

\begin_deeper
\begin_layout Standard
Para cada categoría, el algoritmo elegido es el primer algoritmo de la lista
 del cliente que también es soportado por el cliente.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Intercambio de claves:
\series default
 solo se especifican dos versiones del intercambio de claves DH.
 Se siguen los siguientes pasos, donde se consideran ya negociados previamente
 
\begin_inset Formula $p,q,g$
\end_inset

 y el algoritmo hash:
\end_layout

\begin_deeper
\begin_layout Enumerate
El cliente genera un número 
\begin_inset Formula $x\ \left(1<x<q\right)$
\end_inset

 y calcula 
\begin_inset Formula $e=g^{x}\mod p$
\end_inset

.
 El cliente envía 
\begin_inset Formula $e$
\end_inset

 al servidor.
\end_layout

\begin_layout Enumerate
El servidor genera un número aleatorio 
\begin_inset Formula $y\ \left(1<y<q\right)$
\end_inset

 y calcula 
\begin_inset Formula $f=g^{y}\mod p$
\end_inset

.
 El servidor recibe 
\begin_inset Formula $e$
\end_inset

 y calcula 
\begin_inset Formula $K=e^{y}\mod p$
\end_inset

 y se calcula el hash, 
\begin_inset Formula $H$
\end_inset

, usando estos valores y algunos obtenidos anteriormente, como las cadenas
 de identificación.
 Firma 
\begin_inset Formula $H$
\end_inset

 con su clave de host privada, obteniendo 
\begin_inset Formula $s$
\end_inset

.
 Envía al cliente su clave de host pública, 
\begin_inset Formula $f$
\end_inset

 y 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Enumerate
El cliente verifica que la clave de host pública es la del servidor (aunque
 puede seguir sin verificarlo, pero esto hace el protocolo inseguro contra
 ataques activos).
 El cliente calcula 
\begin_inset Formula $K=f^{x}\mod p$
\end_inset

, su propio hash, 
\begin_inset Formula $H$
\end_inset

, usando los mismos valores que el servidor, y verifica la firma de 
\begin_inset Formula $s$
\end_inset

 en 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Standard
Ahora las dos partes comparten una clave master 
\begin_inset Formula $K$
\end_inset

.
 El servidor ha sido autenticado al cliente.
 El valor hash 
\begin_inset Formula $H$
\end_inset

 sirve como identificador de la sesión para esta conexión.
 Una vez calculado, el identificador de sesión no cambia, aunque se vuelva
 a realizar el intercambio de claves para obtener claves nuevas.
\end_layout

\end_deeper
\begin_layout Enumerate

\series bold
Final del intercambio de claves:
\series default
 se señaliza con el intercambio del mensaje SSH_MSG_NEWKEYS.
 En este punto, ambas partes pueden empezar a usar las claves generadas
 con 
\begin_inset Formula $K$
\end_inset

.
\end_layout

\begin_layout Enumerate

\series bold
Requerimiento de servicio:
\series default
 el cliente envía un mensaje SSH_MSG_SERVICE_REQUEST para requerir autenticación
 de usuario o bien el Connection Protocol.
 Tras esto, todos los datos se intercambian como la carga útil de un paquete
 SSH Transport Layer Protocol, prtegido por encriptación y MAC.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Resumen/Imágenes/SSHTLP1.png
	scale 70

\end_inset


\begin_inset Graphics
	filename Resumen/Imágenes/SSHTLP2.png
	scale 70

\end_inset


\end_layout

\begin_layout Subsubsection
Generación de claves
\end_layout

\begin_layout Standard
Las claves usadas para encriptación y MAC son generadas con la clave secreta
 compartida 
\begin_inset Formula $K$
\end_inset

, el valor hash obtenido en el intercambio de claves 
\begin_inset Formula $H$
\end_inset

, y el identificador de sesión (que es 
\begin_inset Formula $H$
\end_inset

 a no ser que haya intercambios posteriores):
\end_layout

\begin_layout Itemize
IV inicial del cliente al servidor: 
\begin_inset Formula $HASH\left(K\parallel H\parallel"A"\parallel session\_id\right)$
\end_inset


\end_layout

\begin_layout Itemize
IV inicial del servidor al cliente: 
\begin_inset Formula $HASH\left(K\parallel H\parallel"B"\parallel session\_id\right)$
\end_inset


\end_layout

\begin_layout Itemize
Clave de encriptación del cliente al servidor: 
\begin_inset Formula $HASH\left(K\parallel H\parallel"C"\parallel session\_id\right)$
\end_inset


\end_layout

\begin_layout Itemize
Clave de encriptación del servidor al cliente: 
\begin_inset Formula $HASH\left(K\parallel H\parallel"D"\parallel session\_id\right)$
\end_inset


\end_layout

\begin_layout Itemize
Clave de integridad del cliente al servidor: 
\begin_inset Formula $HASH\left(K\parallel H\parallel"E"\parallel session\_id\right)$
\end_inset


\end_layout

\begin_layout Itemize
Clave de integridad del servidor al cliente: 
\begin_inset Formula $HASH\left(K\parallel H\parallel"F"\parallel session\_id\right)$
\end_inset


\end_layout

\begin_layout Subsection
User Authentication Protocol
\end_layout

\begin_layout Standard
Proporciona los medios por los que el cliente se autentica al servidor.
\end_layout

\begin_layout Subsubsection
Tipos de mensajes y formatos
\end_layout

\begin_layout Standard
Hay tres tipos de mensajes que siempre se usan en el UAP.
 
\end_layout

\begin_layout Standard
La peticiones de autenticación del cliente tienen el formato:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{array}{cc}
byte & SSH\_MSG\_USERAUTH\_REQUEST\ \left(50\right)\\
string & user\ name\\
string & service\ name\\
string & method\ name\\
... & method\ specific\ fields
\end{array}
\]

\end_inset

 Si el servidor (1) rechaza la petición de autenticación o (2) la acepta
 pero requiere algún método de autenticación adicional, el servidor envía
 un mensaje con el formato:
\begin_inset Formula 
\[
\begin{array}{cc}
byte & SSH\_MSG\_USERAUTH\_FAILURE\ \left(51\right)\\
name-list & authentications\ that\ can\ continue\\
boolean & partial\ success
\end{array}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Intercambio de mensajes
\end_layout

\begin_layout Standard
El intercambio de mensajes tiene los siguientes pasos:
\end_layout

\begin_layout Enumerate
El cliente envía un SSH_MSG_USERAUTH_REQUEST con ningún método requerido.
\end_layout

\begin_layout Enumerate
El servidor comprueba si el nombre de usuario es válido.
 Si no, el servidor devuelve SSH_MSG_USERAUTH_FAILURE con un partial success
 a false.
 Si el nombre de usuario es válido, pasa al paso 3.
\end_layout

\begin_layout Enumerate
El servidor devuelve SSH_MSG_USERAUTH_FAILURE con una lista de uno o más
 métodos de autenticación a usar.
\end_layout

\begin_layout Enumerate
El cliente elige uno de los métodos aceptables de autenticación y envía
 un SSH_MSG_USERAUTH_REQUEST con ese método y sus campos específicos.
 En este punto, puede haber una secuencia de intercambios para llevar a
 cabo el método.
\end_layout

\begin_layout Enumerate
Si la autenticación es exitosa y se requieren más métodos de autenticación,
 el servidor vuelve al paso 3, usando un partial success a true.
 Si la autenticación falla, el servidor vuelve al paso 3, con el partial
 success a false.
\end_layout

\begin_layout Enumerate
Cuando todos los métodos requeridos de autenticación han sido completados
 con éxito, el servidor envía un mensaje MSG_USERAUTH_SUCCESS y el UAP termina.
\end_layout

\begin_layout Subsubsection
Métodos de autenticación
\end_layout

\begin_layout Itemize

\series bold
publickey:
\series default
 el cliente envía un mensaje al servidor que contiene la clave pública del
 cliente, con el mensaje firmado con la clave privada del cliente.
 Cuando el servidor recibe el mensaje, comprueba si la clave suministrada
 es aceptable para autenticación y, si es así, comprueba que la firma es
 correcta.
\end_layout

\begin_layout Itemize

\series bold
password:
\series default
 el cliente envía un mensaje que contiene una contraseña en texto plano,
 que es protegida con encriptación por el TLP.
\end_layout

\begin_layout Itemize

\series bold
hostbased:
\series default
 la autenticación se hace por el host del cliente en lugar de por el propio
 cliente.
 Por tanto, un host puede dar soporte a varios cliente y proveer autenticación
 a todos ellos.
\end_layout

\begin_layout Subsection
Connection protocol
\end_layout

\begin_layout Standard
Se ejecuta sobre el SSH TLP y asume que una conexión segura y autenticada
 está en curso.
 Esta conexión segura, llamada 
\series bold
túnel
\series default
, se usa por el Connection Protocol para multiplexar cantidad de canales
 lógicos.
\end_layout

\begin_layout Subsubsection
Mecanismo de canales
\end_layout

\begin_layout Standard
Todos los tipos de comunicación que usan SSH se les da soporte usando canales
 separados.
 Cada parte puede abrir un canal.
 Para cada canal, cada parte asocia un número de canal único, que no tiene
 por qué coincidir en ambos extremos.
 El flujo de los canales se controla usando un mecanismo de ventana.
 No se envían datos a un canal hasta que se recibe un mensaje que indica
 que hay espacio de ventana disponible.
\end_layout

\begin_layout Standard
La vida de un canal tiene tres etapas: 
\end_layout

\begin_layout Enumerate

\series bold
Apertura del canal:
\series default
 cuando alguna parte quiere abrir un nuevo canal, le asigna un número al
 canal y envía un mensaje de la forma:
\begin_inset Formula 
\[
\begin{array}{cc}
byte & SSH\_MSG\_CHANNEL\_OPEN\\
string & channel\ type\\
uint32 & sender\ channel\\
uint32 & initital\ window\ size\\
uint32 & maximum\ packet\ size\\
... & channel\ type\ specific\ data\ follows
\end{array}
\]

\end_inset

 Si el lado remoto puede abrir el canal, devuelve un SSH_MSG_CHANNEL_OPEN_CONFIR
MATION, que incluye el número de canal del emisor, el del receptor, y valores
 del tamaño la ventana y tamaño del paquete para tráfico entrante.
 Si no, el lado remoto envía un SSH_MSG_CHANNEL_OPEN_FAILURE con un código
 que expresa la razón del fallo.
\end_layout

\begin_layout Enumerate

\series bold
Transferencia de datos:
\series default
 se lleva a cabo usando un mensaje SSH_MSG_CHANNEL_DATA, que incluye el
 número de canal del receptor y un bloque de datos.
\end_layout

\begin_layout Enumerate

\series bold
Cierre del canal:
\series default
 cuando alguna parte quiere cerrar el canal, envía un SSH_MSG_CHANNEL_CLOSE,
 que incluye el número de canal del receptor.
\end_layout

\begin_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/SSHCP.png

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Tipos de canales
\end_layout

\begin_layout Itemize

\series bold
session:
\series default
 para ejecutar programas de forma remota
\end_layout

\begin_layout Itemize

\series bold
x11:
\series default
 se refiere al sistema X Window
\end_layout

\begin_layout Itemize

\series bold
forwarded-tcpip:
\series default
 esto es port forwarding remoto
\end_layout

\begin_layout Itemize

\series bold
direct-tcpip:
\series default
 para port forwarding local
\end_layout

\begin_layout Subsection
Port forwarding
\end_layout

\begin_layout Standard
Es una de las mejores utilidades de SSH.
 Proporciona la capacidad de convertir cualquier conexión TCP insegura en
 una conexión SSH segura.
 
\end_layout

\begin_layout Standard
Un 
\series bold
puerto
\series default
 es un identificador de un usuario de TCP.
 Así, cualquier aplicación que se ejecuta sobre TCP tiene un número de puerto
 asociado.
 El tráfico TCP entrante se entrega a la aplicación correspondiente basándose
 en el número de puerto.
\end_layout

\begin_layout Standard
Supongamos ahora que tenemos una aplicación cliente identificada por el
 número de puerto 
\begin_inset Formula $x$
\end_inset

 y una aplicación de servidor identificada con el número de puerto 
\begin_inset Formula $y$
\end_inset

.
 En algún punto, la aplicación cliente invoca a la entidad TCP local y requiere
 una conexión con el servidor en el puerto 
\begin_inset Formula $y$
\end_inset

.
 La entidad TCP local negocia una conexión TCP con la entidad TCP remota,
 de tal forma que establece una conexión entre el puerto local 
\begin_inset Formula $x$
\end_inset

 y el remoto 
\begin_inset Formula $y$
\end_inset

.
\end_layout

\begin_layout Standard
Para asegurar esta conexión, SSH se configura de tal forma que el SSH TLP
 establece una conexión TCP entre el cliente SSH y entidades de servidor,
 con números de puerto 
\begin_inset Formula $a$
\end_inset

 y 
\begin_inset Formula $b$
\end_inset

, respectivamente.
 Un túnel SSH seguro se establece sobre esta conexión TCP.
 El tráfico del cliente en el puerto 
\begin_inset Formula $x$
\end_inset

 se redirige a la entidad SSH local y viaja a través del túnel hasta que
 la entidad SSH entrega los datos al servidor en el puerto 
\begin_inset Formula $y$
\end_inset

.
 El tráfico en la otra dirección se redirige de forma similar.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename Resumen/Imágenes/portforw.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
Hay dos tipos de port forwarding:
\end_layout

\begin_layout Enumerate

\series bold
Forwarding local:
\series default
 permite al cliente montar un proceso secuestrados.
 Este interceptará tráfico del nivel de aplicación seleccionado y lo redigirá
 de una conexión TCP insegura a un túnel SSH seguro.
 SSH se configura para escuchar en puertos seleccionados.
 SSH toma todo el tráfico usando un peurto seleccionado y lo envía a través
 de un túnel SSH.
 En el otro extremo, el servidor SSH envía el tráfico entrante al puerto
 destino dictado por la aplicación cliente.
\end_layout

\begin_layout Enumerate

\series bold
Forwarding remoto: 
\series default
el cliente SSH del usuario actúa en nombre del servidor.
 El cliente recibe el tráfico con un determinado número de puerto destino,
 coloca el tráfico en el puerto correcto y lo envía al destino que el usuario
 desee.
\end_layout

\end_body
\end_document
