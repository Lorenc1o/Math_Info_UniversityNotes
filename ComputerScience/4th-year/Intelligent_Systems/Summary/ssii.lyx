#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\begin_modules
tcolorbox
theorems-std
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 3cm
\rightmargin 2cm
\bottommargin 3cm
\headheight 3cm
\headsep 3cm
\footskip 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "morekeywords={&quot;función&quot;, &quot;devuelve&quot;, &quot;entradas&quot;, &quot;estático&quot;, &quot;repetir&quot;, &quot;devolver&quot;}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Sistemas Inteligentes
\end_layout

\begin_layout Date
Curso 20/21
\end_layout

\begin_layout Author
Jose Antonio Lorencio Abril
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introducción a los Sistemas Inteligentes Artificiales
\end_layout

\begin_layout Subsection
¿Qué es la inteligencia artificial?
\end_layout

\begin_layout Standard
\align left
Es un área de la ciencia e ingeniería bastante reciente.
 Su objetivo son las capacidades que consideramos inteligentes.
\end_layout

\begin_layout Standard
\align left
La inteligencia artificial (IA) puede ser entendida desde cuatro enfoques:
\end_layout

\begin_layout Itemize
\align left

\series bold
Sistemas que actúan como humanos:
\series default
 el estudio de cómo hacer computadores que hagan cosas que, de momento,
 la gente hacer mejor.
\end_layout

\begin_deeper
\begin_layout Standard
\align left
El modelo es el hombre, y el objetivo es construir un sistema que pase por
 humano.
\end_layout

\begin_layout Standard
\align left

\series bold
Test de Turing
\series default
: test ideado por Alan Turing, consistente en que un humano se comunica
 con una máquina.
 Si no es capaz de distinguir a la máquina de un humano, se considera que
 esa máquina pasa el test.
 Se supone que una máquina que pasa el test de Turing es inteligente, aunque
 hoy en día no se cree que esto sea suficiente para calificar un sistema
 de inteligente (hay chatbots muy avanzados que no son inteligentes)
\end_layout

\begin_layout Standard
\align left
Para actuar como un humano, la máquina debe ser capaz de procesar el lenguaje
 natural (NLP), representar el conocimiento, razonar, aprender,...
\end_layout

\begin_layout Standard
\align left
Es necesaria, además, la interacción programas-personas, por lo que los
 programas deben actuar como humanos.
\end_layout

\end_deeper
\begin_layout Itemize
\align left

\series bold
Sistemas que piensan como humanos:
\series default
 el esfuerzo por hacer a las computadores pensar, conseguir máquinas con
 mentes en el sentido amplio y literal.
 Ahora el modelo es la mente humana.
 Intentamos establecer una teoría sobre el funcionamiento de la mente (mediante
 experimentación psicológica), y, a partir de esta, establecer modelos computaci
onales, de lo que se encargan las ciencias cognitivas.
\end_layout

\begin_layout Itemize
\align left

\series bold
Sistemas que actúan racionalmente:
\series default
 campo de estudio que busca explicar y emular el comportamiento inteligente
 en términos de procesos computacionales.
 
\end_layout

\begin_deeper
\begin_layout Standard
\align left
Actuar racionalmente significa conseguir unos objetivos dadas unas creencias.
\end_layout

\begin_layout Standard
\align left
El paradigma es el 
\series bold
agente racional
\series default
, que es un agente capaz de percibir su entorno y que aplica su conocimiento
 racional para actuar y conseguir sus objetivos.
\end_layout

\begin_layout Standard
\align left
Requiere de ciertas capacidades, como NLP, representación del conocimiento,
 aprendizaje, adaptación al entorno,...
\end_layout

\begin_layout Standard
\align left
Presenta una visión general, no centrada en el modelo humano, utiliza fuentes
 de conocimiento adicionales a la lógica
\end_layout

\end_deeper
\begin_layout Itemize
\align left

\series bold
Sistemas que piensan racionalmente:
\series default
 estudio de las facultades mentales a través del estudio de modelos computaciona
les.
 Se presupone que las leyes del pensamiento racional se fundamentan en la
 lógica formal, que es la base de los programas inteligentes.
 Este enfoque se encuentra con dos obstáculos:
\end_layout

\begin_deeper
\begin_layout Itemize
\align left
Es muy difícil formalizar el conocimiento
\end_layout

\begin_layout Itemize
Hay un gran salto entre la capacidad teórica de la lógica y su realización
 práctica
\end_layout

\end_deeper
\begin_layout Subsection
Bases de la IA
\end_layout

\begin_layout Standard
\align left
La historia de la IA va ligada al proceso humano de comprensión de la naturaleza
, concretamente al problema del funcionamiento de la mente.
\end_layout

\begin_layout Standard
\align left
La 
\series bold
filosofía
\series default
, desde hace milenios, se ha preguntado sobre la inteligencia, desde diversos
 puntos de vista.
 Es destacable el desarrollo de la lógica formal, buscando formalizar los
 razonamientos humanos.
\end_layout

\begin_layout Standard
\align left
A través de la lógica, se hace posible la formalización de la búsqueda de
 patrones, las 
\series bold
matemáticas
\series default
, que pasan de ser métodos de contabilidad, a ser una marco lógico mediante
 el que se pueden establecer reglas, relaciones y verdades irrefutables
 (bajo los axiomas acordados como ciertos).
 Las matemáticas permiten abordar la IA desde varias perspectivas:
\end_layout

\begin_layout Itemize
\align left
Lógica: búsqueda de las reglas del razonamiento
\end_layout

\begin_layout Itemize
\align left
Complejidad: intento de establecer qué problemas puede resolver un ordenador
 en un tiempo razonable, y cuáles no
\end_layout

\begin_layout Itemize
\align left
Probabilidad: razonamiento en entornos inciertos
\end_layout

\begin_layout Standard
\align left
La 
\series bold
economía
\series default
 ha profundizado bastante en el proceso de toma de decisiones con diferentes
 objetivos:
\end_layout

\begin_layout Itemize
\align left
decisiones beneficiosas
\end_layout

\begin_layout Itemize
\align left
decisiones contra competidores
\end_layout

\begin_layout Itemize
\align left
corto plazo VS largo plazo
\end_layout

\begin_layout Standard
\align left
dando lugar a la teoría de la decisión (estudio de la toma de decisiones),
 teoría de juegos (estudio de la toma de decisiones en entornos multiagente),
 investigación operativa (optimización).
\end_layout

\begin_layout Standard
\align left
La 
\series bold
neurociencia
\series default
 y la 
\series bold
psicología
\series default
 son dos grandes colaboradoras de la IA.
 Proponen modelos de funcionamiento del cerebro, modos de actuación, de
 aprendizaje y de desarrollo mental
\end_layout

\begin_layout Standard
\align left
La 
\series bold
computación
\series default
 estudia las mejoras hardware y software para poder implementar potentes
 modelos de IA.
\end_layout

\begin_layout Standard
\align left
La 
\series bold
teoría de control 
\series default
o 
\series bold
cibernética
\series default
 colabora mediante la construcción de sistemas autónomos.
\end_layout

\begin_layout Standard
\align left
La 
\series bold
lingüística 
\series default
ha resultado ser un importante campo para la IA, ya que estudia la representació
n del conocimiento, así como el funcionamiento gramatical de la lengua.
\end_layout

\begin_layout Subsection
Aplicaciones de la IA
\end_layout

\begin_layout Itemize
Sistemas de recomendación o filtrado
\end_layout

\begin_layout Itemize
Interfaces hombre-máquina
\end_layout

\begin_layout Itemize
Robótica
\end_layout

\begin_layout Itemize
Tareas específicas en medicina, educación, finanzas,...
\end_layout

\begin_layout Subsection
Método de la IA
\end_layout

\begin_layout Standard
Un 
\series bold
método
\series default
 es un modo de realizar con orden la actividad científica y académica según
 su propia naturaleza.
\end_layout

\begin_layout Standard
La IA dispone de varias herramientas para resolver los problemas que se
 le plantean:
\end_layout

\begin_layout Itemize
Heurística y algoritmia:
\end_layout

\begin_deeper
\begin_layout Itemize
Un 
\series bold
algoritmo
\series default
 es un método general de resolución de algún problema, de forma que su validez
 sea incuestionable, por basarse en principios formalizados.
 Puede cuestionarse, eso sí, su eficiencia
\end_layout

\begin_layout Itemize
Un 
\series bold
método heurístico
\series default
 es un método de resolución de problemas que se basa en la intuición o en
 la experiencia, y sirve para resolver problemas de forma más rápida, pero
 correcta
\end_layout

\end_deeper
\begin_layout Itemize
Computación simbólica y numérica
\end_layout

\begin_deeper
\begin_layout Itemize
Un 
\series bold
símbolo
\series default
 es una entidad cuyo valor no pertenece dominio en el que existe el símbolo.
 La inteligencia se asocia a la posibilidad de usar símbolos para representar
 la realidad y las ideas.
 Una aproximación metodológica correcta a un problema debe considerar el
 problema como un sistema de símbolos que poseen un álgebra específica y
 nunca considerar a la aritmética como el álgebra principal
\end_layout

\end_deeper
\begin_layout Itemize
Procedimentalismo y declarativismo
\end_layout

\begin_deeper
\begin_layout Itemize
la 
\series bold
programación procedimental
\series default
 utiliza una descripción del problema basada en la especificación de un
 conjunto de órdenes o instrucciones (funciones) que, ejecutadas en un orden,
 conducen a una solución
\end_layout

\begin_layout Itemize
la 
\series bold
programación declarativa
\series default
 realiza una descripción de los problemas en forma de las relaciones lógico-func
ionales de los componentes y los datos del mismo.
 No especifica la forma de alcanzar la solución, sino la relación que debe
 existir entre esta y los datos, así que una máquina que incorpore este
 tipo de programación debe realizar una inferencia de la solución a partir
 de los datos y de las relaciones especificadas
\end_layout

\end_deeper
\begin_layout Subsection
Distintas definiciones de Sistemas Inteligentes
\end_layout

\begin_layout Standard
\align left
Un 
\series bold
sistema
\series default
 es un conjunto de elementos conectados que se organizan para un propósito
 común.
 Los 
\series bold
sistemas inteligentes
\series default
 incluyen no solo dispositivos inteligentes, sino también conjuntos interconecta
dos de tales dispositivos.
\end_layout

\begin_layout Itemize
\align left
Un sistema inteligente es un programa de ordenador que reúne características
 y comportamientos asimilables al de la inteligencia humana o animal.
 Se usa a veces para sistemas inteligentes incompletos, ya que un sistema
 inteligente completo debe incluir 
\begin_inset Quotes eld
\end_inset

sentidos
\begin_inset Quotes erd
\end_inset

 que le permitan recibir información de su entorno, actuar, y disponer de
 memoria para almacenar el resultado de sus acciones.
 Además, debe aprender de su experiencia para lograr mejorar su rendimiento
 y eficiencia.
 
\end_layout

\begin_deeper
\begin_layout Standard
\align left
Wikipedia
\end_layout

\end_deeper
\begin_layout Itemize
\align left
Un sistema controlado por ordenador y es capaz de responder a cambios del
 entorno para establecer las condiciones óptimas de funcionamiento sin intervenc
ión humana.
\end_layout

\begin_deeper
\begin_layout Standard
\align left
RAE
\end_layout

\end_deeper
\begin_layout Itemize
\align left
Un sistema basado en procedimientos, metodologías o técnicas de la IA, para
 llevar a cabo de forma más precisa y efectiva operaciones para la resolución
 de problemas.
\end_layout

\begin_deeper
\begin_layout Standard
\align left
Handbook of Research on Novel Soft Computing Intelligent Algorithms: Theory
 and Practical Applications
\end_layout

\end_deeper
\begin_layout Itemize
\align left
Sistema que puede imitar y automatizar algunos comportamientos inteligentes
 humanos.
 Es una disciplica que estudia el comportamiento inteligente y sus implementacio
nes, así como su impacto en la sociedad humana.
\end_layout

\begin_deeper
\begin_layout Standard
\align left
Handbook - Research on E-Business Standards and Protocols: Documents, Data
 and Advanced Web Technologies
\end_layout

\end_deeper
\begin_layout Itemize
\align left
Sistema que incorpora inteligencia en aplicaciones desarrolladas por máquinas.
 Efectúan búsqueda y optimización, junto con habilidades de aprendizaje.
 También ejecutan tareas complejas automatizadas, que no son posibles en
 el paradigma de computación tradicional
\end_layout

\begin_deeper
\begin_layout Standard
\align left
Handbook - Research on Artificial Intelligence Techniques and Algorithms
\end_layout

\end_deeper
\begin_layout Itemize
\align left
Sistema con un conjunto coherente de componentes y subsistemas que trabajan
 conjuntamente para llevar a cabo actividades dirigidas por un objetivo
\end_layout

\begin_deeper
\begin_layout Standard
\align left
Encyclopedia of Artificial Intelligence
\end_layout

\end_deeper
\begin_layout Itemize
\align left
Sistema que da respuestas apropiadas de resolución de problemas a problemas
 recibidos como inputs, aunque esos inputs sean nuevos e inesperados.
 Los trabajos de estos sistemas se suelen describir con analogias con sistemas
 biológicos.
 Deben usar la intuición, experiencia pasada, suposiciones, reglas de oro,
 así como reconocer y correlacionar patrones generales instantáneamente,
 en lugar de secuencialmente.
 Estos sistemas pueden aprender y generalizar a partir de situaciones particular
es observando el comportamiento actual del sistema.
 Operadores humanos expertos pueden traducir la incertidumbre de sus proceso
 mental de razonamiento a acciones de control efectivas y pueden explicar
 sus acciones, aunque sea de forma imprecisa y mediante características
 cualitativas.
 Para que un sistema sea más inteligente debe poder razonar de forma imprecisa
 e incierta, tal y como hacemos los humanos
\end_layout

\begin_deeper
\begin_layout Standard
\align left
Fuzzy Control of Industrial Systems, theory and applications
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Los problemas y los procesos de búsqueda
\end_layout

\begin_layout Standard
\align left
No existe un algoritmo determinista general para resolver problemas porque
 los problemas son complejos, el mundo es cambiante y no totalmente conocido.
\end_layout

\begin_layout Standard
\align left
Hay técnicas específicas para la resolución de problemas concretos, pero
 estamos interesados en analizar el conjunto de métodos de resolución de
 problemas que consideramos más generales.
\end_layout

\begin_layout Standard
\align left
Para aprender a diseñar 
\series bold
sistemas de resolución de problemas
\series default
 es necesario analizar los elementos generales de cualquier sistema que
 permita encontrar soluciones a problemas.
 Esto es útil para abordar nuevos problemas de manera formalizada y sistemática.
\end_layout

\begin_layout Standard
\align left
Los elementos principales de los sistemas de resolución de problemas son:
\end_layout

\begin_layout Itemize
\align left

\series bold
Representación
\series default
: describe el dominio del problema, el objetivo final que se desea alcanzar
 y la situación inicial
\end_layout

\begin_layout Itemize
\align left

\series bold
Operadores
\series default
: transforman la situación del problema, o dividen un problema en varios
 subproblemas
\end_layout

\begin_layout Itemize
\align left

\series bold
Estrategia de control
\series default
: selecciona el operador a aplicar, en cada situación del problema
\end_layout

\begin_layout Itemize
\align left

\series bold
Solución de un problema
\series default
: será una secuencia adecuada de operadores que conduce a su resolución
\end_layout

\begin_layout Subsection
Representación
\end_layout

\begin_layout Standard
Los métodos de representación de problemas pueden estar basados en formulación
 en el espacio de estados o formulación mediante reducción.
\end_layout

\begin_layout Subsubsection
Formulación en el Espacio de Estados
\end_layout

\begin_layout Standard
\align left
Un 
\series bold
estado
\series default
 es una representación completa de la situación del problema en un momento
 dado.
 Los 
\series bold
operadores
\series default
 son acciones que pueden transformar un estado en otro.
\end_layout

\begin_layout Standard
\align left
Encontramos distintos tipos de estado:
\end_layout

\begin_layout Itemize
\align left

\series bold
estado inicial
\series default
: es la situación inicial del problema
\end_layout

\begin_layout Itemize
\align left

\series bold
estado final (meta, objetivo)
\series default
: configuración determinada que representa el objetivo deseado
\end_layout

\begin_layout Itemize
\align left

\series bold
estados intermedios
\series default
: son los que se obtienen al aplicar los operadores, partiendo del estado
 inicial
\end_layout

\begin_layout Standard
\align left
Un problema representado mediante estados se especifica como una terna 
\begin_inset Formula $\left(S,O,G\right)$
\end_inset

 donde 
\begin_inset Formula $S$
\end_inset

 y 
\begin_inset Formula $G$
\end_inset

 son conjuntos de estados iniciales y finales, y 
\begin_inset Formula $O$
\end_inset

 es un conjunto de operadores.
\end_layout

\begin_layout Standard
\align left
Una 
\series bold
estrategia
\series default
 define una solución o trayectoria en el espacio de estados.
 Equivale a la secuencia de operadores utilizadas.
\end_layout

\begin_layout Subsubsection
Formulación mediante Reducción
\end_layout

\begin_layout Standard
Este esquema responde a la posibilidad de que el problema se puede descomponer
 en subproblemas más pequeños.
 El principal elemento es la descripción del problema a resolver y la dinámica
 de resolución consiste en su descomposición en subproblemas más simples.
\end_layout

\begin_layout Itemize

\series bold
Situación inicial
\series default
: definida por la formulación del problema y un conjunto de operadores o
 transformadores del problema
\end_layout

\begin_layout Itemize

\series bold
Descripción inicial
\series default
: se resuelve por aplicación de una secuencia de transformaciones que dividen
 el problema en subproblemas, hasta obtener subproblemas sencillos de resolución
 inmediata
\end_layout

\begin_layout Standard
Un operador puede transformar un problema en:
\end_layout

\begin_layout Itemize
varios problemas secundarios, que deberán ser todos resueltos y ensamblados
 para dar solución al problema original.
 Por ejemplo, A se resuelve si se resuelven B y C.
\end_layout

\begin_layout Itemize
varios sub-problemas alternativos, que con encontrar la solución a uno de
 ellos nos dan la solución al problema original.
 Por ejemplo, A se resuelve si se resuelve B o se resuelve C.
\end_layout

\begin_layout Subsection
Características de los problemas
\end_layout

\begin_layout Standard
Para escoger la combinación más apropiada de métodos para resolver un problema,
 debemos analizar el problema desde varias perspectivas:
\end_layout

\begin_layout Itemize

\series bold
Problemas descomponibles
\series default
: son aquellos que pueden ser descompuestos en subproblemas más simples
\end_layout

\begin_layout Itemize

\series bold
Problemas recuperables
\series default
: son aquellos en los que, a partir de la solución, podemos inferir el estado
 inicial mediante procedimientos de razonamiento
\end_layout

\begin_layout Itemize

\series bold
Problemas de cualquier o mejor camino
\series default
: puede ser que busquemos una solución cualquiera o que busquemos la mejor
 entre todas las posibles
\end_layout

\begin_layout Itemize

\series bold
Consistencia y papel del conocimiento
\series default
: es útil preguntarse si el conocimiento del que disponemos sobre el problema
 es consistente, así como determinar si necesitamos una gran cantidad de
 conocimiento para resolverlo o bien solo es importante para restringir
 la búsqueda
\end_layout

\begin_layout Subsubsection
Características de los procesos de búsqueda
\end_layout

\begin_layout Standard
\align left
Existen muchos problemas para los que no se conoce (o ni siquiera se puede
 conocer) un algoritmo de resolución.
\end_layout

\begin_layout Standard
\align left
Un 
\series bold
espacio de estados
\series default
 puede tratarse como un árbol o un grafo dirigido, donde los 
\series bold
nodos
\series default
 contienen los estados y los 
\series bold
arcos
\series default
 representan a los operadores del problema.
 La 
\series bold
solución del problema
\series default
 es un camino desde un nodo inicial a uno final.
 
\end_layout

\begin_layout Standard
\align left
El número de operadores determina el grado de ramifiación del árbol que
 representa el problema.
\end_layout

\begin_layout Standard
\align left
El 
\series bold
nodo raíz
\series default
 se corresponde con el estado inicial, los 
\series bold
nodos finales
\series default
 irán asociados con los objetivos o metas.
 Según la presencia de nodos finales podemos distinguir tres casos:
\end_layout

\begin_layout Itemize
\align left
No hay nodos finales
\end_layout

\begin_layout Itemize
\align left
Solo hay un nodo final
\end_layout

\begin_layout Itemize
\align left
Hay varios nodos finales.
 En este caso es posible que se deba definir un mecanismo de comparación
 para elegir la mejor solución
\end_layout

\begin_layout Standard
\align left
La diferencia entre un grafo y un árbol es que en los grafos diversos caminos
 pueden llegar a un mismo nodo.
 El 
\series bold
problema de los árboles
\series default
 es que, frecuentemente se genera el mismo nodo en caminos distintos, procesándo
lo más de una vez.
 El 
\series bold
problema de los grafos
\series default
 es que pueden aparecer ciclos en la búsqueda, por lo que es más difícil
 probar que el método termina.
\end_layout

\begin_layout Standard
\align left
Al buscar en un grafo en lugar de un árbol reducimos el esfuerzo que se
 invierte explorando el mismo camino varias veces, pero aumenta el esfuerzo
 cada vez que se genera un nuevo nodo, para ver si ya había sido generado.
\end_layout

\begin_layout Standard
\align left
La elección depende del problema: si es muy probable que se genere el mismo
 nodo en varios caminos, es mejor utilizar un grafo.
 Si los nodos no suelen duplicarse es mejor utilizar un árbol.
\end_layout

\begin_layout Standard
La representación por 
\series bold
reducción
\series default
 también puede tratarse como un árbol o grafo.
 En esta ocasión se introduce la estructura de 
\series bold
árbol Y/O
\series default
, que se caracteriza por:
\end_layout

\begin_layout Itemize
cada nodo contiene un problema simple o un conjunto de problemas
\end_layout

\begin_layout Itemize
un nodo que no se descompone es un 
\series bold
nodo terminal
\end_layout

\begin_layout Itemize
un nodo terminal con solución inmediata se denomina 
\series bold
primitiva
\end_layout

\begin_layout Itemize
si por cada posible operador se genera un conjunto de subproblemas de solución
 alternativa, entonces se genera un 
\series bold
nodo O
\end_layout

\begin_layout Itemize
si la aplicación de un operador genera diversos subproblemas, siendo necesaria
 la resolución de todos ellos, entonces se produce un 
\series bold
nodo Y
\end_layout

\begin_layout Standard
La resolución de un problema representado por un árbol Y/O está asociada
 con la resolución del nodo raíz.
 Un nodo será 
\series bold
resoluble
\series default
 si:
\end_layout

\begin_layout Itemize
es un nodo primitiva, o
\end_layout

\begin_layout Itemize
es un nodo Y y sus sucesores son todos resolubles, o
\end_layout

\begin_layout Itemize
es un nodo O y al menos uno de sus sucesores es resoluble
\end_layout

\begin_layout Standard
Si no se verifica alguna de estas condiciones, el nodo será 
\series bold
irresoluble
\series default
, o sea, si:
\end_layout

\begin_layout Itemize
es un nodo terminal pero no es primitiva, o
\end_layout

\begin_layout Itemize
es un nodo Y, y alguno de sus sucesores es irresoluble, o
\end_layout

\begin_layout Itemize
es un nodo O, y todos sus sucesores son irresolubles
\end_layout

\begin_layout Subsection
Razonamiento hacia delante y hacia atrás
\end_layout

\begin_layout Itemize
En el 
\series bold
razonamiento hacia delante 
\series default
se aplican los operadores a la estructura inicial, provocando una transformación
 de su representación, y se repite el proceso.
 El problema tendrá solución si es posible alcanzar el objetivo
\end_layout

\begin_layout Itemize
En el 
\series bold
razonamiento hacia atrás
\series default
 se parte de la configuración final y se aplican los operadores inversos
 al objetivo.
 El problema tendrá solución si es posible alcanzar la configuración inicial.
\end_layout

\begin_layout Itemize
Existe la posibilidad de mezclar ambos enfoques: 
\series bold
búsqueda bidireccional
\end_layout

\begin_layout Subsection
Selección de operadores
\end_layout

\begin_layout Standard
\align left
Es importante determinar qué operador se debe escoger entre los distintos
 posibles.
 
\series bold
Emparejar
\series default
 es determinar los operadores aplicables a la situación actual.
 Para ello, se comprueba si se verifican las precondiciones de los operadores.
\end_layout

\begin_layout Standard
\align left
A menudo, el emparejamiento entre una situación particular y las precondiciones
 de un operador involucra un proceso complejo de búsqueda.
\end_layout

\begin_layout Standard
\align left
Una clase sencilla de emparejamiento que puede requerir una búsqueda extensiva
 surge cuando las precondiciones contienen variables.
\end_layout

\begin_layout Subsection
Heurísticas.
 Funciones heurísticas de evaluación
\end_layout

\begin_layout Standard
\align left
Una 
\series bold
heurística
\series default
 es una estrategia, método o criterio usado para hacer más sencilla la resolució
n de problemas difíciles.
\end_layout

\begin_layout Standard
\align left
El 
\series bold
conocimiento heurístico
\series default
 es aquel usado por los humanos para resolver problemas complejos.
\end_layout

\begin_layout Standard
\align left
Una 
\series bold
técnica heurística
\series default
 es un conjunto de pasos que deben realizarse para identificar una solución
 de alta calidad con pocos recursos, aunque no podamos garantizar encontrarla.
 Existen técnicas heurísticas de aplicación muy general y otras que representan
 conocimientos específicos que son relevantes para la solución de un problema.
\end_layout

\begin_layout Standard
\align left
La 
\series bold
función heurística
\series default
 estima lo próximo que se encuentra un estado de un estado objetivo.
\end_layout

\begin_layout Subsection
La exploración como paradigma de resolución y búsqueda
\end_layout

\begin_layout Standard
La 
\series bold
exploración
\series default
 es un método de resolución tentativo (basado en el criterio de prueba y
 error), en el que se exige la selección de alguna opción entre un conjunto
 de posibilidades y no existe un principio determinista para definir esta
 elección.
 Es útil ante problemas con las siguientes propiedades:
\end_layout

\begin_layout Itemize
se desconoce la posible trayectoria que puede conducir a la solución
\end_layout

\begin_layout Itemize
tales trayectorias no se pueden hallar de forma sistemática o, en muchos
 problemas, su tiempo de cálculo puede exceder lo razonable
\end_layout

\begin_layout Itemize
en el mundo real son resueltos por los seres humanos usando principio heurístico
s, que por su naturaleza son de difícil justificación
\end_layout

\begin_layout Standard

\series bold
Inconvenientes:
\end_layout

\begin_layout Itemize
La complejidad, que en algunos métodos crece exponencialmente con el tamaño
 del problema
\end_layout

\begin_layout Standard

\series bold
Ventajas
\end_layout

\begin_layout Itemize
Es un método universal de resolución de problemas
\end_layout

\begin_layout Itemize
Se han desarrollado métodos para incorporar conocimiento heurístico adecuado,
 lo que tiene como consecuencia que aumente su eficacia
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Estrategias básicas de búsqueda
\end_layout

\begin_layout Standard
\align left
Para resolver un problema debemos:
\end_layout

\begin_layout Itemize
\align left

\series bold
establecer un objetivo
\series default
: estados que satisfacen los criterios para ser meta o subproblemas establecidos
 como primitivos
\end_layout

\begin_layout Itemize
\align left

\series bold
aplicar un método de búsqueda
\series default
: proceso para examinar y encontrar qué secuencia de accioner permite obtener
 un estado objetivo o dar como resuelto el problema
\end_layout

\begin_layout Standard
\align left
En general, un diseño simple de este proceso debe 
\begin_inset Quotes eld
\end_inset

formular, buscar, ejecutar
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=Java,numbers=left,stepnumber=5,morekeywords={&quot;función&quot;, &quot;devuelve&quot;, &quot;entradas&quot;, &quot;estático&quot;, &quot;repetir&quot;, &quot;devolver&quot;}"
inline false
status open

\begin_layout Plain Layout

función RESOLVER-PROBLEMAS(percepción) devuelve una acción
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

entradas: percepción
\end_layout

\begin_layout Plain Layout

estático: problema: una formulación del problema
\end_layout

\begin_layout Plain Layout

		sec: una secuencia de acciones
\end_layout

\begin_layout Plain Layout

		estado-actual
\end_layout

\begin_layout Plain Layout

		objetivo
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

repetir
\end_layout

\begin_layout Plain Layout

	problema <- FORMULAR-PROBLEMA()
\end_layout

\begin_layout Plain Layout

	inicio <- FORMULAR-INICIO()
\end_layout

\begin_layout Plain Layout

	objetivo <- FORMULAR-OBJETIVO()
\end_layout

\begin_layout Plain Layout

	sec <- BUSQUEDA(problema)
\end_layout

\begin_layout Plain Layout

	accion <- PRIMERO(sec)
\end_layout

\begin_layout Plain Layout

	devolver accion
\end_layout

\begin_layout Plain Layout

	estado-actual <- ACTUALIZAR(estado-actual,percepción)
\end_layout

\begin_layout Plain Layout

		
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
Se presupone un entorno estático porque la formulación y la búsqueda del
 problema se hace sin prestar atención a los cambios que pueden ocurrir
 en el entorno.
 También que se conoce el estado inicial.
 Que el entorno es discreto, o sea, que se pueden enumerar las líneas de
 acción alternativas, y que el entorno es determinista, es decir, que las
 soluciones son secuencias de acciones y se ejecutan sin prestar atención
 a las percepciones.
\end_layout

\begin_layout Standard
\align left
Independientemente de la representación utilizada (por espacio de estados
 o reducción) la estructura subyacente será un árbol, un grafo dirigido
 o un Y/O, descrito por los nodos y los arcos.
 Los nodos serán estructuras de 5 componentes, como mínimo:
\end_layout

\begin_layout Itemize
\align left
estado o subproblema: identifica al nodo
\end_layout

\begin_layout Itemize
\align left
nodo padre: nodo en el árbol de búsqueda que ha generado este nodo
\end_layout

\begin_layout Itemize
\align left
acción: el operador que se aplicará al padre para generar el nodo
\end_layout

\begin_layout Itemize
\align left
costo del camino: el costo 
\begin_inset Formula $g\left(n\right)$
\end_inset

 de un camino, indicado por los punteros a los padres
\end_layout

\begin_layout Itemize
\align left
profundidad: el número de pasos a lo largo del camino
\end_layout

\begin_layout Standard
\align left
En el proceso de búsqueda, definimos dos conjuntos de nodos relevantes:
\end_layout

\begin_layout Itemize
\align left

\series bold
Frontera:
\series default
 colección de nodos generados pero que aún no han sido expandidos
\end_layout

\begin_layout Itemize
\align left

\series bold
Cerrados:
\series default
 colección de nodos generados y expandidos
\end_layout

\begin_layout Standard
\align left
La estrategia de búsqueda será un función que selecciona de la frontera
 el siguiente nodo a expandir.
\end_layout

\begin_layout Standard
\align left
La colección de nodos se implementará como una cola con las siguientes operacion
es:
\end_layout

\begin_layout Itemize
\align left
VACIA(cola): true si cola está vacía
\end_layout

\begin_layout Itemize
\align left
BORRAR(cola,criterio): elimina de la cola los elementos que verifican el
 criterio
\end_layout

\begin_layout Itemize
\align left
BORRAR-PRIMERO(cola): pop
\end_layout

\begin_layout Itemize
\align left
INSERTA(elemento,cola)
\end_layout

\begin_layout Itemize
\align left
INSERTA-TODO(elementos,cola)
\end_layout

\begin_layout Standard
\align left
Se denomina 
\series bold
abstracción 
\series default
al proceso de eliminar detalles innecesarios de una representación.
 Es importante para resolver problemas porque debemos simplificar un problema
 lo máximo posible, hasta quedarnos únicamente con el problema en sí mismo.
\end_layout

\begin_layout Subsubsection*
Midiendo el rendimiento de la resolución del problema
\end_layout

\begin_layout Standard
\align left
Un método de resolución de problemas devuelve bien una solución, bien un
 fallo.
 Para evaluar su rendimiento, atendemos a cuatro dimensiones:
\end_layout

\begin_layout Itemize
\align left

\series bold
completitud
\series default
: se pregunta sobre las garantías de que, existiendo solución, se encuentre
\end_layout

\begin_layout Itemize
\align left

\series bold
optimalidad
\series default
: sobre la obtención de la solución óptima
\end_layout

\begin_layout Itemize
\align left

\series bold
complejidad en tiempo
\series default
: cuánto tarda en encontrar la solución
\end_layout

\begin_layout Itemize
\align left

\series bold
complejidad en espacio
\series default
: cuánto espacio necesita el método
\end_layout

\begin_layout Standard
\align left
La complejidad se suele considerar con respecto a alguna medida de la dificultad
 del problema.
 Debido a la estructura de árbol de búsqueda, normalmente expresaremos la
 complejidad en términos del 
\series bold
factor de ramificación
\series default
, 
\begin_inset Formula $b$
\end_inset

, la 
\series bold
profundidad del nodo objetivo más superficial
\series default
, 
\begin_inset Formula $d$
\end_inset

, y la 
\series bold
longitud máxima
\series default
, 
\begin_inset Formula $m$
\end_inset

, de cualquier camino en el espacio de búsqueda.
\end_layout

\begin_layout Subsection
Estrategia sobre una representación por espacio de estados
\end_layout

\begin_layout Subsubsection
Búsqueda no informada o a ciegas
\end_layout

\begin_layout Standard
\align left
No se hace uso de información específica del problema o del dominio concreto
 de este.
 En esta situación se adopta algún criterio arbitrario, pero fijo.
\end_layout

\begin_layout Standard
\align left
Un problema de búsqueda consta de cuatro componentes:
\end_layout

\begin_layout Enumerate
\align left
El estado inicial
\end_layout

\begin_layout Enumerate
\align left
Las posibles acciones: la formulación más común es
\end_layout

\begin_deeper
\begin_layout Itemize
\align left
SUCESOR(x): devuelve conjuntos de pares ordenados <acción, sucesor>, que
 indican que si realizamos 
\begin_inset Quotes eld
\end_inset

acción
\begin_inset Quotes erd
\end_inset

, obtendremos 
\begin_inset Quotes eld
\end_inset

sucesor
\begin_inset Quotes erd
\end_inset

.
 Implícitamente, el estado inicial y esta función definen el espacio de
 estados.
\end_layout

\begin_layout Standard
\align left
Un 
\series bold
camino
\series default
 es un conjunto de estados conectados por una secuencia de acciones.
\end_layout

\end_deeper
\begin_layout Enumerate
\align left
El test objetivo, que determinará si un estado es un estado objetivo o no
\end_layout

\begin_layout Enumerate
\align left
Una 
\series bold
función costo
\series default
, que asigna un coste numérico a cada camino:
\end_layout

\begin_deeper
\begin_layout Enumerate
\align left

\series bold
coste individual
\series default
, coste no negativo de una acción 
\begin_inset Formula $a$
\end_inset

 de 
\begin_inset Formula $x$
\end_inset

 a 
\begin_inset Formula $y$
\end_inset

, 
\begin_inset Formula $c\left(x,y\right)=c\left(x,a,y\right)$
\end_inset


\end_layout

\begin_layout Enumerate
\align left

\series bold
coste del camino
\series default
, suma de los costes individuales de los nodos que forman el camino
\end_layout

\begin_layout Standard
\align left
La calidad de la solución se mide por la función costo del camino.
 Una solución óptima será aquella con el costo más pequeño entre todas las
 soluciones (minimización).
\end_layout

\end_deeper
\begin_layout Subsubsection*
Búsqueda sobre árboles
\end_layout

\begin_layout Standard
\align left
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función BUSQUEDA-ARBOLES(problema,frontera) devuelve {solución o fallo}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

frontera <- INSERTA(HACER-NODO(ESTADO-INICIAL(problema)),frontera)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bucle hacer
\end_layout

\begin_layout Plain Layout

	si VACIA(frontera) entonces devolver fallo
\end_layout

\begin_layout Plain Layout

	nodo <- BORRAR-PRIMERO(frontera)
\end_layout

\begin_layout Plain Layout

	si TEST-OBJETIVO(problema, ESTADO(nodo)) entonces devolver SOLUCION(nodo)
\end_layout

\begin_layout Plain Layout

	frontera <- INSERTAR-NODO(EXPANDIR(nodo,problema),frontera)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

función EXPANDIR(nodo, problema) devuelve Conjunto<nodos>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

sucesores <- conjunto_vacío
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para cada (accion, resultado) en SUCESOR(problema, ESTADO(nodo)) hacer
\end_layout

\begin_layout Plain Layout

	s <- nuevo nodo
\end_layout

\begin_layout Plain Layout

	s.estado <- resultado
\end_layout

\begin_layout Plain Layout

	s.padre <- nodo
\end_layout

\begin_layout Plain Layout

	s.accion <- accion
\end_layout

\begin_layout Plain Layout

	s.costo <- nodo.costo + COSTO-INDIVIDUAL(nodo,accion,s)
\end_layout

\begin_layout Plain Layout

	s.profundidad <- nodo.profundidad + 1
\end_layout

\begin_layout Plain Layout

	sucesores <- ADD(s, sucesores)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

devolver sucesores
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
Las estrategias se distinguen por el orden de expansión de los nodos.
\end_layout

\begin_layout Subsubsection*
Búsqueda primero en anchura
\end_layout

\begin_layout Standard
Se implementa llamando a BUSQUEDA-ARBOLES(problema, COLA-FIFO()).
 Se expanden todos los nodos de un nivel, antes de expandir los del siguiente.
\end_layout

\begin_layout Itemize
completa si 
\begin_inset Formula $b$
\end_inset

 es finita
\end_layout

\begin_layout Itemize
el nodo objetivo más superficial no es necesariamente el óptimo, es óptima
 si la función coste es creciente con el nivel de profundidad
\end_layout

\begin_layout Itemize
suponiendo un factor de ramificación constante, se generan
\begin_inset Formula 
\[
b+b^{2}+...+b^{d}+\left(b^{b+1}-b\right)=O\left(b^{d+1}\right)
\]

\end_inset

nodos.
 Esta es tanto la complejidad de tiempo como de espacio
\end_layout

\begin_layout Subsubsection*
Búsqueda de costo uniforme
\end_layout

\begin_layout Standard
Se implementa llamando a BUSQUEDA-ARBOLES(problema, frontera_O()), donde
 frontera_O() está ordenado por el costo 
\begin_inset Formula $g$
\end_inset

, de menor a mayor.
\end_layout

\begin_layout Itemize
completa si 
\begin_inset Formula $g\left(x,y\right)\geq\varepsilon>0,\ \forall x,y$
\end_inset

 con 
\begin_inset Formula $y$
\end_inset

 descendiente de 
\begin_inset Formula $x$
\end_inset

.
 Ya que, si hubiera alguna acción con coste 0, que deriva en el mismo camino
 del que partimos, obtendríamos un bucle infinito.
 Cuando todos los costes son mayores que una cierta cantidad, los costes
 siempre aumentan y esto no puede suceder.
\end_layout

\begin_layout Itemize
en tal caso también es óptima
\end_layout

\begin_layout Itemize
la complejidad en tiempo y espacio es 
\begin_inset Formula $O\left(b^{\left[\frac{C^{*}}{\varepsilon}\right]}\right)$
\end_inset

, donde 
\begin_inset Formula $C^{*}$
\end_inset

 es el costo de la solución óptima
\end_layout

\begin_layout Subsubsection*
Búsqueda primero en profundidad
\end_layout

\begin_layout Standard
Se implementa llamando a BUSQUEDA-ARBOLES(problema, COLA_LIFO()).
 Ahora expandimos el nodo más profundo en la frontera, antes de proceder
 con los demás.
\end_layout

\begin_layout Itemize
no es completa en general
\end_layout

\begin_layout Itemize
por tanto tampoco puede ser óptima
\end_layout

\begin_layout Itemize
la complejidad en tiempo es 
\begin_inset Formula $O\left(b^{m}\right)$
\end_inset


\end_layout

\begin_layout Itemize
la complejidad en espacio es 
\begin_inset Formula $O\left(bm\right)\sim O\left(m\right)$
\end_inset


\end_layout

\begin_layout Subsubsection*
Búsqueda de profundidad limitada
\end_layout

\begin_layout Standard
Es una búsqueda primero en profundidad, pero con un límite de profundidad
 
\begin_inset Formula $l$
\end_inset

 predeterminado.
 Este límite resuelve un problema de la BPP, la generación de un camino
 infinito que no lleva a ninguna solución, pero introduce una fuente adicional
 de incompletitud si 
\begin_inset Formula $l<d$
\end_inset

, pues en tal caso no vamos a llegar suficientemente profundo como para
 encontrar la solución.
\end_layout

\begin_layout Itemize
completa si 
\begin_inset Formula $l\geq d$
\end_inset


\end_layout

\begin_layout Itemize
no es óptima, podría haber mejores soluciones por debajo de 
\begin_inset Formula $l$
\end_inset


\end_layout

\begin_layout Itemize
complejidad en tiempo 
\begin_inset Formula $O\left(b^{l}\right)$
\end_inset


\end_layout

\begin_layout Itemize
complejidad en espacio 
\begin_inset Formula $O\left(bl\right)\sim O\left(b\right)$
\end_inset


\end_layout

\begin_layout Subsubsection*
Búsqueda primero en profundidad con profundidad iterativa
\end_layout

\begin_layout Standard
Es una búsqueda en profundidad limitada, pero en la que aumentamos el límite
 hasta encontrar el objetivo:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función BUSQUEDA-PROFUNDIDAD-ITERATIVA(problema) devuelve {solución o fallo}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

entradas: problema
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para profundidad <- 0 a infinito hacer
\end_layout

\begin_layout Plain Layout

	resultado <- BUSQUEDA-PROFUNDIDAD-LIMITADA(problema,profundidad)
\end_layout

\begin_layout Plain Layout

	si TEST-OBJETIVO(resultado, problema) entonces devolver resultado
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
completa
\end_layout

\begin_layout Itemize
óptima
\end_layout

\begin_layout Itemize
complejidad en tiempo 
\begin_inset Formula $O\left(b^{d}\right)$
\end_inset


\end_layout

\begin_layout Itemize
complejidad en espacio 
\begin_inset Formula $O\left(bd\right)\sim O\left(b\right)$
\end_inset


\end_layout

\begin_layout Standard
Si 
\begin_inset Formula $b$
\end_inset

 es constante, generar nodos repetidamente no es muy costoso.
\end_layout

\begin_layout Subsubsection*
Comparación de las estrategias de búsqueda no informada
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Criterio
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
BPA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Costo Uniforme
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
BPP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
BPPL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
BPPIt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Completa
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sí*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sí*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sí*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Optima
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sí*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sí
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
No
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sí*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Tiempo
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(b^{d+1}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(b^{\left[\frac{C^{*}}{\varepsilon}\right]}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(b^{m}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(b^{l}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(b^{d}\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Espacio
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(b^{d+1}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(b^{\left[\frac{C^{*}}{\varepsilon}\right]}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(bm\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(bl\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $O\left(bd\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Evitar estados repetidos 
\begin_inset Formula $\boldsymbol{\rightarrow}$
\end_inset

 Búsqueda sobre grafos
\end_layout

\begin_layout Standard
\align left
Para algunos problemas, los árboles de búsqueda son infinitos.
 Si no se detectan los estados repetidos se puede provocar que un problema
 resoluble llegue a ser irresoluble.
 Para ello:
\end_layout

\begin_layout Itemize
\align left
creamos una nueva estructura de datos que almacene loos nodos expandidos
 y que no acepta repetidos
\end_layout

\begin_layout Itemize
\align left
en problemas con muchos estados repetidos, la búsqueda en grafos es más
 eficiente que la búsqueda en árboles
\end_layout

\begin_layout Standard
\align left
El pseudocódigo sería:
\end_layout

\begin_layout Standard
\align left
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función BUSQUEDA-GRAFOS(problema, frontera) devuelve {solución o fallo}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

cerrado <- conjunto-vacio
\end_layout

\begin_layout Plain Layout

frontera <- INSERTAR(HACER-NODO(ESTADO-INICIAL(problema)),frontera)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bucle hacer
\end_layout

\begin_layout Plain Layout

	si VACIA(frontera) entonces devolver fallo
\end_layout

\begin_layout Plain Layout

	nodo <- BORRAR-PRIMERO(frontera)
\end_layout

\begin_layout Plain Layout

	si TEST-OBJETIVO(ESTADO(nodo), problema) entonces devolver SOLUCION(nodo)
\end_layout

\begin_layout Plain Layout

	su ESTADO(nodo) 
\backslash
notin cerrado entonces
\end_layout

\begin_layout Plain Layout

		cerrado <- ADD(cerrado,ESTADO(nodo))
\end_layout

\begin_layout Plain Layout

		frontera <- INSERTAR-TODO(EXPANDIR(nodo,problema),frontera)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
Podemos simplificar, evitando introducir en la frontera nodos ya expandidos
 o ya presentes, con menor coste.
 Es más eficiente en memoria pero necesita más comprobaciones.
\end_layout

\begin_layout Subsubsection
Búsqueda Heurística o informada
\end_layout

\begin_layout Standard
\align left
Las estrategias de búsqueda no informada encuentran soluciones generando
 sistemáticamente nuevos estados y probándolos con el test objetivo.
 Esto es muy ineficiente en problemas complejos.
 Como alternativa, podríamos intentar diseñar algún mecanismo que permita
 dirigir la búsqueda hacia las zonas más prometedoras, y encontrar soluciones
 de una forma más eficiente.
\end_layout

\begin_layout Standard
\align left
Las 
\series bold
heurísticas
\series default
 son criterios, reglas, puntuaciones o métodos que ayudan a decidir cuál
 es la mejor alternativa o la más prometedora entre varias posibles, para
 alcanzar un determinado objetivo.
 Este mecanismo requiere disponer de conocimiento sobre el problema.
 Se utilizan para decidir qué nodo expandir a continuación, qué nodos sucesores
 son generadores y qué nodos no deben tenerse en cuenta.
\end_layout

\begin_layout Standard
\align left
Las 
\series bold
estrategias de búsqueda heurística
\series default
:
\end_layout

\begin_layout Itemize
\align left
utilizan algún mecanismo heurístico para dirigir la búsqueda hacia las zonas
 más prometedoras y encontrar soluciones de una manera más eficiente
\end_layout

\begin_layout Itemize
\align left
existen diversas estrategias, basadas en los métodos básicos y subyacentes
 para la búsqueda no informada
\end_layout

\begin_layout Itemize
\align left
pueden encontrar soluciones de una forma más eficiente
\end_layout

\begin_layout Subsubsection*
Búsqueda Primero el Mejor
\end_layout

\begin_layout Standard
\align left
Es la estrategia general y más básica de búsqueda informada.
 Corresponde a un caso particular del método general de BUSQUEDA-ARBOLES/GRAFOS.
\end_layout

\begin_layout Standard
\align left
Hace uso de una 
\series bold
función de evaluación 
\series default

\begin_inset Formula $f\left(n\right)$
\end_inset

 que, a cada nodo 
\begin_inset Formula $n$
\end_inset

, le asigna un valor numérico que indique lo prometedor que es el nodo para
 ser expandido.
 Este valor se utiliza para ordenar la lista frontera, de tal forma que
 los nodos más prometedores se encuentren al principio.
 Se suele interpretar esta función como una distancia al objetivo, por lo
 que se considera que 
\begin_inset Formula 
\[
n\text{ es más prometedor que \ensuremath{m}}\iff f\left(n\right)\leq f\left(m\right)
\]

\end_inset

 Puede implementarse con una cola con prioridad, de orden ascendente con
 
\begin_inset Formula $f$
\end_inset

-valores (las evaluaciones mediante 
\begin_inset Formula $f$
\end_inset

).
\end_layout

\begin_layout Standard
\align left
Un componente clave es la creación de una 
\series bold
función heurística
\series default
 
\begin_inset Formula $h\left(n\right)$
\end_inset

, que indicará el coste estimado del camino más barato desde el nodo 
\begin_inset Formula $n$
\end_inset

 a un nodo objetivo y, si 
\begin_inset Formula $n$
\end_inset

 es un nodo objetivo, entonces verificará 
\begin_inset Formula $h\left(n\right)=0$
\end_inset

.
 Este tipo de funciones representan la manera más común de transmitir el
 conocimiento adicional del problema al método de búsqueda.
\end_layout

\begin_layout Subsubsection*
Búsqueda primero el mejor greedy (avara o voraz)
\end_layout

\begin_layout Standard
\align left
Expande el nodo que estima más cercano al objetivo.
 Para ello, se establece
\begin_inset Formula 
\[
f\left(n\right)=h\left(n\right)
\]

\end_inset


\end_layout

\begin_layout Itemize
\align left
Complejidad en tiempo y espacio: 
\begin_inset Formula $O\left(b^{m}\right)$
\end_inset

.
 Aunque con una buena 
\begin_inset Formula $h$
\end_inset

 se reduce la complejidad considerablemente.
\end_layout

\begin_layout Subsubsection*
Búsqueda A*
\end_layout

\begin_layout Standard
\align left
En esta ocasión consideramos que está bien tener en cuenta tanto la distancia
 estimada al objetivo, como el coste del camino recorrido hasta ahora, y
 trataremos de minimizar la suma de ambas cantidades, es decir, usaremos
\begin_inset Formula 
\[
f\left(n\right)=g\left(n\right)+h\left(n\right)
\]

\end_inset

 donde 
\begin_inset Formula $g\left(n\right)$
\end_inset

 es el coste del camino desde el inicio hasta 
\begin_inset Formula $n$
\end_inset

 y 
\begin_inset Formula $h\left(n\right)$
\end_inset

 el coste estimado desde 
\begin_inset Formula $n$
\end_inset

 hasta el objetivo.
 Por tanto, 
\begin_inset Formula $f\left(n\right)$
\end_inset

 representa el coste estimado desde el inicio hasta el objetivo pasando
 por 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Vamos a ver ahora que si 
\begin_inset Formula $h$
\end_inset

 satisface ciertas propiedades, A* será completa y óptima.
\end_layout

\begin_layout Standard
\align left
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
Una heurística 
\begin_inset Formula $h\left(n\right)$
\end_inset

 es 
\series bold
admisible
\series default
 si nunca sobrestima el coste real de alcanzar el objetivo desde un nodo
 
\begin_inset Formula $n$
\end_inset

, 
\begin_inset Formula $h^{*}\left(n\right)$
\end_inset

, o sea
\begin_inset Formula 
\[
h\ \text{admisible}\iff h\left(n\right)\leq h^{*}\left(n\right),\ \forall n
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
Esta propiedad implica que, al estimar el coste del camino verdadero 
\begin_inset Formula $C^{*}\left(n\right)=g\left(n\right)+h^{*}\left(n\right)$
\end_inset

 mediante 
\begin_inset Formula $f\left(n\right)=g\left(n\right)+h\left(n\right)$
\end_inset

, se tendrá
\begin_inset Formula 
\[
f\left(n\right)\leq C^{*}\left(n\right)
\]

\end_inset

es decir, el coste estimado de alcanzar una solución pasando por 
\begin_inset Formula $n$
\end_inset

, nunca será mayor que el coste real de una solución que pasa por 
\begin_inset Formula $n$
\end_inset

.
 
\end_layout

\begin_layout Standard
\align left
Las heurísticas no admisibles son pesimistas, puesto que pueden descartar
 un sucesor porque piensan que es peor de lo que realmente es, lo que impide
 la optimalidad.
\end_layout

\begin_layout Standard
\align left
Por otro lado, las heurísticas admisibles son optimistas, suponen que el
 coste de resolver un problema es menor del coste real.
 Esto permite la optimalidad, un nodo del camino óptimo no puede parecer
 tan malo como para descartarlo.
 Así, tenemos el siguiente teorema, que asegura la 
\series bold
optimalidad de A* para BUSQUEDA-ARBOLES
\series default
:
\end_layout

\begin_layout Standard
\align left
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Teorema
\end_layout

\begin_layout Plain Layout
Si 
\begin_inset Formula $h$
\end_inset

 es una heurística admisible, entonces A* guiada por 
\begin_inset Formula $h$
\end_inset

 es óptima.
\end_layout

\end_inset


\end_layout

\begin_layout Proof
\align left
Sea 
\begin_inset Formula $C^{*}$
\end_inset

 el coste de la solución óptima y supongamos que tenemos en la frontera
 un nodo objetivo subóptimo, 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Proof
\align left
Entonces, como 
\begin_inset Formula $G$
\end_inset

 es subóptimo y 
\begin_inset Formula $h\left(G\right)=0$
\end_inset

, por ser este objetivo, se verifica
\begin_inset Formula 
\[
f\left(G\right)=g\left(G\right)+h\left(G\right)=g\left(G\right)>C^{*}
\]

\end_inset

 Consideremos, pues, un nodo 
\begin_inset Formula $n$
\end_inset

 en la frontera sobre un camino solución óptimo, es decir, que conduce a
 una solución con coste 
\begin_inset Formula $C^{*}$
\end_inset

.
 Entonces, como 
\begin_inset Formula $h$
\end_inset

 es admisible
\begin_inset Formula 
\[
f\left(n\right)=g\left(n\right)+h\left(n\right)\leq g\left(n\right)+h^{*}\left(n\right)=C^{*}
\]

\end_inset

 Por tanto, lo que obtenemos es que
\begin_inset Formula 
\[
f\left(n\right)\leq C^{*}<f\left(G\right)
\]

\end_inset

 y A* escogerá 
\begin_inset Formula $n$
\end_inset

 en lugar de 
\begin_inset Formula $G$
\end_inset

.
 Por lo que, en última instancia, devolverá la solución óptima.
\end_layout

\begin_layout Standard
\align left
¿Por qué es necesario que sea un árbol?
\end_layout

\begin_layout Standard
\align left
La respuesta es que los árboles generan una sola vez cada nodo, mientras
 que los grafos pueden crearlos varias veces y, si la función heurística
 solo verifica admisibilidad, podemos obtener soluciones subóptimas.
 Veamos un contraejemplo:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado1.png

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $h\left(n\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $h^{*}\left(n\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
En esta tabla vemos como 
\begin_inset Formula $h$
\end_inset

 es admisible, pues 
\begin_inset Formula $h\left(n\right)\leq h^{*}\left(n\right),\ \forall n$
\end_inset

, y se ve claro que la solución óptima es A-C-B-D, sin embargo, A* seguiría
 el siguiente proceso:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Frontera
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cerrados
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\left(1\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $B_{A}\left(4\right),C_{A}\left(5\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\left(1\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $C_{A}\left(5\right),D_{B}\left(6\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\left(1\right),B_{A}\left(4\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $D_{B}\left(6\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\left(1\right),B_{A}\left(4\right),C_{A}\left(5\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $A\left(1\right),B_{A}\left(4\right),C_{A}\left(5\right),D_{B}\left(6\right)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
Y nos da el camino subóptimo A-B-D.
 La clave se enceuntra en que, al cerrar 
\begin_inset Formula $C$
\end_inset

, detecta que 
\begin_inset Formula $B$
\end_inset

 ya está cerrado y no lo expande.
\end_layout

\begin_layout Standard
\align left
Tenemos dos posibilidades para abordar este obstáculo:
\end_layout

\begin_layout Itemize
\align left
Extender la BUSQUEDA-GRAFOS para que deseche el camino más caro cuando vuelve
 a generar un nodo ya cerrado.
 Esto añade cálculos complementarios pero garantiza optimalidad
\end_layout

\begin_layout Itemize
\align left
Exigir alguna propiedad, más estricta que la admisibilidad, a la heurística,
 de forma que podamos asegurar que el camino óptimo a cualquier estado repetido
 es siempre el primero que seguimos
\end_layout

\begin_layout Standard
\align left
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
Una heurística 
\begin_inset Formula $h$
\end_inset

 es 
\series bold
consistente
\series default
 si, y solo si, 
\begin_inset Formula 
\[
h\left(n\right)\leq K\left(n,a_{s},n'\right)+h\left(n'\right),\ \forall n,n'
\]

\end_inset

 donde 
\begin_inset Formula $K\left(n,a_{s},n'\right)$
\end_inset

 es el coste del camino de 
\begin_inset Formula $n$
\end_inset

 a 
\begin_inset Formula $n'$
\end_inset

 a través de la secuencia de acciones 
\begin_inset Formula $a_{s}$
\end_inset

.
 
\end_layout

\begin_layout Plain Layout
Es decir, es consistente si la estimación dada por 
\begin_inset Formula $h$
\end_inset

 no es mayor que el coste de ir de 
\begin_inset Formula $n$
\end_inset

 a otro nodo cualquiera más la estimación del coste desde ese otro nodo
 a la solución.
 Es una suerte de desigualdad triangular.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
Nótese que esta condición es más estricta que la admisibilidad.
 De hecho, fijémonos en el ejemplo anterior: hemos visto que 
\begin_inset Formula $h$
\end_inset

 era admisible, no obstante, nótese que 
\begin_inset Formula $h\left(C\right)=4$
\end_inset

 y que 
\begin_inset Formula $K\left(C,B\right)+h\left(B\right)=1+1=2$
\end_inset

, luego no es consistente
\end_layout

\begin_layout Standard
\align left
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
Una heurística 
\begin_inset Formula $h$
\end_inset

 es 
\series bold
monótona
\series default
 si, y solo si, 
\begin_inset Formula 
\[
h\left(n\right)\leq c\left(n,a,n'\right)+h\left(n'\right),\ \forall n,n',\ n'\text{ sucesor de }n
\]

\end_inset

 donde 
\begin_inset Formula $c\left(n,a,n'\right)$
\end_inset

 es el coste del arco que une 
\begin_inset Formula $n$
\end_inset

 con 
\begin_inset Formula $n'$
\end_inset

.
\end_layout

\begin_layout Plain Layout
O sea, es monótona si la estimación dada por 
\begin_inset Formula $h$
\end_inset

 no es mayor que el coste de ir a cualquier vecino más la estimación del
 coste desde ese vecino a la solución.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
Notemos ahora que la monotonía parece una condición más laxa que la consistencia
, pues debemos comprobar la misma condición, pero para menos nodos.
 No obstante, se puede demostrar que
\begin_inset Formula 
\[
h\ consistente\iff h\ monótona
\]

\end_inset

 lo cual facilita comprobar la consistencia, al solo necesitar comprobar
 la monotonía.
\end_layout

\begin_layout Proof
\align left
\begin_inset Formula $\left[\implies\right]$
\end_inset

 Obvio, si se verifica para cualquier nodo 
\begin_inset Formula $n'$
\end_inset

 del grafo, en particular se verifica para los vecinos de 
\begin_inset Formula $n$
\end_inset


\end_layout

\begin_layout Proof
\align left
\begin_inset Formula $\left[\impliedby\right]$
\end_inset

 Si el camino para llegar desde 
\begin_inset Formula $n$
\end_inset

 hasta 
\begin_inset Formula $n'$
\end_inset

 es 
\begin_inset Formula 
\[
n=n_{0},n_{1},n_{2},...,n_{k-1},n_{k}=n'
\]

\end_inset

 entonces, 
\begin_inset Formula $K\left(n,a_{s},n'\right)=\sum_{i=1}^{k}c\left(n_{i-1},a_{i-1,i},n_{i}\right)$
\end_inset

 y, por ser 
\begin_inset Formula $h$
\end_inset

 monótona, se tiene que
\begin_inset Formula 
\[
h\left(n\right)=h\left(n_{0}\right)\leq c\left(n_{0},a_{0,1},n_{1}\right)+h\left(n_{1}\right)\leq c\left(n_{0},a_{0,1},n_{1}\right)+c\left(n_{1},a_{1,2},n_{2}\right)+h\left(n_{2}\right)\leq...\leq
\]

\end_inset


\begin_inset Formula 
\[
\leq c\left(n_{0},a_{0,1},n_{1}\right)+c\left(n_{1},a_{1,2},n_{2}\right)+...+c\left(n_{k-1},a_{k-1,k},n_{k}\right)+h\left(n_{k}\right)=
\]

\end_inset


\begin_inset Formula 
\[
=\sum_{i=1}^{k}c\left(n_{i-1},a_{i-1,i},n_{i}\right)+h\left(n'\right)=K\left(n,a_{s},n'\right)+h\left(n'\right)
\]

\end_inset

 por lo que 
\begin_inset Formula $h$
\end_inset

 es consistente.
\end_layout

\begin_layout Standard
\align left
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Teorema
\end_layout

\begin_layout Plain Layout
Si 
\begin_inset Formula $h$
\end_inset

 es una heurística consistente, entonces 
\begin_inset Formula $h$
\end_inset

 es admisible
\end_layout

\end_inset


\end_layout

\begin_layout Proof
\align left
Sea un nodo 
\begin_inset Formula $n$
\end_inset

 y 
\begin_inset Formula $G$
\end_inset

 el objetivo más cercano.
\end_layout

\begin_layout Proof
\align left
Como suponemos que 
\begin_inset Formula $h$
\end_inset

 es consistente, entonces
\begin_inset Formula 
\[
h\left(n\right)\leq K\left(n,a_{s},G\right)+h\left(G\right)
\]

\end_inset

 ahora bien, como 
\begin_inset Formula $G$
\end_inset

 es objetivo, entonces 
\begin_inset Formula $h\left(G\right)=0$
\end_inset

 y como es el más cercano a 
\begin_inset Formula $n$
\end_inset

, entonces 
\begin_inset Formula $K\left(n,a_{s},G\right)=h^{*}\left(n\right)$
\end_inset

, por tanto
\begin_inset Formula 
\[
h\left(n\right)\leq h^{*}\left(n\right)+0=h^{*}\left(n\right)
\]

\end_inset

 y 
\begin_inset Formula $h$
\end_inset

 es admisible
\end_layout

\begin_layout Standard
\align left
Observemos que lo contrario no es cierto, como ya hemos visto en el ejemplo
 anterior.
\end_layout

\begin_layout Standard
\align left
De esta forma, podemos interpretar la búsqueda como una exploración en un
 mapa con curvas de nivel, donde el estado inicial está en el centro, y
 se van recorriendo los nodos concéntricamente hasta agotar todos los de
 una misma zona de nivel.
 Entonces se pasa a la siguiente, y así hasta alcanzar el objetivo más cercano.
\end_layout

\begin_layout Standard
\align left
Tenemos, por tanto, que:
\end_layout

\begin_layout Itemize
\align left
Si 
\begin_inset Formula $h$
\end_inset

 es consistente, entonces los valores de 
\begin_inset Formula $f\left(n\right)$
\end_inset

 a lo largo de cualquier camino no disminuyen.
 Eso quiere decir que la secuencia de nodos expandidos por A* utilizando
 BUSQUEDA-GRAFOS está en orden no decreciente de 
\begin_inset Formula $f\left(n\right)$
\end_inset

, por lo que no será posible encontrar un camino de coste menor para un
 nodo ya cerrado.
\end_layout

\begin_layout Itemize
\align left
Por tanto, si 
\begin_inset Formula $h$
\end_inset

 es consistente, entonces A* es óptimo para BUSQUEDA-GRAFOS:
\end_layout

\begin_deeper
\begin_layout Proof
\align left
Supongamos que, en la frontera, se encuentra un nodo objetivo subóptimo,
 
\begin_inset Formula $G$
\end_inset

, con 
\begin_inset Formula $f\left(G\right)=g\left(G\right)+h\left(G\right)=g\left(G\right)>C^{*}$
\end_inset

, donde 
\begin_inset Formula $C^{*}$
\end_inset

 es el coste óptimo.
 Sea 
\begin_inset Formula $n$
\end_inset

 un nodo de la frontera, tal que pertenece al camino hacia la solución óptima,
 
\begin_inset Formula $G^{*}$
\end_inset

.
 Entonces, como 
\begin_inset Formula $h$
\end_inset

 es consistente, tendremos
\begin_inset Formula 
\[
f\left(n\right)=g\left(n\right)+h\left(n\right)\leq g\left(n\right)+K\left(n,a_{s},G^{*}\right)+h\left(G^{*}\right)
\]

\end_inset

 pero 
\begin_inset Formula $g\left(n\right)+K\left(n,a_{s},G^{*}\right)=C^{*}$
\end_inset

, pues estamos suponiendo 
\begin_inset Formula $G^{*}$
\end_inset

 el nodo solución óptimo, y que 
\begin_inset Formula $n$
\end_inset

 está en el camino óptimo hacia 
\begin_inset Formula $G^{*}$
\end_inset

.
 Por tanto
\begin_inset Formula 
\[
f\left(n\right)\leq C^{*}+h\left(G^{*}\right)=C^{*}<g\left(G\right)=f\left(G\right)
\]

\end_inset

 luego elegiremos 
\begin_inset Formula $n$
\end_inset

, antes de elegir 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Proof
¿Existe siempre tal nodo 
\begin_inset Formula $n$
\end_inset

?
\end_layout

\begin_layout Proof
Si 
\begin_inset Formula $G^{*}$
\end_inset

 es alcanzable desde el nodo inicial, entonces hay un camino óptimo desde
 el nodo inicial hasta 
\begin_inset Formula $G^{*}$
\end_inset

, luego sí.
\end_layout

\begin_layout Proof
¿
\begin_inset Formula $g\left(n\right)$
\end_inset

 es el coste sobre el camino óptimo? Para que la demostración fuese completa,
 deberíamos ver que también se verifica esto.
\end_layout

\end_deeper
\begin_layout Standard
\align left
De esta forma, vemos que A* es 
\end_layout

\begin_layout Itemize
\align left
completa
\end_layout

\begin_layout Itemize
\align left
óptima
\end_layout

\begin_layout Itemize
\align left
óptimamente eficiente entre todos los métodos
\end_layout

\begin_layout Standard
\align left
No obstante, A* no es ideal.
 La dificultad se encuentra en que, para la mayoría de los problemas, la
 cantidad de nodos en cada banda delimitada por las curvas de nivel es aún
 exponencial en la longitud de la solución.
 Y este no es el principal problema.
 Como A* mantiene todos los nodos generados en memoria, por lo general se
 queda sin espacio mucho antes que sin tiempo.
\end_layout

\begin_layout Standard
\align left
Se han desarrollado otros métodos que sacrifican un poco de tiempo para
 solventar los problemas de espacio, sin sacrificar la optimalidad ni la
 completitud.
\end_layout

\begin_layout Subsubsection*
Búsqueda Primero el Mejor Recursiva (BPMR)
\end_layout

\begin_layout Standard
\align left
Su objetivo es limitar el consumo de memoria en la búsqueda heurística.
 Para ello, imita a Primero el Mejor, pero genera menos nodos y el consumo
 de memoria es lineal.
 Evita profundizar sin límite por un camino que podría empezar a empeorar.
\end_layout

\begin_layout Itemize
\align left
Utiliza una variable 
\begin_inset Formula $f_{limite}$
\end_inset

 para recordar el 
\begin_inset Formula $f-valor$
\end_inset

 del mejor camino alternativo desde cualquier ancestro del nodo actual
\end_layout

\begin_layout Itemize
\align left
si el nodo actual excede este límite, la recursión retrocede al camino alternati
vo, descargando el subárbol actual
\end_layout

\begin_layout Itemize
\align left
al retroceder, el método reemplaza el 
\begin_inset Formula $f-valor$
\end_inset

 de cada nodo a lo largo del camino con un valor de respaldo: el mejor 
\begin_inset Formula $f-valor$
\end_inset

 de sus hijos
\end_layout

\begin_layout Standard
\align left
El pseudocódigo queda:
\end_layout

\begin_layout Standard
\align left
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función BPMR(problema) devuelve {solución o fallo}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

BPMR-f(problema, HACER-NODO(ESTADO-INICIAL(problema)),infinito)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

función BMPR-f(problema, nodo, flimite) devuelve {solucion o fallo o flimite_nue
vo}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

si TEST-OBJETIVO(problema, nodo) entonces devolver nodo
\end_layout

\begin_layout Plain Layout

sucesores <- EXPANDIR(nodo, problema)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

si VACIO(sucesores) entonces devolver (fallo,infinito)
\end_layout

\begin_layout Plain Layout

para cada s en sucesores hacer s.f <- max(g(s)+h(s), nodo.f)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

repetir
\end_layout

\begin_layout Plain Layout

	mejor <- nodo tal que nodo.f = min(s.f : s en sucesores)
\end_layout

\begin_layout Plain Layout

	si mejor.f > flimite entonces devuelve (fallo,mejor.f)
\end_layout

\begin_layout Plain Layout

	alernativa <- nodo tal que nodo.f es el segundo más bajo entre los sucesores
\end_layout

\begin_layout Plain Layout

	resultado,mejor.f <- BMPR-f(prolema,mejor,min(flimite,alternativa))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	si resultado != fallo entonces devolver resultado
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Y como ejemplo:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado2.png

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado3.png
	scale 95

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado4.png

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado5.png

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado6.png

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado7.png

\end_inset


\end_layout

\begin_layout Standard
\align left
BMPR es óptimo si 
\begin_inset Formula $h$
\end_inset

 verifica las mismas condiciones que en A* (admisibilidad en árboles y consisten
cia/monotonía en grafos).
\end_layout

\begin_layout Standard
\align left
Su complejidad en espacio es 
\begin_inset Formula $O\left(bd\right)$
\end_inset

 y en tiempo es complicado de caracterizar, depende de la función heurística,
 y de cómo de a menudo cambia el mejor camino mientras se expanden los nodos.
\end_layout

\begin_layout Standard
\align left
Así, si hubiera más memoria disponible, sería sensato aplicar un método
 que use toda la memoria disponible, a cambio de disminuir la complejidad
 en tiempo.
\end_layout

\begin_layout Standard
\align left
Uno de estos métodos es 
\series bold
A* con memoria acotada simplificada (A*MS)
\series default
 que avanza como A* hasta que se llene la memoria.
 En este momento, no se puede añadir un nuevo nodo al árbol de búsqueda
 sin retirar uno viejo.
 A*MS retira el peor nodo hoja, y, como BPMR, devuelve hacia atrás, a su
 padre, el valor del nodo olvidado.
 Así, A*MS vuelve a generar ese subárbol solo cuando todos los demás caminos
 parecen peores que el olvidado.
 
\end_layout

\begin_layout Standard
\align left
A*MS es completo si hay alguna solución alcanzable (
\begin_inset Formula $d$
\end_inset

 menor que el tamaño de memoria).
 Es óptimo si cualquier solución óptima es alcanzable.
 
\end_layout

\begin_layout Standard
\align left
En términos prácticos, A*MS podría ser el mejor método de uso general para
 encontrar soluciones óptimas.
\end_layout

\begin_layout Subsubsection*
Suboptimalidad controlada: heurísticas e-admisibles
\end_layout

\begin_layout Standard
Una forma de perder la optimalidad, pero de una forma controlada es permitir
 incrementar en una cantidad 
\begin_inset Formula $e$
\end_inset

 el salto de la frontera de optimalidad, de tal forma que, si
\begin_inset Formula 
\[
h^{*}\left(n\right)<h\left(n\right)\implies h\left(n\right)\leq h^{*}\left(n\right)+e
\]

\end_inset

 Este tipo de heurísticas se denominan 
\begin_inset Formula $\boldsymbol{e}$
\end_inset


\series bold
-admisibles
\series default
.
 Son importantes porque dan lugar a 
\series bold
soluciones 
\begin_inset Formula $\boldsymbol{e}$
\end_inset

-óptimas
\series default
, es decir, soluciones que no son óptimas pero por tan solo una cantidad
 
\begin_inset Formula $e$
\end_inset

.
\end_layout

\begin_layout Subsection
Estrategias sobre una representación por Reducción
\end_layout

\begin_layout Subsubsection
Búsqueda no informada o a ciegas
\end_layout

\begin_layout Standard
\align left
Utilizaremos un árbol de búsqueda Y/O.
 Para ello, especificaremos:
\end_layout

\begin_layout Itemize
\align left
un nodo inicial
\end_layout

\begin_layout Itemize
\align left
un conjunto de nodos terminales resolubles (primitivas)
\end_layout

\begin_layout Itemize
\align left
el conjunto de operadores para reducir el problem en subproblemas
\end_layout

\begin_layout Standard
\align left
Los 
\series bold
nodos O
\series default
 representan operadores que dividen un problema en subproblemas alternativos,
 representados por arcos dirigidos desde el nodo padre a cada nodo sucesor.
 Para resolver el nodo padre, basta resolver cualquiera de los sucesores.
\end_layout

\begin_layout Standard
\align left
Los 
\series bold
nodos Y
\series default
 representan operadores que dividen un problema en un conjunto de subproblemas,
 queda representado por un conjunto de arcos que uno el nodo padre con el
 conjunto de sucesores.
 Para resolver el nodo padre, es necesario resolver todos los nodos sucesores.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado8.png

\end_inset


\end_layout

\begin_layout Standard
\align left
Una 
\series bold
solución al problema
\series default
 original está dada por un subárbol del árbol Y/O suficiente para demostrar
 que el nodo comienzo es resoluble.
 
\end_layout

\begin_layout Standard
\align left
Los métodos de búsqueda en problemas de reducción tienen en común con los
 métodos de búsqueda en espacio de estados que la operación de expandir
 sigue presente, y que los distintos métodos difieren principalmente en
 el orden de expansión.
\end_layout

\begin_layout Standard
\align left
Vamos a hacer dos suposiciones simplificadoras:
\end_layout

\begin_layout Itemize
\align left
el espacio de búsqueda será un árbol Y/O, no un grafo Y/O general
\end_layout

\begin_layout Itemize
\align left
cuando un problema se transforma en un conjunto de subproblemas, estos pueden
 ser resueltos en cualquier orden (los subproblemas son independientes entre
 sí)
\end_layout

\begin_layout Standard
\align left
El pseudocódigo queda:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función BUSQUEDA-ARBOLES-YO(problema, frontera) devuelve {solucion o fallo}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

frontera <- INSERTA(HACER-NODO(PROBLEMA-INICIAL(problema)),frontera)
\end_layout

\begin_layout Plain Layout

bucle hacer
\end_layout

\begin_layout Plain Layout

	si VACIA(frontera) entonces devolver fallo
\end_layout

\begin_layout Plain Layout

	nodo <- BORRAR-PRIMERO(frontera)
\end_layout

\begin_layout Plain Layout

	frontera <- INSERTAR-TODO(EXPANDIR-YO(nodo, problema), frontera)
\end_layout

\begin_layout Plain Layout

	si VACIO(EXPANDIR-YO(nodo, problema)) entonces
\end_layout

\begin_layout Plain Layout

		nodo <- irresoluble
\end_layout

\begin_layout Plain Layout

		si (nodo irresoluble => algún ascentro irresoluble) entonces ancestros
 <- irresolubles
\end_layout

\begin_layout Plain Layout

		si (PROBLEMA-INICIAL(problema) irresoluble) entonces devolver fallo
\end_layout

\begin_layout Plain Layout

		BORRAR(frontera, {nodos con ascentros irresolubles})
\end_layout

\begin_layout Plain Layout

	en otro caso si (se generan nodos resolubles) entonces
\end_layout

\begin_layout Plain Layout

		etiquetar esos nodos como resolubles
\end_layout

\begin_layout Plain Layout

		si (esos nodos resolubles => algún ascentro resoluble) entonces ancestros
 <- resolubles
\end_layout

\begin_layout Plain Layout

		si (PROBLEMA-INICIAL(problema) resoluble) entonces devolver SOLUCION
\end_layout

\begin_layout Plain Layout

		BORRAR(frontera, {nodos etiquetados resolubles o con ascentros resolubles})
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

funcion EXPANDIR-YO(nodo, problema) devuelve set<nodo>
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

SUC <- {}
\end_layout

\begin_layout Plain Layout

para cada sucesor m de nodo
\end_layout

\begin_layout Plain Layout

	si m es un conjunto de subproblemas entonces
\end_layout

\begin_layout Plain Layout

		SUC <- INSERTAR-TODO(sucesores de m, SUC)
\end_layout

\begin_layout Plain Layout

	en otro caso SUC <- INSERTAR(m, SUC)
\end_layout

\begin_layout Plain Layout

devolver SUC
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Búsqueda Primero en Anchura en Árboles Y/O
\end_layout

\begin_layout Standard
Se implementa llamando a BUSQUEDA-ARBOLES-YO(problema, COLA-FIFO()).
\end_layout

\begin_layout Subsubsection*
Búsqueda Primero en Profundidad en Árboles Y/O
\end_layout

\begin_layout Standard
Se implementa llamando a BUSQUEDA-ARBOLES-YO(problema, COLA-LIFO())
\end_layout

\begin_layout Subsubsection*
Búsqueda de Profundidad Limitada en Árboles Y/O
\end_layout

\begin_layout Standard
Se puede aliviar el problema de los árboles ilimitados aplicando la búsqueda
 primero en profundidad con un límite de profundidad predeterminado.
 Al igual que ocurría en espacio de estados, el límite introduce una fuente
 de incompletitud, puede que no profundicemos suficiente para resolver el
 problema principal.
\end_layout

\begin_layout Subsubsection
Búsqueda Heurística o Informada
\end_layout

\begin_layout Standard
La presencia de nodos Y añade complicaciones conceptuales.
 Es útil ver los grafos YO como hipergrafos.
 Pasamos de tener arcos que conectan pares de nodos 
\begin_inset Formula $\left(a,b\right)$
\end_inset

 a tener hiperarcos, que conectan un nodo antecesor con un conjunto de nodos
 sucesores 
\begin_inset Formula $\left(a,\left\{ b_{1},...,b_{k}\right\} \right)$
\end_inset

, o 
\begin_inset Formula $\boldsymbol{k}$
\end_inset


\series bold
-conectores
\series default
, con 
\begin_inset Formula $k$
\end_inset

 el cardinal del conjunto de sucesores.
\end_layout

\begin_layout Standard
Podemos definir un grafo solución de forma precisa si suponemos que nuestros
 grafos YO no poseen ciclos (son árboles), de forma recursiva:
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
\begin_inset Formula $G'$
\end_inset

 es un 
\series bold
grafo solución
\series default
 desde el nodo 
\begin_inset Formula $n$
\end_inset

 a un conjunto 
\begin_inset Formula $N$
\end_inset

 de nodos de un grafo YO, 
\begin_inset Formula $G$
\end_inset

 si:
\end_layout

\begin_layout Itemize
\begin_inset Formula $G'$
\end_inset

 es un subgrafo de 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Itemize
Si 
\begin_inset Formula $n\in N\implies G'=\left\{ n\right\} $
\end_inset


\end_layout

\begin_layout Itemize
Si 
\begin_inset Formula $n\notin N$
\end_inset

, entonces
\end_layout

\begin_deeper
\begin_layout Itemize
si 
\begin_inset Formula $n$
\end_inset

 tiene un 
\begin_inset Formula $k$
\end_inset

-conector, 
\begin_inset Formula $\left(n,\left\{ n_{1},...,n_{k}\right\} \right)$
\end_inset

 tales que hay un grafo solución hasta 
\begin_inset Formula $N$
\end_inset

 desde cada 
\begin_inset Formula $n_{i},\ i=1,...,k$
\end_inset

, se verifica que 
\begin_inset Formula $G'$
\end_inset

 consta de:
\end_layout

\begin_deeper
\begin_layout Itemize
nodo 
\begin_inset Formula $n$
\end_inset


\end_layout

\begin_layout Itemize
el 
\begin_inset Formula $k$
\end_inset

-conector
\end_layout

\begin_layout Itemize
los nodos 
\begin_inset Formula $n_{1},...,n_{k}$
\end_inset


\end_layout

\begin_layout Itemize
los grafos solución a 
\begin_inset Formula $N$
\end_inset

 desde cada nodo 
\begin_inset Formula $n_{1},...,n_{k}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
si no, no hay grafo solución desde 
\begin_inset Formula $n$
\end_inset

 a 
\begin_inset Formula $N$
\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Standard
Como hicimos anteriormente, es útil asignar costes a los conectores de los
 grafos Y/O, que serán utilizados para calcular el coste de un grafo solución.
\end_layout

\begin_layout Standard
Sea 
\begin_inset Formula $K\left(n,N\right)$
\end_inset

 el coste de un grafo solución desde el nodo 
\begin_inset Formula $n$
\end_inset

 hasta 
\begin_inset Formula $N$
\end_inset

.
 Entonces:
\end_layout

\begin_layout Itemize
si 
\begin_inset Formula $n\in N\implies K\left(n,N\right)=0$
\end_inset


\end_layout

\begin_layout Itemize
si 
\begin_inset Formula $n\notin N$
\end_inset

, entonces, si 
\begin_inset Formula $n$
\end_inset

 tiene un 
\begin_inset Formula $k$
\end_inset

-conector 
\begin_inset Formula $\left(n,\left\{ n_{1},...,n_{k}\right\} \right)$
\end_inset

 en el grafo solución, sea 
\begin_inset Formula $c_{n}$
\end_inset

 el coste de ese conector, entonces
\begin_inset Formula 
\[
K\left(n,N\right)=c_{n}+\sum_{i=1}^{k}K\left(n_{i},N\right)
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Características de las funciones de evaluación en grafos Y/O
\end_layout

\begin_layout Standard
\align left
Estaremos interesados, normalmente, en encontrar el grafo solución que tenga
 costo mínimo, o sea, el 
\series bold
grafo solución óptimo
\series default
.
 Para ello, dispondremos de una función heurística 
\begin_inset Formula $h$
\end_inset

 para estimar el costo.
\end_layout

\begin_layout Standard
\align left
Para buscar en un grafo Y/O, es necesario realizar cuatro acciones en cada
 paso:
\end_layout

\begin_layout Itemize
\align left
atravesar el grafo empezando por el nodo inicial y siguiendo el mejor camino
 actual, acumulando el conjunto de nodos que van en ese camino y no se han
 expandido
\end_layout

\begin_layout Itemize
\align left
elegir uno de esos nodos no expandidos y expandirlo.
 Añadir sus sucesores al grafo y calcular 
\begin_inset Formula $h$
\end_inset

 para cada uno de ellos
\end_layout

\begin_layout Itemize
\align left
cambiar la 
\begin_inset Formula $h$
\end_inset

 estimada del nodo recientemente expandido para reflejar la nueva información
 proporcionada por sus sucesores.
 Propagar este cambio hacia atrás a través del grafo
\end_layout

\begin_layout Itemize
\align left
para cada nodo que se visita mientras se avanza en el grafo, debemos decidir
 cuál de sus conectores es más prometedor y marcarlo como parte del mejor
 grafo solución parcial actual
\end_layout

\begin_layout Standard
\align left
Así, en el nodo raíz de la estructura aparecerá el coste del grafo solución
 actual, y una marca indicando el operador que genera ese grafo solución.
\end_layout

\begin_layout Subsubsection*
Estrategia Y/O*
\end_layout

\begin_layout Standard
\align left
No utiliza las dos listas frontera y cerrados, sino una única estructura
 
\begin_inset Formula $G$
\end_inset

, que representa la parte del grafo de búsqueda que se ha generado explícitament
e hasta el momento, denominado 
\series bold
grafo de exploración
\series default
.
\end_layout

\begin_layout Standard
\align left
También se emplea un 
\series bold
valor futilidad
\series default
, que sirve de valor tope para descartar un camino.
 Si el costo estimado de una posible solución se vuelve mayor que el valor
 futilidad, entonces abandonaremos la búsqueda.
\end_layout

\begin_layout Standard
\align left
El pseudocódigo queda:
\end_layout

\begin_layout Standard
\align left
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función YO*(problema, futilidad) devuelve grafo-solucion
\end_layout

\begin_layout Plain Layout

	locales: G,G' grafos
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

G grafo vacío
\end_layout

\begin_layout Plain Layout

G <- G+{inicio}
\end_layout

\begin_layout Plain Layout

inicio.costo <- h(inicio)
\end_layout

\begin_layout Plain Layout

si (ES-TERMINAL(inicio)) entonces MARCAR(inicio, resuelto)
\end_layout

\begin_layout Plain Layout

repetir hasta (ES-RESUELTO(inicio) o inicio.costo > futilidad)
\end_layout

\begin_layout Plain Layout

	construir un subgrafo de G, G', con los conectores marcados
\end_layout

\begin_layout Plain Layout

	nodo <- elegir nodo de FRONTERA(G')
\end_layout

\begin_layout Plain Layout

	si (VACIO(EXPANDIR(nodo))) entonces nodo.costo=futilidad
\end_layout

\begin_layout Plain Layout

	en otro caso (para cada sucesor en EXPANDIR(nodo)) hacer
\end_layout

\begin_layout Plain Layout

		G <- G+{sucesor}
\end_layout

\begin_layout Plain Layout

		si (ES-TERMINAL(sucesor) entonces MARCAR(sucesor, resuelto) y sucesor.costo=0
\end_layout

\begin_layout Plain Layout

		si (!ES-TERMINAL(sucesor) y (no estaba en G)) entonces sucesor.costo=h(sucesor)
\end_layout

\begin_layout Plain Layout

	S={nodo : nodo ha sido marcado resuelto o su costo ha cambiado}
\end_layout

\begin_layout Plain Layout

	repetir hasta VACIO(S)
\end_layout

\begin_layout Plain Layout

		actual <- actual en S tal que no hay descendientes de actual en S
\end_layout

\begin_layout Plain Layout

		S <- S-{actual}
\end_layout

\begin_layout Plain Layout

		para cada (k-conector de actual {ni1,...,nik}) hacer
\end_layout

\begin_layout Plain Layout

			actual.costoi=c+ni1.costo+...+nik.costo
\end_layout

\begin_layout Plain Layout

		actual.costo <- min(actual.costoi)
\end_layout

\begin_layout Plain Layout

		conector <- (el que nos da el valor anterior)
\end_layout

\begin_layout Plain Layout

		MARCAR(conector, marca)
\end_layout

\begin_layout Plain Layout

		si (todos los sucesores a través de conector están marcados como resueltos)
 entonces MARCAR(actual, resuelto)
\end_layout

\begin_layout Plain Layout

		si (actual ha sido marcado resuelto o su costo ha cambiado) entonces
\end_layout

\begin_layout Plain Layout

			propagar la información hacia el principio del grafo
\end_layout

\begin_layout Plain Layout

			S <- S+{actual.antecesores}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
La 
\series bold
condición de monotonía en una estructura Y/O
\series default
 de una función heurística 
\begin_inset Formula $h$
\end_inset

 es que, para cualquier conector dirigido desde el nodo 
\begin_inset Formula $n$
\end_inset

 a los sucesores 
\begin_inset Formula $n_{1},...,n_{k}$
\end_inset

 se verifica
\begin_inset Formula 
\[
h\left(n\right)\leq c+\sum_{i=1}^{k}h\left(n_{i}\right)
\]

\end_inset

 donde 
\begin_inset Formula $c$
\end_inset

 es el costo del 
\begin_inset Formula $k$
\end_inset

-conector.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
Así, si hay un grafo solución desde el nodo inicial a un conjunto de nodos
 terminales y 
\begin_inset Formula $h$
\end_inset

 es admisible y satisface la condición de monotononía para estructuras Y/O,
 entonces se dice que el 
\series bold
método YO* es admisible
\series default
 y proporciona un grafo solución óptimo.
\end_layout

\begin_layout Standard
\align left
Cuando se verifica la condición de monotonía de 
\begin_inset Formula $h$
\end_inset

, las revisiones de costos que se hacen en YO* solo pueden consistir en
 incrementos.
\end_layout

\begin_layout Standard
Se puede modificar la última parte del método para que se incluyan en S
 solo los antecesores de actual tales que actual sea uno de sus sucesores
 a través de conectores marcados.
\end_layout

\begin_layout Standard
Notemos, por último, que:
\end_layout

\begin_layout Itemize
se puede ampliar el método para trabajar con grafos Y/O generales, que pueden
 contener ciclos
\end_layout

\begin_layout Itemize
la definición del coste de un grafo solución supone que un subproblema puede
 resolverse dos o más veces, lo que implica contar el costo de resolverlo
 varias veces.
 Si el problema implica algún proceso físico, entonces las soluciones proporcion
adas por YO* son óptimas.
 Pero si el proceso de resolución no es de ese tipo quizás no deberían contarse
 los costos más de una vez
\end_layout

\begin_layout Subsection
El efecto de la precisión heurística en el rendimiento
\end_layout

\begin_layout Standard
\align left
Una manera de caracterizar la calidad de una heurística es el 
\series bold
factor de ramificación eficaz
\series default
, 
\begin_inset Formula $b^{*}$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Si el número total de nodos generados por un método para un problema es
 
\begin_inset Formula $N$
\end_inset

 y la profundidad de la solución es 
\begin_inset Formula $d$
\end_inset

, entonces el factor de ramificación eficaz, 
\begin_inset Formula $b^{*}$
\end_inset

, es el factor de ramificación que un árbol uniforme de profundidad 
\begin_inset Formula $d$
\end_inset

 debería tener para tener 
\begin_inset Formula $N+1$
\end_inset

 nodos.
 O sea, que verifica
\begin_inset Formula 
\[
N+1=1+b^{*}+\left(b^{*}\right)^{2}+...+\left(b^{*}\right)^{d}
\]

\end_inset

 Una buena heurística debe tener 
\begin_inset Formula $b^{*}$
\end_inset

 lo más próximo posible a 1, lo que permite resolver problemas complejos
 en un tiempo razonable.
\end_layout

\begin_layout Standard
\align left
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
Una heurística 
\begin_inset Formula $h_{2}$
\end_inset

 domina a otra 
\begin_inset Formula $h_{1}$
\end_inset

 si, y solo si, 
\begin_inset Formula 
\[
h_{2}\left(n\right)\geq h_{1}\left(n\right),\ \forall n
\]

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
La dominancia se traslada directamente a la eficiencia
\end_layout

\begin_layout Subsubsection
Diseñando funciones heurísticas admisibles
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
Un problema con menos restricciones que el original se denomina 
\series bold
problema relajado
\series default
.
 El costo de una solución óptima en un problema relajado es una heurística
 admisible para el problema original, porque la solución óptima en el problema
 original es, por definición, también una solución del problema relajado,
 por lo que debe ser al menos tan cara como su solución óptima.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Un problema con la generación de nuevas funciones heurísticas es que a menudo
 no es fácil o incluso posible conseguir una heurística claramente mejor
 (una es mejor en unos casos, y otra es mejor en otros).
 Pero, si disponemos de un conjunto de heurísticas admisibles 
\begin_inset Formula $h_{1},...,h_{k}$
\end_inset

 para un problema, y ninguna domina a las demás, podemos escoger la heurística
\begin_inset Formula 
\[
h\left(n\right)=\max\left\{ h_{1}\left(n\right),...,h_{k}\left(n\right)\right\} 
\]

\end_inset

 que es admisible:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
h\left(n\right)=h_{i}\left(n\right)\leq h^{*}\left(n\right)
\]

\end_inset

 consistente si las componentes lo son
\begin_inset Formula 
\[
h\left(n\right)=h_{i}\left(n\right)\leq K\left(n,a_{s},m\right)+h_{i}\left(m\right)\leq K\left(n,a_{s},m\right)+\max_{i}\left\{ h_{i}\left(m\right)\right\} =K\left(n,a_{s},m\right)+h\left(m\right)
\]

\end_inset

 además, 
\begin_inset Formula $h$
\end_inset

 domina a todas sus componentes.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Estrategias avanzadas de búsqueda
\end_layout

\begin_layout Standard
\align left
Los métodos de búsqueda vistos hasta ahora se diseñan para explorar sistemáticam
ente espacios de búsqueda.
 No obstante, en muchos problemas el camino al objetivo es irrelevante,
 solo nos interesa llegar hasta él.
 Además, en los procesos de búsqueda que hemos visto hasta ahora, todas
 las decisiones tomadas pueden ser recuperables, pero hay muchos problemas
 no recuperables, en los que una decisión de un agente en un momento dado
 tiene que considerar posibles acciones que pueden realizar otros agentes,
 planteando distintos escenarios posibles de forma imprevisible.
 Esto puede introducir dificultades en el proceso de resolución de problemas.
\end_layout

\begin_layout Standard
\align left
Los entornos competitivos, en los que los objetivos de varios agentes están
 en conflicto, dan lugar a problemas de búsqueda entre adversarios o 
\series bold
juegos
\series default
.
\end_layout

\begin_layout Subsection
Métodos de búsqueda local y problemas de optimización
\end_layout

\begin_layout Standard
\align left
Si no importa el camino al objetivo, podemos considerar una nueva clase
 de métodos, los 
\series bold
métodos de búsqueda local
\series default
, que:
\end_layout

\begin_layout Itemize
\align left
operan con un único estado actual
\end_layout

\begin_layout Itemize
\align left
generalmente se mueven solo a los vecinos del estado actual
\end_layout

\begin_layout Itemize
\align left
los caminos seguidos no suelen ser recordados
\end_layout

\begin_layout Standard
\align left
Estos métodos presentan dos grandes ventajas:
\end_layout

\begin_layout Itemize
\align left
usan muy poca memoria (generalmente 
\begin_inset Formula $O\left(n\right)$
\end_inset


\end_layout

\begin_layout Itemize
\align left
a menudo pueden encontrar soluciones rezonables en espacios de estados grandes
 o infinitos, donde los algoritmos sistemáticos son inadecuados
\end_layout

\begin_layout Standard
\align left
Por tanto, son útiles para resolver problemas de optimización puros, en
 los que se busca el mejor estado según una función objetivo.
\end_layout

\begin_layout Standard
\align left
Es útil conceptualmente considerar que el espacio de estados conforma un
 paisaje que tiene:
\end_layout

\begin_layout Itemize
\align left
posición: definida por el estado
\end_layout

\begin_layout Itemize
\align left
elevación: definida por la función objetivo en cada punto
\end_layout

\begin_layout Standard
\align left
Así, si la elevación corresponde al coste, el objetivo es encontrar un mínimo
 global (el valle más bajo).
 Si corresponde a una función de evaluación, entonces buscamos un máximo
 global (el pico más alto).
\end_layout

\begin_layout Standard
\align left
Los métodos de búsqued local exploran este paisaje.
\end_layout

\begin_layout Standard
\align left
Un método de búsqueda local siempre encuentra un objetivo, si este existe.
 Y un método óptimo siempre encuentra el máximo global.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado9.png

\end_inset


\end_layout

\begin_layout Standard
\align left
Podemos encontrar algunas zonas diferenciadas del paisaje:
\end_layout

\begin_layout Itemize
\align left

\series bold
máximo local
\series default
: pico que es más alto que cada uno de sus estados vecinos, pero más bajo
 que el máximo global
\end_layout

\begin_layout Itemize
\align left

\series bold
cresta
\series default
: secuencia de máximos locales que hace muy difícil la navegación para los
 métodos avaros
\end_layout

\begin_layout Itemize
\align left

\series bold
meseta o terraza
\series default
: área del paisaje del espacio de estados donde la función objetivo es plana
\end_layout

\begin_layout Subsubsection
Búsqueda por Ascensión de Colinas
\end_layout

\begin_layout Standard
\align left
Simplemente es un bucle que continuamente se mueve en dirección del valor
 creciente.
 Termina cuando alcanza un pico en donde ningún vecino tiene un valor más
 alto (un máximo local).
\end_layout

\begin_layout Standard
\align left
No mantiene un árbol de búsqueda, sino una estructura de datos del nodo
 actual que necesita solo el registro del estado y su valor de función objetivo.
 No mira más allá de los vecinos inmediatos del estado actual.
\end_layout

\begin_layout Standard
\align left
En pseudocódigo:
\end_layout

\begin_layout Standard
\align left
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función ASCENSION-COLINAS(problema) devuelve {estado máximo local}
\end_layout

\begin_layout Plain Layout

entradas: problema
\end_layout

\begin_layout Plain Layout

locales: actual,vecino
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

actual <- HACER-NODO(ESTADO-INICIAL(problema))
\end_layout

\begin_layout Plain Layout

bucle hacer
\end_layout

\begin_layout Plain Layout

	vecino <- sucesor(actual) con valor máximo
\end_layout

\begin_layout Plain Layout

	si vecino.valor<=actual.valor entonces devolver ESTADO(actual)
\end_layout

\begin_layout Plain Layout

	actual <- vecino
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
Ascensión de colinas a menudo se atasca, cuando encuentra máximos locales
 que no son globales, crestas o mesetas.
 En cada caso, el método alcanza un punto en el cual no se puede hacer ningún
 progreso.
\end_layout

\begin_layout Standard
\align left
Una posible solución es permitir 
\series bold
movimiento lateral
\series default
, es decir, permitir al método moverse a estados vecinos aunque no mejoren
 el valor actual.
 Sin embargo, si permitimos que siempre se haga movimiento lateral cuando
 no hay movimiento ascendente, entraremos en un bucle infinito siempre que
 el método alcance un máximo local plano.
 Esto puede solucionarse poniendo un límite sobre el número de movimientos
 laterales consecutivos laterales permitidos.
\end_layout

\begin_layout Standard
\align left
Los métodos de ascensión de colinas son incompletos, pueden dejar de encontrar
 un objetivo aunque este exista.
\end_layout

\begin_layout Subsubsection
Ascensión de colinas de reinicio aleatorio
\end_layout

\begin_layout Standard
\align left
Consiste en realizar una serie de búsquedas sucesivas desde un estado inicial
 aleatorio.
 Es completa con probabilidad cercana a 1.
\end_layout

\begin_layout Standard
\align left
Si la búsqueda por ascensión de colinas tiene una probabilidad 
\begin_inset Formula $p$
\end_inset

 de éxito, entonces el número esperado de reinicios es 
\begin_inset Formula $\frac{1}{p}$
\end_inset

, que se reparten entre 1 acierto y 
\begin_inset Formula $\frac{1}{p}-1$
\end_inset

 fallos, por tanto, el número total de pasos es el coste de una iteración
 con éxito más 
\begin_inset Formula $\frac{1-p}{p}$
\end_inset

 veces el coste de los fallos.
 
\end_layout

\begin_layout Subsubsection
Búsqueda por temple simulado
\end_layout

\begin_layout Standard
\align left
Intenta combinar la eficacia de la ascensión de caminas con la completitud
 de la elección aleatoria de caminos.
 La idea se basa en un proceso metalúrgico para templar metal: se calienta
 a alta temperatura y se enfría gradualmente, facilitando que alcance una
 estructura cristalina de baja energía.
\end_layout

\begin_layout Standard
\align left
Así, de forma intuitiva, podemos pensar que, dado un estado:
\end_layout

\begin_layout Itemize
\align left
si se agita con suficiente fuerza puede escapar de mínimos locales.
 La fuerza de agitación la determina una función que simula la temperatura
\end_layout

\begin_layout Itemize
\align left
si se agita demasiado fuerte puede escapar de un mínimo global
\end_layout

\begin_layout Itemize
\align left
la fuerza de agitación disminuye con el tiempo, se 
\begin_inset Quotes eld
\end_inset

enfría
\begin_inset Quotes erd
\end_inset

 el paisaje
\end_layout

\begin_layout Standard
\align left
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función TEMPLE-SIMULADO(problema, esquema) devuelve {estado solución}
\end_layout

\begin_layout Plain Layout

entradas: problema
\end_layout

\begin_layout Plain Layout

		esquema, función temperatura respecto tiempo
\end_layout

\begin_layout Plain Layout

locales: actual y siguiente: nodos
\end_layout

\begin_layout Plain Layout

		T: temperatura
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

actual <- HACER-NODO(ESTADO-INICIAL(problema))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

para t <- 1 a infinito hacer
\end_layout

\begin_layout Plain Layout

	T <- esquema(t)
\end_layout

\begin_layout Plain Layout

	si (T=0) entonces devolver actual
\end_layout

\begin_layout Plain Layout

	para i <- 1 to Lt hacer
\end_layout

\begin_layout Plain Layout

		siguiente <- sucesor aleatorio de actual
\end_layout

\begin_layout Plain Layout

		dE <- siguiente.valor - actual.valor
\end_layout

\begin_layout Plain Layout

		si dE>0 entonces
\end_layout

\begin_layout Plain Layout

			actual <- siguiente
\end_layout

\begin_layout Plain Layout

		si no
\end_layout

\begin_layout Plain Layout

			actual <- siguiente con probabilidad e^(dE/T)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
El bucle interno es similar a ascensión de colinas, pero el sucesor se elige
 aleatoriamente.
 Si mejora al actual, se elige seguro.
 Si lo empeora, se elige con probabilidad 
\begin_inset Formula $e^{\frac{\Delta E}{T}}$
\end_inset

, valor que decrece exponencialmente con la falta de calidad del sucesor
 y con la temperatura 
\begin_inset Formula $T$
\end_inset

, que disminuye con el tiempo.
\end_layout

\begin_layout Subsubsection
Búsqueda por haz local
\end_layout

\begin_layout Standard
\align left
Este método guarda la pista de 
\begin_inset Formula $k$
\end_inset

 estados, y hace lo siguiente:
\end_layout

\begin_layout Enumerate
\align left
comienza con 
\begin_inset Formula $k$
\end_inset

 estados generados aleatoriamente
\end_layout

\begin_layout Enumerate
\align left
se generan los sucesores de cada uno de los 
\begin_inset Formula $k$
\end_inset

 estados
\end_layout

\begin_layout Enumerate
\align left
si alguno es objetivo, fin
\end_layout

\begin_layout Enumerate
\align left
si no, se seleccionan los 
\begin_inset Formula $k$
\end_inset

 mejores sucesores de la lista completa y volvemos a 2
\end_layout

\begin_layout Standard
\align left
Podría parecer que es equivalente a realizar 
\begin_inset Formula $k$
\end_inset

 reinicios aleatorios en paralelo en lugar de secuencialmente, pero los
 dos métodos son distintos.
 En la búsqueda con reinicio aleatorio, cada proceso de búsqueda es independient
e de los demás, mientras que en la búsqueda por haz local, la información
 útil es pasada entre los 
\begin_inset Formula $k$
\end_inset

 hilos paralelos de búsqueda.
\end_layout

\begin_layout Standard
\align left
En su forma más simple, la búsqueda de haz local es carente de diversidad
 entre los 
\begin_inset Formula $k$
\end_inset

 estados.
\end_layout

\begin_layout Standard
Una variante muy utilizada son los llamados 
\series bold
algoritmos genéticos
\series default
, una variante de la búsqueda de haz estocástica.
\end_layout

\begin_layout Subsubsection*
Algoritmos genéticos
\end_layout

\begin_layout Standard
Variante de los métodos de búsqueda por haz estocástica.
 Esto quiere decir que son un método de búsqueda local: no suele importar
 cómo llegar a la solución, tan solo la solución en sí misma; y no se recorre
 el espacio de soluciones al completo, sino parte de él.
 Por tanto, no siempre obtendremos una solución óptima, pues podemos obtener
 óptimos locales.
 Los AGs constan de las siguientes partes:
\end_layout

\begin_layout Itemize

\series bold
Población:
\series default
 Llevaremos la pista de 
\begin_inset Formula $k$
\end_inset

 estados, generados al comienzo aleatoriamente.
\end_layout

\begin_layout Itemize

\series bold
Individuos o cromosomas:
\series default
 cada estado de la población.
 
\end_layout

\begin_layout Itemize

\series bold
Codificación:
\series default
 forma de representación de los estados.
 La codificación será una cadena sobre un alfabeto finito.
 La codificación puede ser binaria, entera, de orden, o real.
\end_layout

\begin_layout Itemize

\series bold
Gen:
\series default
 cada elemento de un estado se denomina gen.
 Por tanto, un gen será un elemento del alfabeto de codificación.
 El conjunto de genes de un individuo a veces se denomina genotipo, y a
 la traducción del significado del genotipo al problema que tratamos de
 resolver se le denomina fenotipo.
\end_layout

\begin_layout Itemize

\series bold
Función Fitness:
\series default
 es la función usada para cuantificar lo bueno que es cada individuo en
 relación al problema.
 Esta será la función que buscamos optimizar.
\end_layout

\begin_layout Itemize

\series bold
Operadores genéticos:
\series default
 los algoritmos genéticos dan uso a 3 operadores básicos para simular el
 proceso de evolución:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Selección:
\series default
 utilizado para seleccionar qué individuos pasan a reproducirse, y cuales
 no.
 Para la selección es muy normal tener en cuenta los valores de fitness
 de los individuos, ya que es este valor el que indica la calidad de los
 mismos.
\end_layout

\begin_layout Itemize

\series bold
Cruce:
\series default
 simula la reproducción de los individuos seleccionados.
 Define la forma en la que los genes de pares de individuos se entremezclan
 para dar lugar a nuevos individuos.
 Por supuesto, los individuos generados mediante cruce deben representar
 estados válidos del espacio de búsqueda.
\end_layout

\begin_layout Itemize

\series bold
Mutación:
\series default
 este operador provoca variaciones aleatorias en algunos genes de un individuo.
 Se utiliza para añadir variabilidad a la población.
\end_layout

\end_deeper
\begin_layout Standard
Así, el esquema básico de un AG queda como sigue:
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

funcion AG(poblacion, fitness) devuelve individuo
\end_layout

\begin_layout Plain Layout

entradas: población, función fitness
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

repetir
\end_layout

\begin_layout Plain Layout

    mi_poblacion := SELECCION(poblacion, fitness)
\end_layout

\begin_layout Plain Layout

    para x=1 hasta tamaño(mi_población) hacer
\end_layout

\begin_layout Plain Layout

        si(r<pc) entonces
\end_layout

\begin_layout Plain Layout

            poblacion_cruzar = poblacion_cruzar + mi_poblacion[x]
\end_layout

\begin_layout Plain Layout

    para i=1 hasta tamaño(poblacion_cruzar) hacer
\end_layout

\begin_layout Plain Layout

        {x,y} = dos individuos aleatorios de poblacion_cruzar
\end_layout

\begin_layout Plain Layout

        h1, h2 = CRUCE(x,y)
\end_layout

\begin_layout Plain Layout

        {x,y} = {h1, h2}
\end_layout

\begin_layout Plain Layout

    para x=1 hasta tamaño(mi_poblacion)*longitud(individuo) hacer
\end_layout

\begin_layout Plain Layout

        si(r<pm) entonces
\end_layout

\begin_layout Plain Layout

            gen = MUTAR(gen)
\end_layout

\begin_layout Plain Layout

            modificar el gen del individuo correspondiente
\end_layout

\begin_layout Plain Layout

    poblacion = mi_poblacion
\end_layout

\begin_layout Plain Layout

hasta condición de fin (fitness mínimo, o suficientemente pequeño, o ha
 pasado mucho tiempo)
\end_layout

\begin_layout Plain Layout

devolver individuo de poblacion tal que fitness(individuo)=max{fitness(i):
 i en poblacion}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Donde 
\begin_inset Formula $r$
\end_inset

 es un número generado aleatoriamente y
\begin_inset Formula $p_{c}$
\end_inset

 es la probabilidad de que un individuo sea seleccionado para cruzarse,
 
\begin_inset Formula $p_{m}$
\end_inset

 es la probabilidad de que se produzca una mutación en un gen determinado,
 y SELECCION, CRUCE y MUTAR son implementaciones concretas de los operadores
 que hemos explicado anteriormente.
 Algunas implementaciones comúnmente utilizadas son:
\end_layout

\begin_layout Itemize
Selección:
\end_layout

\begin_deeper
\begin_layout Itemize
Ruleta: se eligen los individuos de forma directamente proporcional a la
 función de idoneidad, de modo que individuos con mejor valor fitness tienen
 más posibilidades de ser elegidos
\end_layout

\begin_layout Itemize
Torneo: se hacen 
\begin_inset Formula $k$
\end_inset

 emparejamientos entre individuos de la población y se eligen los que tienen
 mejor fitness en cada emparejamiento
\end_layout

\end_deeper
\begin_layout Itemize
Cruce:
\end_layout

\begin_deeper
\begin_layout Itemize
Cruce por un punto: se intercambian todos los genes de los dos individuos
 de un punto en adelante
\end_layout

\begin_layout Itemize
Cruce por dos puntos: se intercambian todos los genes de los dos individuos
 entre dos puntos seleccionados
\end_layout

\end_deeper
\begin_layout Itemize
Mutación:
\end_layout

\begin_deeper
\begin_layout Itemize
Cambio de un gen aleatorio: un gen cambia su valor aleatoriamente
\end_layout

\begin_layout Itemize
Intercambio entre dos genes: dos genes aleatorios intercambian sus valores
\end_layout

\end_deeper
\begin_layout Subsection
Búsqueda entre adversarios: Decisiones óptimas en Juegos
\end_layout

\begin_layout Standard
\align left
En los entornos multiagente, cualquier agente tiene que considerar las acciones
 de los otros agentes y cómo afectan a su propio bienestar.
 La imprevisibilidad de estos otros agentes puede introducir muchas posibles
 contingencias en el proceso de resolución de problemas del agente.
\end_layout

\begin_layout Standard
\align left
Los entornos competitivos, en los cuales los objetivos de diferentes agentes
 están en conflicto dan ocasión a problemas de búsqueda entre adversarios
 o 
\series bold
juegos
\series default
.
\end_layout

\begin_layout Standard
\align left
En IA, normalmente se consideran 
\series bold
juegos de suma cero
\series default
, es decir, juegos tales que se desarrollan en entornos deterministas, totalment
e observables con dos agentes cuyas acciones deben alternar y en los que
 los valores utilidad, al final de juego, son siempre iguales y opuestos.
\end_layout

\begin_layout Standard
Consideraremos juegos con dos jugadores llamados MAX y MIN.
 MAX mueve primero, y mueven por turnos hasta que el juego se termina.
 Al final del juego se concederán puntos al jugador ganador y penalizaciones
 al perdedor, en la misma cantidad (juegos de suma cero).
\end_layout

\begin_layout Standard
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
Un 
\series bold
juego
\series default
 es una clase de problemas de búsqueda, donde:
\end_layout

\begin_layout Itemize
el estado inicial es la posición del tablero inicial e identifica al jugador
 que mueve primero
\end_layout

\begin_layout Itemize
la función sucesor devuelve una lista de pares (movimientos, estado)
\end_layout

\begin_layout Itemize
un test terminal que determina cuándo se termina el juego
\end_layout

\begin_layout Itemize
una función utilidad que asigna un valor numérico a los estados terminales
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El estado inicial y los movimientos legales para cada lado definen el árbol
 de juego.
 El número sobre cada nodo hoja indica el valor de utilidad del estado terminal
 desde el punto de vista de un jugador: cuanto mayor sea un valor, mejor
 para MAX y peor para MIN.
 Así, MAX usará el árbol de búsqueda para determinar el mejor movimiento.
\end_layout

\begin_layout Subsubsection
Estrategia óptima.
 Minimax
\end_layout

\begin_layout Standard
\align left
MAX debe encontrar una estrategia contingente, que especifica el movimiento
 de MAX en el estado inicial, después los movimientos de MAX en los estados
 que resultan de cada respuesta posible de MIN, después los movimientos
 de MAX en los estados que resultan de cada respuesta posible de MIN de
 los anteriores movimientos, y así.
\end_layout

\begin_layout Standard
\align left
Así, el valor de minimax en cada nodo 
\begin_inset Formula $n$
\end_inset

, será:
\end_layout

\begin_layout Standard
\align left
\begin_inset Formula 
\[
VALOR\_MINIMAX\left(n\right)=\begin{cases}
utilidad\left(n\right) & si\ n\ terminal\\
\max_{s\in SUC(n)}VALOR\_MINIMAX\left(s\right) & si\ n\ es\ de\ MAX\\
\min_{s\in SUC(n)}VALOR\_MINIMAX\left(s\right) & si\ n\ es\ de\ MIN
\end{cases}
\]

\end_inset

 Esto sería un juego óptimo para MAX, suponiendo que MIN también juega de
 forma óptima.
 Pero si MIN no juega de forma óptima, entonces MAX debe seguir la misma
 estrategia, ya que lo hará aún mejor.
\end_layout

\begin_layout Standard
\align left
El pseudocódigo es:
\end_layout

\begin_layout Standard
\align left
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función DECISION-MINIMAX(estado) devuelve acción
\end_layout

\begin_layout Plain Layout

entrada: estado
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	v <- MAX-VALOR(estado)
\end_layout

\begin_layout Plain Layout

	devolver {accion de SUCESORES(estado) con valor v}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

función MAX-VALOR(estado) devuelve {valor utilidad}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	si TEST-TERMINAL(estado) entonces devolver estado.utilidad
\end_layout

\begin_layout Plain Layout

	v <- -infinito
\end_layout

\begin_layout Plain Layout

	para {un s en SUCESORES(estado)} hacer
\end_layout

\begin_layout Plain Layout

		v <- MAX(v,MIN-VALOR(s))
\end_layout

\begin_layout Plain Layout

	devolver v
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

función MIN-VALOR(estado) devuelve {valor utilidad}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	si TEST-TERMINAL(estado) entonces devolver estado.utilidad
\end_layout

\begin_layout Plain Layout

	v <- infinito
\end_layout

\begin_layout Plain Layout

	para {un s en SUCESORES(estado)} hacer
\end_layout

\begin_layout Plain Layout

		v <- MIN(v,MAX-VALOR(s))
\end_layout

\begin_layout Plain Layout

	devolver v
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
El método minimax, por tanto, realiza una exploración primero en profundidad.
 Suponiendo que 
\begin_inset Formula $m$
\end_inset

 es la profundidad máxima y 
\begin_inset Formula $b$
\end_inset

 el número de movimientos legales:
\end_layout

\begin_layout Itemize
\align left
la complejidad en tiempo es 
\begin_inset Formula $O\left(b^{m}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\align left
la complejidad en espacio es
\begin_inset Formula 
\[
\begin{cases}
O\left(bm\right) & \text{si se generan todos los sucesores a la vez}\\
O\left(m\right) & \text{si se generan los sucesores uno por uno}
\end{cases}
\]

\end_inset

 
\end_layout

\begin_layout Standard
\align left
Un árbol MINIMAX es análogo a un árbol Y/O, donde los nodos MAX son nodos
 O y los nodos MIN son nodos Y (si MIN actúa de forma óptima).
\end_layout

\begin_layout Subsubsection
Decisiones óptimas en juegos multijugador
\end_layout

\begin_layout Standard
\align left
Minimax se puede extender a juegos multijugador.
 Para ello, sustituimos el valor para cada nodo con un vector de valores.
 Para los estados terminales, este vector dará la utilidad del estado desde
 el punto de vista de cada jugador.
 Nótese que en juegos de suma cero, el vector de dos elementos puede reducirse
 a un valor porque el otro será el opuesto.
\end_layout

\begin_layout Standard
\align left
Por tanto, debemos hacer que la función utilidad devuelve un vector de utilidade
s.
 El valor hacia atrás de un nodo 
\begin_inset Formula $n$
\end_inset

 es el vector de utilidad de cualquier sucesor que tiene el valor más alto
 para el jugador que elige en ese nodo.
\end_layout

\begin_layout Subsubsection
MINIMAX ALFA-BETA
\end_layout

\begin_layout Standard
La búsqueda minimax provoca un crecimiento exponencial en el número de movimient
os.
 Aunque no se puede eliminar el exponente, se puede dividir.
 Este es el objetivo de la poda alfa-beta.
\end_layout

\begin_layout Standard
La 
\series bold
poda alfa-beta
\series default
 devuelve el mismo movimiento que devuelve minimax, pero podando nodos o
 subárboles que pueden descartarse por seguridad de no empeorar la solución
 actual.
\end_layout

\begin_layout Standard
Llamamos 
\begin_inset Formula $\alpha$
\end_inset

 a la mejor opción (valor más alto) encontrada a lo largo del camino para
 MAX, y 
\begin_inset Formula $\beta$
\end_inset

 al mejor valor (el más bajo) encontrado a lo largo del camino para MIN.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función BUSQUEDA-ALFA-BETA(estado) devuelve acción
\end_layout

\begin_layout Plain Layout

entrada: estado
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	v <- MAX-VALOR(estado,-infinito,infinito)
\end_layout

\begin_layout Plain Layout

	devolver {acción de SUCESORES(estado) con valor v}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

función MAX-VALOR(estado, alpha, beta) devuelve {valor utilidad}
\end_layout

\begin_layout Plain Layout

entrada: estado
\end_layout

\begin_layout Plain Layout

		alpha
\end_layout

\begin_layout Plain Layout

		beta
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	si TEST-TERMINAL(estado) entonces devolver estado.utilidad
\end_layout

\begin_layout Plain Layout

	v <- -infinito
\end_layout

\begin_layout Plain Layout

	para {un s en SUCESORES(estado)} hacer
\end_layout

\begin_layout Plain Layout

		v <- MAX(v,MIN-VALOR(s,alpha,beta))
\end_layout

\begin_layout Plain Layout

		si v>=beta entonces devolver v
\end_layout

\begin_layout Plain Layout

		alpha <- MAX(alpha,v)
\end_layout

\begin_layout Plain Layout

	devolver v
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

función MIN-VALOR(estado, alpha, beta) devuelve {valor utilidad}
\end_layout

\begin_layout Plain Layout

entrada: estado
\end_layout

\begin_layout Plain Layout

		alpha
\end_layout

\begin_layout Plain Layout

		beta
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	si TEST-TERMINAL(estado) entonces devolver estado.utilidad
\end_layout

\begin_layout Plain Layout

	v <- infinito
\end_layout

\begin_layout Plain Layout

	para {un s en SUCESORES(estado)} hacer
\end_layout

\begin_layout Plain Layout

		v <- MIN(v,MAX-VALOR(estado))
\end_layout

\begin_layout Plain Layout

		si v <= alpha entonces devolver v
\end_layout

\begin_layout Plain Layout

		beta <- MIN(beta,v)
\end_layout

\begin_layout Plain Layout

	devolver v
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
La eficacia de la poda alfa-beta es muy dependiente del orden en el que
 se examinan los sucesores.
\end_layout

\begin_layout Itemize
si podemos elegir el mejor orden, alfa-beta tiene que examinar 
\begin_inset Formula $O\left(b^{\frac{d}{2}}\right)$
\end_inset

 nodos para escoger el mejor movimiento, en lugar de 
\begin_inset Formula $O\left(b^{d}\right)$
\end_inset


\end_layout

\begin_layout Itemize
si los sucesores se examinan en orden aleatorio, el número total de nodos
 examinados será aproximadamente 
\begin_inset Formula $O\left(b^{\frac{3d}{4}}\right)$
\end_inset


\end_layout

\begin_layout Subsubsection
Decisiones en tiempo real imperfectas.
 Heurísticas
\end_layout

\begin_layout Standard
\align left
Tanto minimax como alfa-beta tienen que buscar en todos los caminos, o una
 parte de ellos, hasta los estados terminales.
 Esta profundidad no es, en general, práctica, porque los movimientos deben
 hacerse en una cantidad razonable de tiempo.
\end_layout

\begin_layout Standard
\align left
Se propuso que los programas cortasen la búsqueda antes y entonces aplicar
 una función de evaluación heurística a los estados, convirtiendo los nodos
 no terminales en hojas terminales.
 
\end_layout

\begin_layout Standard
\align left
Para este propósito, se sustituye la función de utilidad por una función
 de evaluación heurística que estime la utilidad de la posición, y sustituir
 el test-terminal por un test-límite que decide cuando aplicar la heurística.
\end_layout

\begin_layout Standard
\align left
Se debe llevar el cálculo de la profundidad y poner un límite de profundidad
 fijo, de modo que TEST-LÍMITE(estado, profundidad) devuelva verdadero para
 toda profundidad mayor que una profundidad prefijada 
\begin_inset Formula $d$
\end_inset

, que se elige de modo que la cantidad de tiempo usado no exceda lo permitido
 por las reglas del juego.
\end_layout

\begin_layout Standard
\align left
Un test límite más sofisticado tiene en cuenta que la función de evaluación
 solo debería aplicarse a posiciones estables (es decir, que es improbable
 que sufran grandes variaciones en su valor en un futuro próximo), por lo
 que las no estables se extienden hasta alcanzar posiciones estables.
\end_layout

\begin_layout Subsubsection
Juegos que incluyen un elemento de probabilidad
\end_layout

\begin_layout Standard
Muchos juegos incluyen elementos aleatorios.
 Aún así, queremos escoger el movimiento que conduzca a la mejor posición.
 Como no hay valores minimax definidos, debemos calcular el valor esperado
 (esperanza matemática).
\end_layout

\begin_layout Standard
Para ello, generalizamos el valor minimax para juegos deterministas a un
 valor minimax esperado para juegos con nodos probabilísticos.
\end_layout

\begin_layout Standard
Los nodos terminales y los MAX y los MIN trabajan igual que antes, pero
 los nodos probabilísticos se evalúan tomando el promedio ponderado de los
 valores que se obtienen de todos los resultados posibles:
\begin_inset Formula 
\[
MINIMAXESP\left(n\right)=\begin{cases}
n.utilidad & \text{si \ensuremath{n} es terminal}\\
\max_{s\in SUC\left(n\right)}MINIMAXESP\left(s\right) & \text{si \ensuremath{n} es un nodo MAX}\\
\min_{s\in SUC\left(n\right)}MINIMAXESP\left(s\right) & \text{si \ensuremath{n} es un nodo MIN}\\
\sum_{s\in SUC\left(n\right)}P\left(s\right)\cdot MINIMAXESP(s) & \text{si \ensuremath{n} es un nodo probabilístico}
\end{cases}
\]

\end_inset

 donde 
\begin_inset Formula $P\left(s\right)$
\end_inset

 es la probabilidad de que ocurra 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Representación del conocimiento.
 Razonamiento.
\end_layout

\begin_layout Standard
\align left
Como venimos viendo, el objetivo básico de un sistema inteligente no es
 más que resolver tareas para las que se necesita una gran cantidad de informaci
ón o solo se dispone de descripciones poco estructuradas, incompletas o
 imprecisas.
\end_layout

\begin_layout Standard
\align left
Muchas veces buscamos la consecución de tareas genéricas, que para ser resueltas
 necesitamos tanto de información sobre el dominio como un método genérico
 de resolución independiente, en muchos casos, del dominio de aplicación.
\end_layout

\begin_layout Standard
\align left
Según la información que necesitan, los sistemas inteligentes pueden ser:
\end_layout

\begin_layout Itemize
\align left

\series bold
Intensivos en datos:
\series default
 minan grandes cantidades de datos para obtener conocimiento, que luego
 puede ser usado para resolver una tarea
\end_layout

\begin_layout Itemize
\align left

\series bold
Intensivos en conocimiento:
\series default
 aplican gran cantidad de conocimiento a los datos para obtener conclusiones
 útiles
\end_layout

\begin_layout Standard
\align left
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
Un 
\series bold
sistema basado en conocimiento (SBC)
\series default
 es un sistema inteligente intensivo en conocimiento.
\end_layout

\begin_layout Plain Layout
El 
\series bold
conocimiento
\series default
 no son más que descripciones declarativas y explícitas formadas por:
\end_layout

\begin_layout Itemize
conceptos y relaciones entre los conceptos, específicos del dominio de aplicació
n
\end_layout

\begin_layout Itemize

\series bold
métodos de resolución de problemas (PSM): 
\series default
métodos genéricos que especifiquen paso a paso el proceso para resolver
 la tarea concreta
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
Así, para resolver una tarea, necesitamos:
\end_layout

\begin_layout Itemize
\align left
una representación computacional del conocimiento: conceptos, relaciones
 y PSM
\end_layout

\begin_layout Itemize
\align left
una técnica de razonamiento: que utilice el las relaciones entre conceptos
 para inferir conclusiones, mediante la estructura de control especificada
 por el PSM
\end_layout

\begin_layout Subsubsection*
Representación del conocimiento y razonamiento
\end_layout

\begin_layout Standard
\align left
Es una disciplina de la IA centrada en el diseño de estructuras de datos
 para almacenar conocimiento y el diseño de técnicas de razonamiento capaces
 de manipular esas estructuras para realizar inferencias.
\end_layout

\begin_layout Standard
\align left

\series bold
Tipos de conocimiento:
\end_layout

\begin_layout Itemize
\align left
Conocimiento de entidades: propiedades y estructura física de objetos reales
\end_layout

\begin_layout Itemize
\align left
Conocimiento de conducta: comportamiento o modo de proceder de los entes
 
\end_layout

\begin_layout Itemize
\align left
Conocimiento de eventos: secuencia y distribución temporal de sucesos, así
 como relaciones causales entre los mismos
\end_layout

\begin_layout Itemize
\align left
Conocimiento procedimental: cómo deben realizarse determinados procesos
 o transformaciones
\end_layout

\begin_layout Itemize
\align left
Conocimiento sobre incertidumbre: sobre la certeza de los hechos
\end_layout

\begin_layout Itemize
\align left
Meta-Conocimiento: conocimiento sobre el conocimiento
\end_layout

\begin_layout Standard
\align left

\series bold
Fases de Utilización
\end_layout

\begin_layout Standard
\align left
Se refieren a la etapas en la obtención y uso del conocimiento establecidas
 en distintos paradigmas de la Ingeniería del Conocimiento:
\end_layout

\begin_layout Enumerate
\align left
Adquisición: se extrae el conocimiento de alguna fuente (experto/procesos
 de prueba-error)
\end_layout

\begin_layout Enumerate
\align left
Conceptualización: definición y organización de los distintos componentes
 del conocimiento.
 Constituye el proceso central de la ingeniería del conocimiento
\end_layout

\begin_layout Enumerate
\align left
Representación: diseño de las estructuras de datos que se usarán como soporte
 computacional del conocimiento.
 Por tanto, la representación del conocimiento es declarativa
\end_layout

\begin_layout Enumerate
\align left
Implementación: desarrollo del software que implementa el conocimiento y
 las técnicas de inferencia, que suele ser procedimental
\end_layout

\begin_layout Enumerate
\align left
Acceso: relacionado con la forma de extraer el conocimiento desde una representa
ción estructurada.
 Factores como la velocidad de acceso son muy relevantes (grandes cantidades
 de datos o funcionamiento en tiempo real)
\end_layout

\begin_layout Enumerate
\align left
Selección o recuperación: fase en la que hay que seleccionar un elemento
 del conocimiento concreto, adecuado al problema y al estado del proceso
 de resolución del mismo.
 A menudo se utiliza meta-conocimiento
\end_layout

\begin_layout Standard
\align left

\series bold
Propiedades de las Representaciones del Conocimiento
\end_layout

\begin_layout Itemize
\align left
Ámbito: extensión del dominio en el que se va a aplicar el conocimiento.
 Se considera imposible definir conocimiento que abarque cualquier contexto
 de aplicación.
\end_layout

\begin_layout Itemize
\align left
Granularidad: tamaño de la unidad mínima de representación.
\end_layout

\begin_deeper
\begin_layout Itemize
\align left
Grano de gran tamaño: permite representar fácilmente conceptos de alto nivel,
 pero presenta un difícil tratamiento y procesamiento
\end_layout

\begin_layout Itemize
\align left
Grano pequeño: permite representar conceptos de bajo nivel, construir estructura
s jerárquicas y su tratamiento es más sencillo, pero complica la tarea de
 representar conceptos de alto nivel
\end_layout

\end_deeper
\begin_layout Itemize
\align left
Redundancia: responde a si es posible o tiene sentido representar un mismo
 conocimiento de múltiples formas.
 Como inconveniente presenta que abandonamos la unicidad del conocimiento,
 pero tiene como ventaja que genera una diversidad que permite una aplicación
 más efectiva del conocimiento, ganando en generalidad
\end_layout

\begin_layout Itemize
\align left
Modularidad: posibilidad de agrupar gránulos de conocimiento en módulos,
 asociados a distintos pasos de un PSM.
 Esto facilita su recuperación, así como el diseño
\end_layout

\begin_layout Itemize
Comprensibilidad: capacidad de interpretar las estructuras de representación
\end_layout

\begin_layout Subsection
Sistemas Basados en Reglas (SBR)
\end_layout

\begin_layout Standard
La lógica, si bien no describe de forma precisa ni completa el proceso de
 razonamiento humano en general, es ciertamente una buena herramienta de
 descripción de algunos razonamientos concretos.
 Concretamente, la lógica la utilizamos cuando de una serie de sucesos,
 extraemos la causa y la consecuencia.
 Como ejemplo, podemos pensar en que estamos plantados frente a un interruptor
 cuya función desconocemos, lo pulsamos, y se enciende una luz azul.
 Concluiremos entonces que, a causa de pulsar el botón, la luz azul se ha
 encendido.
 De esta forma, la lógica trata de formalizar este proceso de relacionar
 causas y efectos.
\end_layout

\begin_layout Standard
En este sentido, podríamos plantear la posibilidad de dotar a los ordenadores
 de sistemas lógicos de razonamiento, de forma que proporcionándoles una
 serie de inputs (que en analogía con los humanos serían lo que detectamos
 mediante nuestros sentidos), usen unas reglas que relacionan y distinguen
 las causas de los efectos (para nosotros esto es la experiencia, lo que
 hemos aprendido) y extraigan las consecuencias que derivan de esos inputs.
 Y esto precisamente son los 
\series bold
Sistemas Basados en Reglas (SBR)
\series default
, la implementación en un ordenador de un sistema lógico de deducción formal.
 En ocasiones se denominan Sistemas Expertos, porque las reglas de inferencia
 son proporcionadas por expertos en la materia en la que estamos interesados
 en hacer predicciones.
\end_layout

\begin_layout Subsubsection
Componentes de un SBR
\end_layout

\begin_layout Itemize
\noindent
\align left

\series bold
Base de Conocimiento (BC)
\series default
: contiene las 
\series bold
reglas
\series default
 que codifican el conocimiento sobre la materia de estudio.
 Las reglas, a su vez, tienen dos partes:
\end_layout

\begin_deeper
\begin_layout Itemize
\noindent
\align left
Condición, consecuente o Left Hand Side (LHS): codifica la causa que precede
 a un efecto.
\end_layout

\begin_layout Itemize
\noindent
\align left
Consecuente o Right Hand Side (RHS): codifica el efecto producido por la
 causa.
\end_layout

\begin_layout Standard
\noindent
\align left
Es decir, las reglas son un par causa-efecto, normalmente expresado como
 
\series bold
Si
\series default
 causa 
\series bold
Entonces
\series default
 efecto.
\end_layout

\end_deeper
\begin_layout Itemize
\noindent
\align left

\series bold
Base de Hechos (BH)
\series default
: representa el estado actual de resolución de un problema concreto.
 Contiene los inputs del problema, las consecuencias inferidas a lo largo
 del razonamiento, y las metas a alcanzar o consecuencias finales que buscamos
 conocer.
\end_layout

\begin_layout Itemize
\noindent
\align left

\series bold
Motor de Inferencias (MI)
\series default
: es el mecanismo algorítmico que utiliza la BC y la BH para obtener conclusione
s.
 Los motores de inferencia pueden trabajar de dos formas:
\end_layout

\begin_deeper
\begin_layout Itemize
\noindent
\align left
Razonamiento hacia delante: parte de los hechos conocidos, y usando las
 reglas obtiene las consecuencias derivables de estos.
 Responde a la cuestión: ¿Qué efectos tendrán estos hechos conocidos?
\end_layout

\begin_layout Itemize
\noindent
\align left
Razonamiento hacia atrás: parte de las consecuencias que deseamos saber
 si se verifican, y usa las reglas, hacia atrás, para ver si, con los hechos
 conocidos, se verifican las consecuencias buscadas.
 Responde a la cuestión: ¿Ocurrirán estas consecuencias, dados estos hechos?
\end_layout

\end_deeper
\begin_layout Itemize
\noindent
\align left

\series bold
Red de inferencia
\series default
: es un grafo dirigido en el que los nodos son las reglas, representadas
 mediante puertas lógicas.
 Las condiciones del antecedente son las entradas a los nodos y los efectos
 son las salidas, que pueden ser las condiciones de otros nodos.
 Los antecedentes que no son consecuentes de ninguna otra regla son los
 posibles hechos de partida; y el consecuente que no es antecedente de ninguna
 otra regla se convierte en la meta a alcanzar por el sistema.
 La red de inferencia resulta de utilidad cuando no hay una gran cantidad
 de reglas.
\end_layout

\begin_layout Standard
\noindent
\align left
Es importante notar que la Base de Conocimiento describe todo nuestro conocimien
to acerca del problema general que estamos tratando, mientras que la base
 de hechos es dependiente de las circunstancias específicas de cada situación.
 Por ejemplo, un SBR que diferencia sillas de mesas, debería tener una BC
 en la que se proporcione la información necesaria para diferenciar una
 mesa de una silla, y en la BH tendremos, por ejemplo, fotos de las sillas
 y mesas concretas que buscamos diferenciar.
\end_layout

\begin_layout Standard
\noindent
\align left
Además, la BC y la BH trabajan en conjunción, unidas por la MI, una sola
 de ellas es inútil si no se dispone de la otra.
 Las reglas de la BC operan sobre la BH, la condición de una regla debe
 tratar de verificarse con los datos de la BH; y si uno de estos test se
 verifica, entonces obtendremos una consecuencia, que puede propiciar cambios
 en el contenido de la BH.
\end_layout

\begin_layout Subsection
Representación mediante Lógicas no Clásicas
\end_layout

\begin_layout Standard
\align left
Los primeros sistemas de razonamiento estaban basados en lógicas clásicas
 (proposicional y de primer orden), pero esto presenta varios inconvenientes:
\end_layout

\begin_layout Itemize
\align left
los algoritmos para manipular conocimiento lógico son ineficientes
\end_layout

\begin_layout Itemize
\align left
las lógicas clásicas no pueden tratar conocimiento incompleto, incierto,
 impreciso o inconsistente
\end_layout

\begin_layout Itemize
\align left
la expresividad es limitada
\end_layout

\begin_layout Standard
\align left
Pero hay muchas otras lógicas, la mayoría diseñadas específicamente para
 superar ciertas deficiencias de la lógica clásica.
 En general, un sistema para la manipulación del conocimiento puede ser
 considerado como una lógica si contiene:
\end_layout

\begin_layout Itemize
\align left
Un 
\series bold
lenguaje
\series default
 bien definido para representar conocimiento
\end_layout

\begin_layout Itemize
\align left
Una teoría de modelos o 
\series bold
semántica
\series default
 bien definida que se ocupe del significado de declaraciones expresadas
 en el lenguaje
\end_layout

\begin_layout Itemize
\align left
Una 
\series bold
teoría de demostración
\series default
 que se ocupe de la manipulación sintáctica y de la obtención de declaraciones
 a partir de otras declaraciones
\end_layout

\begin_layout Subsubsection
Lógicas no monótonas
\end_layout

\begin_layout Standard
\align left
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
Una 
\series bold
lógica es monótona
\series default
 si cuando se añade un axioma o un teorema propio a una teoría 
\begin_inset Formula $T$
\end_inset

 para obtener una teoría 
\begin_inset Formula $T'$
\end_inset

, entonces todos los teoremas de 
\begin_inset Formula $T$
\end_inset

 son también teoremas en 
\begin_inset Formula $T'$
\end_inset

.
\end_layout

\begin_layout Plain Layout
Por contra, en una 
\series bold
lógica no monótona
\series default
 la incorporación de un teorema a una teoría puede invalidar conclusiones
 que podrían haberse hecho previamente.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
Hay al menos tres circunstancias en las que el razonamiento no monótono
 puede ser adecuado:
\end_layout

\begin_layout Itemize
\align left
cuando el conocimiento es incompleto deben hacerse suposiciones por defecto,
 que puedan invalidarse cuando se disponga de más conocimiento
\end_layout

\begin_layout Itemize
\align left
cuando el universo es cambiante
\end_layout

\begin_layout Itemize
\align left
en resolución de problemas donde deban hacerse suposiciones temporales
\end_layout

\begin_layout Standard
\align left
Las lógicas clásicas son 
\series bold
estáticas
\series default
, es decir, que una vez que se establece que una afirmación es cierta, siempre
 será así (si no el sistema no sería consistente y no serviría de mucho).
 Nótese que esto restringe mucho los problemas atacables con lógica clásica,
 por los motivos que ya hemos comentado.
\end_layout

\begin_layout Subsection*
Lógica de Situaciones
\end_layout

\begin_layout Standard
\align left
En un mundo cambiante, los hechos pueden ser ciertos en determinadas situaciones
 y pasar a ser falsos en otras, o al revés.
 La lógica de situaciones es una forma de modelar un mundo cambiante.
 En ella, los predicados tienen un argumento extra que denota en qué situación
 la afirmación es verdadera.
 
\end_layout

\begin_layout Standard
\align left
Las situaciones y eventos se relacionan mediante una relación, 
\begin_inset Formula $R$
\end_inset

, de forma que 
\begin_inset Formula $R\left(e,s\right)$
\end_inset

 denota la situación que se obtiene cuando ocurre 
\begin_inset Formula $e$
\end_inset

 en la situación 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Subsection*
Lógica Difusa: representación de la vaguedad
\end_layout

\begin_layout Standard
\align left
Históricamente, las ciencias formales han restringido el uso del lenguaje
 natural a aquellos predicados que, aplicados a un dominio, lo dividen en
 subconjuntos claramente delimitados (por ejemplo, decir los 
\begin_inset Formula $números\ pares$
\end_inset

, divide a los naturales en dos subconjuntos sin lugar a confusión sobre
 si un elemento está en un conjunto u otro).
 En el mundo real, en cambio, es muy frecuente encontrarse con afirmaciones
 vagas, que no permiten realizar una división satisfactoria del dominio
 (por ejemplo, los 
\begin_inset Formula $altos$
\end_inset

 no son un subconjunto de la población claramente diferenciado.
 Otra cosa sería decir, la 
\begin_inset Formula $gente\ que\ mide\ más\ de\ 1.80m,\ recién\ levantados$
\end_inset

, que sí que proporciona una división precisa de la población).
\end_layout

\begin_layout Standard
\align left
Estos 
\series bold
predicados vagos
\series default
 están presentes en el lenguaje ordinario y son un elemento fundamental
 en el razonamiento humano.
 Pero la falta de nitidez de estos predicados supone una fuente de incosistencia
s (ya que un individuo podría ser al mismo tiempo alto y no alto, dependiendo
 de la interpretación que hagamos de ser alto).
 Así, un predicado vaho puede definirse como aquel en que la frontera del
 conjunto de objetos que cumplen la propiedad representada por el predicado
 no está bien definida.
 O sea 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $x$
\end_inset

 es 
\begin_inset Formula $A$
\end_inset


\begin_inset Quotes erd
\end_inset

 es vago si 
\begin_inset Formula $A$
\end_inset

 no tiene la frontera bien marcada.
 Nótese que la incertidumbre no se encuentra en el mundo externo (la altura
 es cuantificable y en un momento concreto es fija), sino que la incertidumbre
 se encuentra en el término linguístico que trata de describir la propiedad
 (la palabra 
\begin_inset Formula $alto$
\end_inset

 no especifica a partir de qué altura ni en qué circunstancias se realiza
 la medición).
\end_layout

\begin_layout Standard
\align left
Podemos, entonces, razonar a partir de afirmaciones vagas, usando 
\series bold
razonamiento aproximado
\series default
.
 Por ejemplo, si estamos ante la regla
\begin_inset Formula 
\[
x\ pequeño\implies x\ ligero
\]

\end_inset

 y nos proporcionan la siguiente información o hecho
\begin_inset Formula 
\[
x\ ocupa\ 1cm^{3}
\]

\end_inset

 entonces, en lógica clásica no podemos equiparar el hecho con el antecedente
 de la regla, ya que 
\begin_inset Formula $pequeño$
\end_inset

 es una expresión vaga.
 No obstante, en el mundo real, se produce un emparejamiento parcial entre
 el hecho y la condición de la regla, y es posible inferir alguna conclusión.
 Por ejemplo, si estamos en un contexto de paquetes de envíos, 
\begin_inset Formula $1cm^{3}$
\end_inset

 se puede considerar pequeño, por lo que se puede concluir que 
\begin_inset Formula $x$
\end_inset

 es ligero y, por ejemplo, aplicar la tarifa 
\begin_inset Quotes eld
\end_inset

paquetes ligeros
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\align left
A partir de estos conceptos, se definen los 
\series bold
conjuntos difusos
\series default
, que suponen un salto cualitativo en la relación entre la ciencia y el
 lenguaje ante la necesidad de herramientas formales para su análisis.
 Estas herramientas las proporciona la 
\series bold
teoría de los conjuntos difusos
\series default
 y la ciencia que aporta los principios formales del razonamiento aproximado
 es la 
\series bold
lógica difusa
\series default
.
\end_layout

\begin_layout Subsubsection*
Conjuntos precisos o clásicos VS Conjuntos difusos
\end_layout

\begin_layout Standard
\align left
En lógica clásica, la noción de predicado está íntimamente ligada a la de
 conjunto.
 En general, todo predicado preciso 
\begin_inset Formula $P\left(x\right)$
\end_inset

 aplicado a un dominio 
\begin_inset Formula $U$
\end_inset

 tiene asociado un conjunto preciso, 
\begin_inset Formula $P\subset U$
\end_inset

, formado por 
\begin_inset Formula $P=\left\{ x\in U:P\left(x\right)=true\right\} $
\end_inset

.
 Este conjunto puede definirse, entonces, mediante una función de pertenencia
 (función característica) que describe la pertenencia de cada elemento de
 
\begin_inset Formula $U$
\end_inset

 a 
\begin_inset Formula $P$
\end_inset

 como un valor en 
\begin_inset Formula $\left\{ 0,1\right\} $
\end_inset


\begin_inset Formula 
\[
\begin{array}{ccc}
\mu_{P}:U & \rightarrow & \left\{ 0,1\right\} \\
x & \mapsto & \begin{cases}
0 & x\notin P\\
1 & x\in P
\end{cases}
\end{array}
\]

\end_inset

 de tal forma que 
\begin_inset Formula $\mu_{P}\left(x\right)=0\implies P\left(x\right)=false$
\end_inset

 y 
\begin_inset Formula $\mu_{P}\left(x\right)=1\implies P\left(x\right)=true$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Sin embargo, al aplicar un predicado vago, 
\begin_inset Formula $A\left(x\right)$
\end_inset

, a un dominio 
\begin_inset Formula $U$
\end_inset

, obtenemos un conjunto difuso 
\begin_inset Formula $A\subset U$
\end_inset

, definido mediante una función de pertenencia de cada elemento de 
\begin_inset Formula $U$
\end_inset

 a 
\begin_inset Formula $A$
\end_inset

 coo un grado en 
\begin_inset Formula $\left[0,1\right]$
\end_inset

, donde el 0 indica que seguro que 
\begin_inset Formula $x$
\end_inset

 no verifica 
\begin_inset Formula $A$
\end_inset

, y el 1 que seguro que sí (es como una probabilidad de que 
\begin_inset Formula $x$
\end_inset

 verifique la propiedad 
\begin_inset Formula $A$
\end_inset

).
\begin_inset Formula 
\[
\begin{array}{ccc}
\mu_{A}:U & \rightarrow & \left[0,1\right]\\
x & \mapsto & \mu_{A}\left(x\right)\in\left[0,1\right]
\end{array}
\]

\end_inset


\end_layout

\begin_layout Subsection
Representación y razonamiento con incertidumbre
\end_layout

\begin_layout Standard
En muchos sistemas inteligentes es preciso considerar hechos cuya fiabilidad
 y precisión es limitada, y conocimiento del que no se tiene total certeza.
 Por tanto, debemos resolver dos problemas:
\end_layout

\begin_layout Itemize

\series bold
Representación
\series default
: necesitamos formalismos que capturan y soportan incertidumbre, así como
 establecer medidas formales de la incertidumbre
\end_layout

\begin_layout Itemize

\series bold
Razonamiento
\series default
: gestión de la incertidumbre en los procesos de inferencia.
 Técnicas formales para la propagación y combinación de afirmaciones inciertas
\end_layout

\begin_layout Standard
Es frecuente incorporar la incertidumbre sobre una representación que originalme
nte no la incluye, para aumentar su ámbito de aplicación.
 Se hace necesario diferenciar entre:
\end_layout

\begin_layout Itemize

\series bold
impreciso
\series default
: ambiguo, no concreto, no detallado
\end_layout

\begin_layout Itemize

\series bold
incierto
\series default
: hechos, afirmaciones o sucesos carentes de verdad absoluta o seguridad
 de ocurrencia
\end_layout

\begin_layout Subsubsection
Teoría de la certidumbre o de los factores de certeza
\end_layout

\begin_layout Standard
\align left
No todo (de hecho, casi nada) son hechos factuales que conocemos con seguridad,
 y cuyas consecuencias conocemos con certeza.
 Normalmente, trabajamos con incertidumbre y las conclusiones obtenidas
 a partir de una causa suelen tener un cierto grado de fiabilidad.
\end_layout

\begin_layout Standard
\align left
Para este propósito incorporamos el concepto de 
\series bold
Factor de Certeza
\series default
, que se entiende como la credibilidad del consecuente o hipótesis en función
 de la conjunción de antecedentes o evidencias.
 Los factores de certeza, en última instancia, son valoraciones subjetivas
 proporcionadas por los expertos en la materia a estudio.
\end_layout

\begin_layout Standard
\align left
Formalmente, se define en términos de dos componentes subjetivos:
\end_layout

\begin_layout Itemize
\align left
MC(h,e): medida de la creencia en la hipótesis h, dada la evidencia e.
 
\begin_inset Formula $MC(h,e)\in[0,1]\ y\ MC(h,e)=0$
\end_inset

 si la evidencia no soporta a h.
\end_layout

\begin_layout Itemize
\align left
MI(h,e): medida de la incredulidad en la hipótesis h, dada la evidencia
 e.
 
\begin_inset Formula $MI(h,e)\in[0,1]\ y\ MC(h,e)=0$
\end_inset

 si la evidencia soporta a h.
\end_layout

\begin_layout Standard
\align left
Es de notar que una misma evidencia no puede, al mismo tiempo, apoyar la
 creencia y la incredulidad de una hipótesis, es decir: 
\end_layout

\begin_layout Standard
\align left
\begin_inset Formula 
\[
MC(h,e)>0\implies MI(h,e)=0
\]

\end_inset


\begin_inset Formula 
\[
MI(h,e)>0\implies MC(h,e)=0
\]

\end_inset


\end_layout

\begin_layout Standard
\align left
Y el factor de certeza se define como 
\begin_inset Formula 
\[
FC(h,e)=MC(h,e)-MI(h,e)
\]

\end_inset

 de forma que 
\begin_inset Formula $FC(h,e)\in[-1,1]$
\end_inset


\end_layout

\begin_layout Standard
\align left
Por último, debemos combinar nuestro método de razonamiento explicado anteriorme
nte con la existencia de incertidumbre, para ello debemos definir la forma
 en la que los factores de certeza se combinan al usar distintas reglas,
 obtener nueva evidencia a favor o en contra de algunos hechos, etc.
\end_layout

\begin_layout Standard
\align left
Para ello, debemos distinguir los posibles casos con los que nos podemos
 encontrar:
\end_layout

\begin_layout Itemize
\align left

\series bold
Combinación de antecedentes:
\series default
 combinamos las piezas de evidencia 
\begin_inset Formula $e_{1},\ y\ e_{2}$
\end_inset

, que afectan al factor de certeza de h: 
\begin_inset Formula 
\[
FC(h,e_{1}\land e_{2})=\min\{FC(h,e_{1}),FC(h,e_{2})\}
\]

\end_inset


\begin_inset Formula 
\[
FC(h,e_{1}\lor e_{2})=\max\{FC(h,e_{1}),FC(h,e_{2})\}
\]

\end_inset


\end_layout

\begin_layout Itemize
\align left

\series bold
Adquisición incremental de evidencia:
\series default
 cuando dos evidencias afectan de forma distinta (mediante reglas diferentes)
 a una hipótesis: 
\end_layout

\begin_layout Itemize
\align left
\begin_inset Formula 
\[
FC(h,e_{1}\land e_{2})=\begin{cases}
FC(h,e_{1})+FC(h,e_{2})\cdot(1-FC(h,e_{1})), & \text{si \ensuremath{FC(h,e_{1}),FC(h,e_{2})\geq0}}\\
FC(h,e_{1})+FC(h,e_{2})\cdot(1+FC(h,e_{1})), & \text{si \ensuremath{FC(h,e_{1}),FC(h,e_{2})\leq0}}\\
\frac{FC(h,e_{1})+FC(h,e_{2})}{1-\min\{|FC(h,e_{1})|,|FC(h,e_{2})|\}}, & \text{si \ensuremath{FC(h,e_{1})\cdot FC(h,e_{2})<0}}
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Itemize
\align left

\series bold
Encadenamiento de evidencia:
\series default
 se combinan dos reglas, tales que el resultado de una es la entrada de
 la otra: 
\begin_inset Formula 
\[
FC(h,e)=FC(h,s)*\max\{0,FC(s,e)\}
\]

\end_inset

 donde las reglas han sido de la forma R1: Si e Entonces s; y R2: Si s Entonces
 h.
\end_layout

\begin_layout Subsubsection*
¿Qué mide el factor de certeza asociado a un hecho?
\end_layout

\begin_layout Standard
\align left
El factor de certeza es la probabilidad subjetiva que un experto da a la
 veracidad de un hecho a partir de la evidencia disponible.
 Aunque no siempre es directamente proporcionado por el experto, sino que
 puede ser inferido a partir de los hechos y los factores de certeza de
 otros hechos anteriores.
 En este caso, el significado del FC es el mismo, pero ahora no ha sido
 asignado directamente por el experto, sino que ha sido derivado mediante
 el proceso de inferencia.
\end_layout

\begin_layout Subsection
Representaciones estructuradas del conocimiento
\end_layout

\begin_layout Standard
\align left
No existe actualmente una forma general de representación del conocimiento
 capaz de ser usada con éxito en todo tipo de aplicación; las formas disponibles
 están limitadas a dominios específicos.
 Entre las representaciones más usadas encontramos:
\end_layout

\begin_layout Itemize
\align left

\series bold
Redes semánticas:
\series default
 técnica basada en grafos que pretende modelar los mecanismos de memoria
 humanos, haciendo énfasis en nuestra capacidad de recuperar conceptos a
 través de las relaciones que los enlazan
\end_layout

\begin_layout Itemize
\align left

\series bold
Marcos o Frames:
\series default
 técnica basada en estructuras parecidas a formularios, que es preciso rellenar
 e inferencia basada en herencia
\end_layout

\begin_layout Standard
\align left
Más adelante, se adoptó el término 
\series bold
ontología
\series default
 para los esquemas de representación del conocimiento basadas en redes semántica
s o marcos.
 Es una escificación formal y explícita de una conceptualización compartida,
 que puede ser léida por un ordenador.
 Se utiliza en el ámbito de la ingeniería del conocimiento para referirse
 a un conjunto de conceptos organizados jerárquicamente, representados en
 algún sistema informático cuya utilidad es la de servir de soporte a diversas
 aplicaciones que requieren de conocimiento específico sobre la materia
 que la ontología representa.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Planificar para la resolución de problemas
\end_layout

\begin_layout Standard
\align left
El 
\series bold
problema de la planificación
\series default
 consiste en la dificultad de llevar un sistema inteligente a resolver problemas
 del mundo real, en el que se pueden llevar a cabo infinidad de acciones
 distintas, aunque queremos que el sistema solo ejecute un subconjunto muy
 reducido de todas las posibles acciones.
 Por tanto, se debe identificar ese conjunto de acciones que debe ser capaz
 de realizar el sistema inteligente, y cómo cambia el mundo cada acción.
\end_layout

\begin_layout Standard
\align left
\begin_inset Flex Color Box
status open

\begin_layout Plain Layout

\series bold
Definición
\end_layout

\begin_layout Plain Layout
Se denomina 
\series bold
planificar
\series default
 a la tarea de obtener una secuencia de acciones que permita llegar a un
 estado objetivo.
\end_layout

\begin_layout Plain Layout
La secuencia de acciones obtenida se denomina 
\series bold
plan
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
En principio, un problema de planificación podría resolverse aplicando técnicas
 de búsqueda, pero esto no es factible en la práctica, porque el espacio
 de búsqueda, como adelantábamos, suele ser extraordinariamente complejo,
 los problemas reales de planificación no suelen ser descomponibles en problemas
 independientes, y los estados de búsqueda suelen requerir descripciones
 complejas.
\end_layout

\begin_layout Subsection
Descomposición y Problemas Interactivos
\end_layout

\begin_layout Standard
Un 
\series bold
sistema planificador
\series default
 es esencialmente un sistema de descomposición de problemas.
 Usa técnicas de búsqueda diferentes a las estudiadas.
 Para generar un plan, un sistema planificador necesita de:
\end_layout

\begin_layout Itemize
una descripción del estado inicial del problema
\end_layout

\begin_layout Itemize
un objetivo
\end_layout

\begin_layout Itemize
un conjunto de acciones, operadores o reglas
\end_layout

\begin_layout Standard
La eficacia del sistema depende de la complejidad de las reglas disponibles.
 Así, el diseño de reglas debería ser modular y completo, es decir, que
 permita alcanzar el objetivo.
\end_layout

\begin_layout Standard
Nos vamos a encontrar con los siguientes problemas:
\end_layout

\begin_layout Itemize

\series bold
problema del marco o estructura
\series default
: cuando se ejecuta una regla, ¿qué permanece sin cambios?
\end_layout

\begin_layout Itemize

\series bold
problema de la cualificación
\series default
: ¿qué necesita una regla en su entorno para ejecutarse?
\end_layout

\begin_layout Itemize

\series bold
problema de la ramifiación
\series default
: ¿qué elementos relevantes del entorno se modifican?
\end_layout

\begin_layout Subsubsection
Métodos de planificación
\end_layout

\begin_layout Itemize

\series bold
Lineal:
\series default
 presenta una lista ordenada de todas las acciones a realizar, ordenadas
 con un orden total.
 Es decir, se realiza una acción tras de otra en el orden especificado.
\end_layout

\begin_layout Itemize

\series bold
No Lineal
\series default
: un plan no es necesariamente una lista ordenada, sino que puede ser una
 ordenación parcial de las acciones a realizar para conseguir un objetivo.
 La ordenación parcial debe respetar os prerrequisitos de cada acción.
\end_layout

\begin_layout Itemize

\series bold
Jerárquico
\series default
: para establecer un plan se pueden establecer aproximaciones sucesivas.
 Tras un primer plan general se va refinando jerárquicamente hasta el nivel
 de detalle que requiera el problema.
\end_layout

\begin_layout Subsubsection
Componentes de un sistema de planificación
\end_layout

\begin_layout Standard
Recordemos que utilizamos la lógica proposicional de primer orden (LPPO),
 por lo que las descripciones serán fórmulas bien formadas de la lógica
 (fbfs).
 Consideraremos el lenguaje de planificación STRIPS, que hereda muchos aspectos
 de la lógica de situaciones, que especificaba cómo las situaciones, descritas
 en LPPO, se veían afectadas por als acciones de un agente.
\end_layout

\begin_layout Standard
Así, un 
\series bold
problema STRIPS
\series default
, se define como una tupla:
\end_layout

\begin_layout Itemize

\series bold
estado inicial
\series default
: conjunto de fbfs.
 En general, tanto el estado inicial como los estados intermedios se describen
 mediante conjunciones de literales básicos
\end_layout

\begin_layout Itemize

\series bold
estado objetivo
\series default
: condición descriptiva del objetivo.
 Se expresarán como conjunciones de literales y todas las variables se cuantific
arán existencialmente
\end_layout

\begin_layout Itemize

\series bold
conjunto de acciones
\series default
: u operadores útiles para la elaboración del plan.
 Estas acciones generan nuevos estados, por lo que pueden verse como reglas
 que cambian la descripción de un estado a otra.
 Constan de:
\end_layout

\begin_deeper
\begin_layout Itemize
Antecedente: la fórmula de precondición 
\begin_inset Formula $\left(P\right)$
\end_inset

, es una conjunción de literales cuyas variables tienen cuantificación existenci
al.
 Para poder aplicar una regla, la fórmula debe ser cierta en el contexto
 actual del mundo.
 Si se halla algún emparejamiento, se dice que la precondición empareja
 con los hechos.
 La composición unificadore se denomina sustitución de emparejamiento.
 Cada sustitución es una posible aplicación de la regla.
\end_layout

\begin_layout Itemize
Consecuente: formado por:
\end_layout

\begin_deeper
\begin_layout Itemize
los elementos que dejan de ser ciertos (lista de supresión 
\begin_inset Formula $\left(S\right)$
\end_inset

): al aplicar una regla, el emparejamiento se aplica a los literales de
 la lista de supresión, y las particularizaciones se suprimen de la descripción
 del estado
\end_layout

\begin_layout Itemize
aquellos que pasan a ser ciertos (fórmula de adición
\begin_inset Formula $\left(A\right)$
\end_inset

): al aplicar una regla, el emparejamiento se aplica a la lista de adición,
 y las particularizaciones se añaden a la descripción del estado
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Planificación de Orden Total
\end_layout

\begin_layout Subsubsection
Planificación como Búsqueda en un Espacio de Estados
\end_layout

\begin_layout Standard
\align left
El enfoque más simple en planificación consiste en considerarla como un
 problema de búsqueda en el que aplicamos las técnicas de búsqueda que ya
 conocemos.
 El 
\series bold
objetivo de la planificación
\series default
 equivale a un estado final, las 
\series bold
acciones disponibles
\series default
 equivalen a los operadores de búsquedas y se generará un árbol de búsqueda
 cuyos nodos equivalen a estados.
\end_layout

\begin_layout Standard
\align left
Como las descripciones de acciones especifican tanto precondiciones como
 efectos, es posible realizar la búsqueda en ambas direcciones, hacia delante
 y hacia atrás.
\end_layout

\begin_layout Subsubsection*
Sistema de resolución hacia delante
\end_layout

\begin_layout Itemize
\noindent
\align left
Usa la descripción del estado actual como base de datos global
\end_layout

\begin_layout Itemize
\noindent
\align left
Los operadores son reglas tipo STRIPS
\end_layout

\begin_layout Itemize
\noindent
\align left
Seleccionamos reglas aplicables hasta que se produzca una descripción del
 estado que satisfaga la expresión objetivo
\end_layout

\begin_layout Subsubsection*
Sistema de resolución hacia atrás
\end_layout

\begin_layout Enumerate
\noindent
\align left
Partimos de la expresión objetivo usada como base de datos global
\end_layout

\begin_layout Enumerate
\noindent
\align left
Llegamos al estado inicial mediante aplicación de reglas inversas, que transform
an expresiones de objetivos en expresiones de subobjetivos
\end_layout

\begin_layout Standard
\align center
//CAUTION ZONE//
\end_layout

\begin_layout Standard
\align center
//Esta parte está tan mal explicada que no soy capaz de condensarla de forma
 clara//
\end_layout

\begin_layout Standard
\noindent
\align left
Así, sea una regla concreta 
\begin_inset Formula $D$
\end_inset

, con precondición 
\begin_inset Formula $P$
\end_inset

 y adición 
\begin_inset Formula $A$
\end_inset

, y el objetivo 
\begin_inset Formula $\left\{ L\land G_{1}\land...\land G_{N}\right\} $
\end_inset

.
 Entonces, aplicamos 
\begin_inset Formula $D$
\end_inset

 de forma inversa para generar un subobjetivo 
\begin_inset Formula $S$
\end_inset

 a partir del objetivo:
\end_layout

\begin_layout Itemize
\noindent
\align left
para llegar al objetivo concreto se hace a través de la operación de adición
\end_layout

\begin_layout Itemize
\noindent
\align left
supongamos que en 
\begin_inset Formula $A$
\end_inset

 tenemos un 
\begin_inset Formula $L'$
\end_inset

 que se unifica con 
\begin_inset Formula $L$
\end_inset

 mediante un unificador más general 
\begin_inset Formula $u$
\end_inset

, y la particularización de las precondiciones es 
\begin_inset Formula $Pu$
\end_inset

.
 Entonces, los literales de 
\begin_inset Formula $Pu$
\end_inset

 son un subconjunto del subobjetivo buscado, pues serán necesarios para
 aplicar 
\begin_inset Formula $D$
\end_inset


\end_layout

\begin_layout Itemize
\noindent
\align left
en el subobjetivo debemos incluir, también, 
\begin_inset Formula $G_{1}'\land...\land G_{N}'$
\end_inset

, que deben ser tales que al aplicar la particularización de la regla 
\begin_inset Formula $D$
\end_inset

 a una descripción de estado que satisfaga esas expresiones, produzca una
 descripción que satisfaga 
\begin_inset Formula $G_{1}\land...\land G_{N}$
\end_inset

.
 A este proceso se le denomina 
\series bold
regresión
\end_layout

\begin_layout Standard
\noindent
\align left
Entonces, el 
\series bold
proceso de regresión
\series default
 de un literal 
\begin_inset Formula $G$
\end_inset

 es el siguiente:
\end_layout

\begin_layout Itemize
\noindent
\align left
denotamos 
\begin_inset Formula $R\left[G,D_{u}\right]$
\end_inset

 a la regresión de 
\begin_inset Formula $G$
\end_inset

 (o sea, 
\begin_inset Formula $G'$
\end_inset

) a través de la regla 
\begin_inset Formula $D$
\end_inset

 con precondición 
\begin_inset Formula $P$
\end_inset

, lista de supresión 
\begin_inset Formula $S$
\end_inset

 y de adición 
\begin_inset Formula $A$
\end_inset


\end_layout

\begin_layout Itemize
\noindent
\align left
sean 
\begin_inset Formula $S_{u},A_{u}$
\end_inset

 las particularizaciones de los literales de 
\begin_inset Formula $A$
\end_inset

 y 
\begin_inset Formula $S$
\end_inset

 para 
\begin_inset Formula $D_{u}$
\end_inset

, entonces:
\end_layout

\begin_deeper
\begin_layout Itemize
\noindent
\align left
si 
\begin_inset Formula $G_{u}$
\end_inset

 es un literal de 
\begin_inset Formula $S_{u}$
\end_inset

 entonces 
\begin_inset Formula $R\left[G,D_{u}\right]=False$
\end_inset

 y 
\begin_inset Formula $D$
\end_inset

 no es aplicable
\end_layout

\begin_layout Itemize
\noindent
\align left
si 
\begin_inset Formula $G_{u}$
\end_inset

 es un literal de 
\begin_inset Formula $A_{u}$
\end_inset

 entonces 
\begin_inset Formula $R\left[G,D_{u}\right]=True$
\end_inset

 y no se añade
\end_layout

\begin_layout Itemize
\noindent
\align left
en otro caso, 
\begin_inset Formula $R\left[G,D_{u}\right]=G_{u}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\align center
//END CAUTION ZONE//
\end_layout

\begin_layout Standard
\noindent
\align left
Entonces, aplicando todas las reglas inversas el espacio de subobjetivos
 es más amplio que el espacio de estados que se obtiene al aplicar todas
 las reglas en el sistema hacia delante, pero muchas de las descripciones
 de subobjetivos son imposibles, por lo que se pueden podar, reduciendo
 sustancialmente el espacio de búsqueda.
\end_layout

\begin_layout Standard
\noindent
\align left
En la mayoría de problemas del mundo real, la aplicación de cualquiera de
 los dos métodos no es práctica, debido a la cantidad de tiempo y espacio
 requerida para encontrar la solución.
 Dado que no es viable una búsqueda exhaustiva del espacio, se deberán emplear
 heurísticas.
 
\end_layout

\begin_layout Subsubsection
Planificación secuencial usando una pila de objetivos: STRIPS
\end_layout

\begin_layout Standard
\align left
STRIPS es un sistema de planificación lineal, o sea, no se pasa al objetivo
 siguiente hasta que no se ha resuelto completamente el actual.
 Para ello, utiliza una pila de subobjetivos, en lugar de un conjunto, y
 funciona bien cuando no interdepencias o estas son débiles.
\end_layout

\begin_layout Standard
\align left
El pseudocódigo del proceso es:
\end_layout

\begin_layout Standard
\align left
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función STRIPS(estado-inicial, objetivo)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	estado <- estado-inicial; plan <- {}; pila <- {};
\end_layout

\begin_layout Plain Layout

	pila.push(objetivo)
\end_layout

\begin_layout Plain Layout

	repetir hasta VACIO(pila)
\end_layout

\begin_layout Plain Layout

		obj <- pila.head
\end_layout

\begin_layout Plain Layout

		si (MATCH(obj, estado.descripcion)) entonces
\end_layout

\begin_layout Plain Layout

			pila.pop
\end_layout

\begin_layout Plain Layout

			para cada expresión en pila hacer {aplicar la sustitución}
\end_layout

\begin_layout Plain Layout

		sino, si (obj es conjunción de objetivos) entonces
\end_layout

\begin_layout Plain Layout

			objs <- ordenarlos
\end_layout

\begin_layout Plain Layout

			para cada o en objs hacer pila.push(o)
\end_layout

\begin_layout Plain Layout

		sino, si (todos los subobjetivos resueltos Y !(objetivo resuelto)) entonces
\end_layout

\begin_layout Plain Layout

			{reconsiderar objetivo compuesto y apilar}
\end_layout

\begin_layout Plain Layout

		sino, si (obj es un objetivo simple) entonces
\end_layout

\begin_layout Plain Layout

			elegir operador OP tal que EMPAREJA(OP.listaAdicion,obj)
\end_layout

\begin_layout Plain Layout

			REEMPLAZAR(obj, OP)
\end_layout

\begin_layout Plain Layout

			para cada precondicion en OP.listaPrecondiciones hacer pila.push(precondicion)
\end_layout

\begin_layout Plain Layout

		sino, si (obj es un operador OP) entonces
\end_layout

\begin_layout Plain Layout

			estado <- APLICAR(OP, estado)
\end_layout

\begin_layout Plain Layout

			plan <- plan + {OP}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
La componente de control del sistema de resolución asociado a STRIPS debe
 tomar diversas decisiones, entre las que se incluyen:
\end_layout

\begin_layout Enumerate
\align left
Ordenación de las componentes de un objetivo compuesto.
 Se pueden obtener planes subóptimos por una ordenación deficiente de los
 objetivos a satisfacer
\end_layout

\begin_layout Enumerate
\align left
Elección entre las distintas particularizaciones posibles
\end_layout

\begin_layout Enumerate
\align left
Selección de operadores relevantes cuando hay más de uno
\end_layout

\begin_layout Subsubsection*
Ejemplo STRIPS
\end_layout

\begin_layout Standard
\align left
La formulación del problema, visualmente, es
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado10.png

\end_inset


\end_layout

\begin_layout Standard
\align left
Y esto podemos expresarlo como
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
Los operadores disponibles son:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
coger(x)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P y S: Sobremesa(x), Manovacia, Libre(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A: Cogido(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dejar(x)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P y S: Cogido(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A: Sobremesa(x), Libre(x), Manovacia
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
apilar(x,y)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P y S: Cogido(x), Libre(y)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A: Manovacia, Sobre(x,y), Libre(x)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
desapilar(x)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P y S: Manovacia, Libre(x), Sobre(x,y)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A: Cogido(x), Libre(y)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
Como el objetivo es compuesto, se apilan los objetivos simples en un orden
 determinado
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
En la cima de la pila hay un objetivo simple, luego se escoge un operador
 y se añaden sus precondiciones
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(B)
\begin_inset Formula $\land$
\end_inset

Cogido(C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
apilar(C,B)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
En la cima vuelve a haber un objetivo compuesto, se apilan sus objetivos
 simples en un orden determinado
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cogido(C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(B)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(B)
\begin_inset Formula $\land$
\end_inset

Cogido(C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
apilar(C,B)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
A partir del objetivo simple Cogido(c), se escoge un operador y se apilan
 sus precondiciones
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\begin_inset Formula $\land$
\end_inset

Libre
\begin_inset Formula $\land$
\end_inset

Sobre(C,y)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Desapilar(C,y)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cogido(C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(B)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(B)
\begin_inset Formula $\land$
\end_inset

Cogido(C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
apilar(C,B)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
Tras sucesimos emparejamientos de objetivos simples y aplicación de los
 dos operadores que serán añadidos al plan, que ahora mismo será PLAN={Desapilar
(C,A),Apilar(C,B)}, obtenemos
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Graphics
	filename pegado11.png

\end_inset


\end_layout

\begin_layout Standard
\align left
Se escoge ahora el operador apilar y se insertan sus precondiciones en la
 pila
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\begin_inset Formula $\land$
\end_inset

Cogido(A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Apilar(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
Estas precondiciones se apilan una a una
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cogido(A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\begin_inset Formula $\land$
\end_inset

Cogido(A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Apilar(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
Como Libre(C) empareja con el estado, se desapila y continuamos
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cogido(A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\begin_inset Formula $\land$
\end_inset

Cogido(A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Apilar(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
Se selecciona el operador coger y se apilan sus precondiciones
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\begin_inset Formula $\land$
\end_inset

Libre(A)
\begin_inset Formula $\land$
\end_inset

Manovacia
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Coger(A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cogido(A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\begin_inset Formula $\land$
\end_inset

Cogido(A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Apilar(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
Esas precondiciones se apilan una por una, vemos que las tres están en el
 estado luego se desapilarán.
 Estaremos con Coger en el tope de la pila, por lo tanto lo desapilamos
 y los añadimos al plan, PLAN={Desapilar(C,A), Apilar(C,B), Coger(A)} y
 tenemos:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cogido(A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(C)
\begin_inset Formula $\land$
\end_inset

Cogido(A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cogido(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Apilar(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Graphics
	filename pegado12.png

\end_inset


\end_layout

\begin_layout Standard
\align left
Como Cogido(A) se encuentra en el estado, se desapila y habremos completado
 el siguiente objetivo, nos quedaremos con Apilar(A,C) en el tope, que lo
 despilaremos y añadiremos al PLAN={Desapilar(C,A), Apilar(C,B),Coger(A),Apilar(
A,C)}, obtenemos
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Estado
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Objetivo
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Libre(A)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(C,B)
\begin_inset Formula $\land$
\end_inset

Sobre(A,C)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobre(A,C)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sobremesa(B)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Manovacia
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
Y el último subobjetivo queda cumplido, luego hemos terminado, queda PLAN={Desap
ilar(C,A), Apilar(C,B),Coger(A),Apilar(A,C)}.
\end_layout

\begin_layout Subsubsection
Planificación Ordenada Parcialmente
\end_layout

\begin_layout Standard
\align left
Un 
\series bold
planificador no lineal
\series default
 construye un plan cuyo orden no es total.
 Se basan en la posible descomposición del problema, trabajando en varios
 subobjetivos de manera independiente, solucionados con subplanes y creando
 un plan a partir de ellos.
\end_layout

\begin_layout Standard
\align left
La idea básica es trabajar con secuencias de dos acciones, sin distinguir
 el orden dentro de la secuencia.
\end_layout

\begin_layout Standard
\align left
Un 
\series bold
plan de orden parcial (POP)
\series default
 es un grafo de acciones, en el cada una de las soluciones de orden total
 se denomina linealizaciñón del POP.
 Por ejemplo, supongamos que nos queremos calzar, entonces, los distintos
 planes de orden total son
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado13.png

\end_inset


\end_layout

\begin_layout Standard
\align left
Mientras que el POP quedaría
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pegado14.png

\end_inset


\end_layout

\begin_layout Standard
\align left
Y, por lo general, los POP generan un espacio más pequeño, por lo que la
 búsqueda será menos costosa.
\end_layout

\begin_layout Standard
\align left
Las ideas básicas son:
\end_layout

\begin_layout Itemize
\align left
Planificación de compromiso mínimo: escoger solo acciones y particularizaciones
 estrictamente necesarias
\end_layout

\begin_layout Itemize
\align left
Uso de restricciones temporales
\end_layout

\begin_layout Standard
\align left
Los 
\series bold
arcos amenaza
\series default
 representarán situaciones en las que el resultado de aplicar una acción
 influye en la precondición de otra acción, por lo que nos ayudarán a determinar
 el orden en el que deben ocurrir las acciones.
\end_layout

\begin_layout Subsubsection
Planificación Jerárquica
\end_layout

\begin_layout Standard
\align left
La idea de este tipo de planificación es jerarquizar el problema en diferentes
 niveles de complejidad, y resolver gradualmente aumentando progresivamente
 la complejidad.
 Es un enfoque 
\series bold
de arriba a abajo 
\series default
o 
\series bold
top-down
\series default
.
 El sistema de referencia es ABSTRIPS.
\end_layout

\begin_layout Standard
\align left
El principal argumento a su favor es que el resolver un problema medianamente
 coplejo no es posible con un planteamiento de búsqueda completa.
 Así, las 
\series bold
jerarquías
\series default
 se crean dependiendo de valores críticos de las precondiciones de los oepradore
s: a más dificultad de satisfacer la precondición, mayor valor crítico,
 y en cada nivel de la jerarquía se tratan precondiciones con el mismo valor
 crítico, comenzando con las que tienen el mayor, asumiendo las demás satisfecha
s.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introducción al Aprendizaje Computacional
\end_layout

\begin_layout Standard
Con el término 
\series bold
aprendizaje
\series default
 nos referimos al proceso por el que una entidad acrecienta su conocimiento
 y/o habilidad.
 Es un aspecto esencial de la inteligencia.
 Y uno de sus elementos imprescindibles es la experiencia.
\end_layout

\begin_layout Standard
Un programa no puede denominarse inteligente si no tiene capacidades de
 adaptación a cambios.
 Por tanto, es necesario conseguir programas que tengan la habilidad de
 aprender.
\end_layout

\begin_layout Standard
Algunas razones que justifican el aprendizaje computacional son:
\end_layout

\begin_layout Enumerate
Algunas tareas solo pueden describirse bien mediante ejemplos
\end_layout

\begin_layout Enumerate
Es posible que escondidos en una gran cantidad de datos se encuentren relaciones
 y correlaciones valiosas
\end_layout

\begin_layout Enumerate
Algunas máquinas no trabajan tan bien inicialmente como se desearía a largo
 plazo
\end_layout

\begin_layout Enumerate
En ciertos dominios, la cantidad de conocimiento disponible puede sobrepasar
 la capacidad de codificación humana
\end_layout

\begin_layout Enumerate
Los entornos cambian con el tiempo, por lo que los programas deberían adaptarse
 a esos cambios
\end_layout

\begin_layout Enumerate
Constantemente se genera nuevo conocimiento
\end_layout

\begin_layout Subsection
Conceptos básicos
\end_layout

\begin_layout Subsubsection
Tipos de aprendizaje
\end_layout

\begin_layout Itemize

\series bold
Aprendizaje supervisado:
\series default
 la experiencia viene en forma de ejemplos etiquetados
\end_layout

\begin_layout Itemize

\series bold
Aprendizaje no supervisado:
\series default
 la experiencia viene en forma de observaciones del entorno
\end_layout

\begin_layout Subsubsection
Fases del aprendizaje y Proceso de inferencia
\end_layout

\begin_layout Standard
\align left
Las fases del aprendizaje son el entrenamiento y las pruebas.
 
\end_layout

\begin_layout Standard
\align left
Debemos tener en cuenta tanto parámetros externos (aprendidos) como internos
 (no aprendidos).
\end_layout

\begin_layout Standard
\align left
La 
\series bold
base del aprendizaje
\series default
 es la optimización de una función de rendimiento.
\end_layout

\begin_layout Standard
\align left
En la 
\series bold
fase de entrenamiento
\series default
 se distingue entre supervisión o no supervisión.
\end_layout

\begin_layout Standard
\align left
En la 
\series bold
fase de prueba
\series default
 no se hace tal distinción.
\end_layout

\begin_layout Standard
\align left
Por último, queda el proceso de inferencia, que consiste en utilizar el
 sistema entrenado para realizar predicciones a futuro.
\end_layout

\begin_layout Subsubsection
Características deseables de un sistema de aprendizaje
\end_layout

\begin_layout Itemize

\series bold
Precisión
\series default
: fiabilidad del método aprendido, representada normalmente por la proporción
 de ejemplos aprendidos correctamente
\end_layout

\begin_layout Itemize

\series bold
Velocidad
\series default
: rapidez del proceso de predicción, puede que sea preferible reducir la
 precisión si se mejora considerablemente la velocidad
\end_layout

\begin_layout Itemize

\series bold
Comprensión
\series default
: si es un operador humano el que usa el modelo aprendido, debe ser fácil
 de entender para evitar errors
\end_layout

\begin_layout Itemize

\series bold
Tiempo en aprender
\series default
: de especial importancia en aprendizaje online aplicado a sistemas que
 cambian rápidamente.
 Puede implicar la necesidad de un número pequeño de observaciones para
 obtener un modelo adecuado
\end_layout

\begin_layout Subsubsection
Estimación del error
\end_layout

\begin_layout Standard
\align left
La 
\series bold
matriz de confusión
\series default
 sirve para determinar la precisión de un sistema de clasificación binario
 (en el que solo hay dos categorías) y tiene la siguiente forma
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicción
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Realidad
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verdaderos negativos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Falsos positivos
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Falsos negativos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Verdaderos positivos
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
La matriz de confusión puede generalizarse para una cantidad arbitraria
 de categorías, donde la posición 
\begin_inset Formula $x_{ij}$
\end_inset

 indica que el objeto es realmente de categoría 
\begin_inset Formula $i$
\end_inset

 y ha sido clasificado como de categoría 
\begin_inset Formula $j$
\end_inset

 (obviamente puede ser 
\begin_inset Formula $i=j$
\end_inset

).
\end_layout

\begin_layout Standard
\align left
Algunos estimadores del error son:
\end_layout

\begin_layout Itemize
\align left

\series bold
Estimador del error de los ejemplos
\series default
: sea 
\begin_inset Formula $N$
\end_inset

 el número de ejemplos y sea 
\begin_inset Formula $E$
\end_inset

 el número de veces que el modelo se equivoca.
 El estimador del error es 
\begin_inset Formula $\frac{E}{N}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\align left
Es un buen estimador si los ejemplos no fueron utilizados en el proceso
 de aprendizaje.
\end_layout

\end_deeper
\begin_layout Itemize
\align left

\series bold
Estimando el error de resustitución
\series default
: usamos para estimar el error el mismo conjunto de datos que para el entrenamie
nto.
 Por tanto, será una aproximación optimista al error real, tiende a subestimarlo.
\end_layout

\begin_layout Itemize
\align left

\series bold
Estimación del error por validación cruzada (cross validation)
\series default
: se usa para estimar el error de un método, no de un modelo concreto.
 Es muy útil en casos con escasos datos.
 Se sigue el siguiente procedimiento:
\end_layout

\begin_deeper
\begin_layout Enumerate
\align left
Dividir el conjunto de ejemplos 
\begin_inset Formula $S$
\end_inset

 en 
\begin_inset Formula $k$
\end_inset

 partes disjuntas de tamaño similar
\end_layout

\begin_layout Enumerate
\align left
Para 
\begin_inset Formula $i=1...k$
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
\align left
Se construye el modelo usando el método sobre el conjunto 
\begin_inset Formula $S\setminus S_{i}$
\end_inset


\end_layout

\begin_layout Enumerate
\align left
Se determina el estimador del error de los ejemplos 
\begin_inset Formula $R_{i}$
\end_inset

 usando el conjunto de prueba 
\begin_inset Formula $S_{i}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\align left
Se calcula el estimador del error por validación cruzada como
\begin_inset Formula 
\[
\sum_{i=1}^{k}\frac{\left|S_{i}\right|}{\left|S\right|}R_{i}
\]

\end_inset

 con 
\begin_inset Formula $\left|S_{i}\right|,\left|S\right|$
\end_inset

 los cardinales de 
\begin_inset Formula $S_{i}$
\end_inset

 y 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Standard
\align left
Así, este método realiza varias estimaciones a partir de diferentes combinacione
s de conjuntos de entrenamiento y prueba, y las agrega.
 Si seleccionamos 
\begin_inset Formula $k=10$
\end_inset

, estamos ante 
\series bold
10-fold cross-validation
\series default
.
 Otro caso particular es el 
\series bold
leave-one-out
\series default
 consistente en hacer 
\begin_inset Formula $k=\left|S\right|$
\end_inset

, es decir, se toman los conjuntos unipuntuales.
\end_layout

\begin_layout Standard
\align left
Es bastante costoso, por lo que se usa con conjuntos pequeños, donde estimar
 simplemente el error de los ejemplos puede no resultar significativo.
\end_layout

\end_deeper
\begin_layout Standard
\align left
En algunos dominios, algunos errores son más costosos que otros (por ejemplo,
 en diagnóstico médico un falso negativo puede costar la vida al paciente).
\end_layout

\begin_layout Standard
\align left
Así, tiene sentido poner costes a los fallos.
 La expresión del coste de cada error se especifica con una matriz análoga
 a la matriz de confusión, denominada 
\series bold
matriz de costos
\series default
, y donde 
\begin_inset Formula $c_{ij}$
\end_inset

 es el coste de clasificar un objeto de la clase 
\begin_inset Formula $i$
\end_inset

 como si fuese de la 
\begin_inset Formula $j$
\end_inset

, por ejemplo, podría ser
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Predicción
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Realidad
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
False
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\align left
Si 
\begin_inset Formula $E_{ij}$
\end_inset

 es el número de ejemplos de clase 
\begin_inset Formula $i$
\end_inset

 clasificados como de la clase 
\begin_inset Formula $j$
\end_inset

, el 
\series bold
estimador del coste de la mala clasificación
\series default
 es
\begin_inset Formula 
\[
c=\sum_{i=1}^{N}\sum_{j=1}^{N}c_{ij}E_{ij}
\]

\end_inset


\end_layout

\begin_layout Standard
\align left
Cuando el modelo no es de clasificación, sino que es numérico, un buen estimador
 es el 
\series bold
error cuadrático medio (MSE)
\series default
:
\begin_inset Formula 
\[
MSE=\frac{\sum_{i=1}^{N}\left(y_{i}^{*}-y_{i}\right)^{2}}{N}
\]

\end_inset

 donde 
\begin_inset Formula $y_{i}^{*}$
\end_inset

 es el valor real e 
\begin_inset Formula $y_{i}$
\end_inset

 es el inferido por el modelo.
\end_layout

\begin_layout Subsection
Algunos Sistemas Básicos de Aprendizaje e Inferencia
\end_layout

\begin_layout Subsubsection
Aprendizaje Memorístico
\end_layout

\begin_layout Standard
\align left
La idea básica es almacenar todo el nuevo conocimiento para utilizarlo cuando
 sea preciso.
 Todo sistema de aprendizaje debe recordar lo aprendido para poder utilizarlo
 en el futuro, por lo que esta parte puede estar integrada en un sistema
 aprendiz más complejo.
\end_layout

\begin_layout Standard
\align left
Lo que hará será tomar problemas ya resueltos por el sistema, y memorizarlos
 junto con su solución.
\end_layout

\begin_layout Standard
En el aprendizaje memorístico podemos destacar algunos elementos:
\end_layout

\begin_layout Itemize

\series bold
Organización de la memoria
\series default
: se ha de utilizar memorización siempre que sea más conveniente que recalcular
\end_layout

\begin_layout Itemize

\series bold
Estabilidad del entorno
\series default
: la memoria solo es útil si los recuerdos sirven para resolver problemas
 futuros.
 Por tanto, en entornos rápidamente cambiantes, lo almacenado puede quedar
 desfasado rápidamente, y no es conveniente usarlo en este caso
\end_layout

\begin_layout Itemize

\series bold
Almacenamiento frente a recálculo
\series default
: el aprendizaje por memorización debe ser eficiente.
 Se pueden seguir dos enfoques para conseguir esta eficiencia:
\end_layout

\begin_deeper
\begin_layout Itemize
Análisis coste-beneficio: cada vez que llega nueva información, se decide
 si se almacena o no
\end_layout

\begin_layout Itemize
Olvido selectivo: se almacena todo y se olvida lo que se usa poco frecuentemente
\end_layout

\end_deeper
\begin_layout Subsubsection
Aprendizaje en la resolución de problemas
\end_layout

\begin_layout Standard
\align left
Un programa para resolver problemas puede aprender a partir de la generalización
 de sus propias experiencias:
\end_layout

\begin_layout Itemize
\align left
al resolver un problema, puede recordarse su estructura, lo métodos que
 llevaron a su solución, y esta solución
\end_layout

\begin_layout Itemize
\align left
más adelante, podemos utilziar esta experiencia si nos encontramos con el
 mismo problema, o generalizarla para que pueda ser usada ante problemas
 similares
\end_layout

\begin_layout Standard
\align left
STRIPS, para llevar a cabo esta función, da uso a 
\series bold
macro-operadores
\series default
, que consisten en que, tras cada episodio de planificación, un componente
 de STRIPS toma el plan calculado o una parte del mismo, y lo transforma
 en un macro-operador, que consiste en:
\end_layout

\begin_layout Itemize
\align left
precondiciones: las condiciones iniciales del problema resuelto
\end_layout

\begin_layout Itemize
\align left
postcondiciones: el objetivo alcanzado mediante el plan utilizado
\end_layout

\begin_layout Standard
\align left
O sea, que es un nuevo operador, que abstrae un conjunto de operadores básicos
 del sistema ejecutados en un cierto orden.
 Se trata como un operador normal.
\end_layout

\begin_layout Standard
\align left
No obstante, raramente se presenta el mismo problema dos veces, por lo que
 es preciso generalizar, transformando el macro-operador en uno más genérico
 que pueda ser equiparado con una familia de problemas, y no únicamente
 con el problema que lo generó.
 Para este propósito, se sustituyen las constantes por variables.
 
\end_layout

\begin_layout Standard
\align left
Pero, a menudo, la generalización no es tan directa, y algunas constantes
 deben retener su valor.
 Esto plantea algunas dificultades, pues debemos determinar qué constantes
 podemos cambiar por variables, y cuáles deben permanecer como están.
\end_layout

\begin_layout Standard
\align left
Así, el proceso de generalización que aplica STRIPS es un proceso complejo
 que hace los siguientes pasos:
\end_layout

\begin_layout Enumerate
\align left
Sustituye todas las constantes por variables
\end_layout

\begin_layout Enumerate
\align left
Reevalúa todas las precondiciones de cada operador del plan parametrizado.
 Aquellas precondiciones que requieran que alguna variable tome siempre
 un valor concreto, obligan al sistema a hacer que ese parámetro no sea
 una variable, sino ese valor específico
\end_layout

\begin_layout Standard
\align left
Los macro-operadores, bien utilizados, resultan muy útiles.
 Un macro-operador puede dar lugar a un pequeño cambio global en el mundo,
 aunque los operadores individuales que lo forman produzcan muchos cambios
 locales no buscados.
\end_layout

\begin_layout Subsubsection
Aprendizaje de Reglas de Asociación
\end_layout

\begin_layout Standard
Una 
\series bold
regla de asociación
\series default
 relaciona los distintos elementos que pueden aparecer en una base de datos
 relacional o transaccional.
 A diferencia de las reglas de un SBR, no expresa causalidad.
 Se obtienen a partir de observaciones:
\end_layout

\begin_layout Itemize
aquellas cuyo antecedente y consecuente son ciertos en muchas de las observacion
es se dice que tienen una 
\series bold
cobertura alta
\end_layout

\begin_layout Itemize
aquellas que, en las observaciones, cuando se cumple el antecedente también
 suele cumplirse el consecuente, se dice que tienen una 
\series bold
confianza alta
\end_layout

\begin_layout Standard
Nuestro objetivo es, por tanto, encontrar reglas interesantes, con valores
 buenos de cobertura y confianza.
\end_layout

\begin_layout Standard
Encontrar todos los subconjuntos frecuentes de la base de datos es difícil
 ya que esto implica considerar todos los posibles subconjuntos de items
 (combinaciones de items).
 El conjunto de posibles conjuntos de items es el conjunto potencia de 
\begin_inset Formula $I$
\end_inset

 y su tamaño es de 
\begin_inset Formula ${\displaystyle 2^{n}-1}$
\end_inset

 (excluyendo el conjunto vacío que no es válido como conjunto de items).
 Aunque el tamaño del conjunto potencia crece exponencialmente con el número
 de ítems, 
\begin_inset Formula $n$
\end_inset

, de 
\begin_inset Formula $I$
\end_inset

, es posible hacer una búsqueda eficiente utilizando la propiedad "downward-clos
ure" del soporte (también llamada anti-monótona) que garantiza que para
 un conjunto de items frecuente, todos sus subconjuntos también son frecuentes,
 y del mismo modo, para un conjunto de items infrecuente, todos sus superconjunt
os deben ser infrecuentes.
 Explotando esta propiedad se han diseñado algoritmos eficientes para encontrar
 los items frecuentes.
\end_layout

\begin_layout Standard
Notación:
\end_layout

\begin_layout Itemize
\begin_inset Formula $I=\left\{ I_{1},...,I_{n}\right\} $
\end_inset

 es un conjunto de 
\begin_inset Formula $n$
\end_inset

 atributos arbitrarios, llamados ítems
\end_layout

\begin_layout Itemize
\begin_inset Formula $D=\left\{ t_{1},...,t_{m}\right\} $
\end_inset

 es un conjunto de 
\begin_inset Formula $m$
\end_inset

 ejemplares o transacciones de un problema
\end_layout

\begin_layout Itemize
\begin_inset Formula $t_{i}$
\end_inset

 también se denomina 
\begin_inset Formula $itemset$
\end_inset

, es un conjunto de items de 
\begin_inset Formula $I$
\end_inset


\end_layout

\begin_layout Standard
Una 
\series bold
regla de asociación
\series default
 será una expresión de la forma 
\begin_inset Formula 
\[
X\implies Y
\]

\end_inset

 donde 
\begin_inset Formula $X,Y\subset I$
\end_inset

 y 
\begin_inset Formula $X\cap Y=\emptyset$
\end_inset

.
 Y, definimos las medidas anteriores de forma precisa:
\end_layout

\begin_layout Itemize

\series bold
Confianza
\series default
: la confianza de una regla 
\begin_inset Formula $X\implies Y$
\end_inset

 se interpreta como la probabilidad de que una trasacción que contiene los
 ítems de 
\begin_inset Formula $X$
\end_inset

 también contenga los ítems de 
\begin_inset Formula $Y$
\end_inset

:
\begin_inset Formula 
\[
c\left(X\implies Y\right)=P\left(Y|X\right)=\frac{\left|\left\{ X\cup Y\subset t_{k}\right\} \right|}{\left|\left\{ X\subset t_{k}\right\} \right|}
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Soporte
\series default
: el soporte de una regla 
\begin_inset Formula $X\implies Y$
\end_inset

 se interpreta como la probabilidad de que una transacción contenga a todos
 los ítems de 
\begin_inset Formula $X$
\end_inset

 y de 
\begin_inset Formula $Y$
\end_inset


\begin_inset Formula 
\[
s\left(X\implies Y\right)=P\left(X\cup Y\right)=\frac{\left|\left\{ X\cup Y\subset t_{k}\right\} \right|}{\left|D\right|}
\]

\end_inset

 
\end_layout

\begin_layout Standard
Nos interesan reglas con mucho soporte, por lo que buscamos pares 
\begin_inset Formula $\left(atributo,valor\right)$
\end_inset

 que cubran una gran cantidad de transacciones o itemsets.
 Una vez tenemos los itemsets, los transformamos en reglas.
\end_layout

\begin_layout Standard
Para obtener las reglas, usaremos un proceso de dos fases:
\end_layout

\begin_layout Enumerate
Generar todas las posibles combinaciones de ítems, entendiendo estas como
 itemsets, con un soporte por encima de un mínimo
\end_layout

\begin_layout Enumerate
Dado un itemset frecuente 
\begin_inset Formula $Y=\left\{ i_{1},...,i_{k}:k\geq2\right\} $
\end_inset

, generamos todas las reglas que contengan todos los items de ese itemset,
 generando todos los
\begin_inset Formula 
\[
X\implies\left(Y\setminus X\right)
\]

\end_inset

 donde 
\begin_inset Formula $\emptyset\neq X\subset Y$
\end_inset

 que verifique que su confianza es mayor que la mínima requerida:
\begin_inset Formula 
\[
c\left(X\implies\left(Y\setminus X\right)\right)=\frac{s\left(Y\right)}{s\left(X\right)}\geq c_{min}
\]

\end_inset


\end_layout

\begin_layout Subsubsection*
Algoritmo A PRIORI
\end_layout

\begin_layout Standard
Definimos los itemsets frecuentes como aquellos itemsets con soporte mínimo.
 Como hemos mencionado antes, se verifica:
\end_layout

\begin_layout Itemize
Un subconjunto de un itemset frecuente es también un itemset frecuente
\end_layout

\begin_layout Itemize
Si un itemset no satisface el soporte mínimo, ningún superconjunto suyo
 lo satisface
\end_layout

\begin_layout Standard
Así, iterativamente, se encuentran itemsets frecuentes con cardinalidad
 1 hasta 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Standard

\series bold
Fase 1
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función APRIORI
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	Ck: itemsets candidatos de tamaño k
\end_layout

\begin_layout Plain Layout

	Lk: itemsets frecuentes de tamaño k
\end_layout

\begin_layout Plain Layout

	L1 = {itemsets frecuentes de tamaño 1}
\end_layout

\begin_layout Plain Layout

	para (k=1; !VACIO(Lk); k++) hacer
\end_layout

\begin_layout Plain Layout

		C_{k+1}=APRIORI-CANDIDATOS(Lk)
\end_layout

\begin_layout Plain Layout

		para cada transaccion t en D hacer
\end_layout

\begin_layout Plain Layout

			Ct=subset(C_{k+1},t)
\end_layout

\begin_layout Plain Layout

			para cada candidato c en Ct hacer c.count++
\end_layout

\begin_layout Plain Layout

		L_{k+1}={c en C_{k+1}|c.count > minSoporte}
\end_layout

\begin_layout Plain Layout

	devolver {la unión de todos los Lk}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

función APRIORI-CANDIDATOS(Lk)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	FASE DE FORMACIÓN
\end_layout

\begin_layout Plain Layout

		insertar en C_{k+1} todas las combinaciones de los itemsets desde Lk para
 formar itemsets de tamaño k+1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	FASE DE PODA
\end_layout

\begin_layout Plain Layout

		para cada itemset c en C_{k+1} hacer
\end_layout

\begin_layout Plain Layout

			para cada k-subconjunto s de c hacer
\end_layout

\begin_layout Plain Layout

				si s notin Lk entonces
\end_layout

\begin_layout Plain Layout

					borrar c de C_{k+1}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	devolver C_{k+1}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
FASE 2
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "numbers=left,stepnumber=5,breaklines=true"
inline false
status open

\begin_layout Plain Layout

función GENERAR-REGLAS-APRIORI
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	para cada (itemset-frecuente f) hacer
\end_layout

\begin_layout Plain Layout

		generar todos los k-subconjuntos no vacíos de f con k>=2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	para cada (k-subconjunto no vacío, S, de f) hacer
\end_layout

\begin_layout Plain Layout

		si s(f)/s(S) >= minConfianza entonces
\end_layout

\begin_layout Plain Layout

			regla de salida (s -> (f-s))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
